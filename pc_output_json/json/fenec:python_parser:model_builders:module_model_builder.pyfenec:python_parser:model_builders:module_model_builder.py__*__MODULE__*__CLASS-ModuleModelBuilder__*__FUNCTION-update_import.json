{
    "function_name": "update_import",
    "docstring": "Update an import in the imports list.\n\nLoops through the imports list and replaces the old import with the updated import.\n\nArgs:\n    updated_import_model (ImportModel): The updated import model.\n    old_import_model\n\nReturns:\n    ModuleModelBuilder: The module model builder instance.\n\nRaises:\n    Exception: If the import to be updated is not found.",
    "decorators": null,
    "parameters": null,
    "returns": "No return annotation",
    "is_method": true,
    "is_async": false,
    "id": "fenec:python_parser:model_builders:module_model_builder.py__*__MODULE__*__CLASS-ModuleModelBuilder__*__FUNCTION-update_import",
    "file_path": "fenec/python_parser/model_builders/module_model_builder.py",
    "parent_id": "fenec:python_parser:model_builders:module_model_builder.py__*__MODULE__*__CLASS-ModuleModelBuilder",
    "block_type": "FUNCTION",
    "start_line_num": 85,
    "end_line_num": 132,
    "code_content": "\ndef update_import(\n    self, updated_import_model: ImportModel, old_import_model: ImportModel\n) -> \"ModuleModelBuilder\":\n    \"\"\"\n        Update an import in the imports list.\n\n        Loops through the imports list and replaces the old import with the updated import.\n\n        Args:\n            updated_import_model (ImportModel): The updated import model.\n            old_import_model\n\n        Returns:\n            ModuleModelBuilder: The module model builder instance.\n\n        Raises:\n            Exception: If the import to be updated is not found.\n        \"\"\"\n    if self.module_attributes.imports:\n        import_to_remove: ImportModel | None = None\n        for existing_import in self.module_attributes.imports:\n            if (\n                existing_import.import_names == old_import_model.import_names\n                and existing_import.imported_from == old_import_model.imported_from\n                and existing_import.import_module_type\n                == old_import_model.import_module_type\n            ):\n                import_to_remove = existing_import\n                # if \"OpenAISummarizer\" in [\n                #     name.name for name in existing_import.import_names\n                # ]:\n                #     print(\"Updating OpenAISummarizer import\")\n                break\n\n        if not import_to_remove:\n            # raise Exception(f\"Could not find import to remove: {old_import_model}\")\n            # print(f\"Could not find import to remove: {old_import_model}\")\n            ...\n        else:\n            self.module_attributes.imports.remove(import_to_remove)\n            self.module_attributes.imports.append(updated_import_model)\n    else:\n        raise Exception(\n            f\"No imports in the builders imports list: {self.module_attributes.imports}\"\n        )\n    return self\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "The code defines a method `update_import` within a class, likely part of a module management system, designed to update an import statement in a list of imports. The primary purpose of this method is to iterate through a list of import models, identify an existing import that matches the specified old import model, and replace it with a new, updated import model. This functionality is crucial for maintaining the accuracy and currency of module dependencies, ensuring that the module's import statements reflect the latest changes in the codebase.\n\nKey components include the `update_import` method itself, which takes two arguments: `updated_import_model` and `old_import_model`, both of which are instances of the `ImportModel` class. The method returns an instance of `ModuleModelBuilder`, indicating that it is part of a builder pattern for constructing or modifying module models. The implementation involves a loop that checks each import in the `module_attributes.imports` list against the `old_import_model` based on attributes like `import_names`, `imported_from`, and `import_module_type`. If a match is found, the old import is removed and replaced with the `updated_import_model`. The method raises an exception if the import to be updated is not found, ensuring robust error handling.\n\nThe technical stack is not explicitly mentioned, but it likely involves custom classes such as `ImportModel` and `ModuleModelBuilder`, which are part of the system's internal architecture. These classes are designed to encapsulate the details of import statements and module construction, respectively, providing a structured way to manage and update module dependencies.\n\nIn the context of a larger project, this method is integral to a dynamic module management system, which may be part of a larger code analysis or refactoring tool. It interacts with other components of the module management system, potentially integrating with tools that analyze or modify code structures. This method ensures that any changes in the codebase, such as renaming or relocating modules, are accurately reflected in the import statements, thereby maintaining the integrity and functionality of the software system. The commented-out code suggests potential logging or debugging features, indicating that the system may include mechanisms for tracking changes or updates to specific imports, such as the \"OpenAISummarizer\" import.",
    "children_ids": []
}