{
    "function_name": "_process_summarization_map",
    "docstring": "Processes a summarization map to create or update summaries for models.\n\nArgs:\n    - `summarization_map` (list[ModelType]): The map of models to summarize.\n    - `pass_number` (int): The current summarization pass number.\n    - `models` (list[ModelType] | None): Previously summarized models (if any).\n    - `top_down` (bool): Whether this is a top-down summarization pass.\n\nReturns:\n    - `list[ModelType] | None`: Updated list of models with new summaries.",
    "decorators": null,
    "parameters": null,
    "returns": "list[ModelType] | None",
    "is_method": true,
    "is_async": false,
    "id": "fenec:ai_services:summarizer:graph_db_summarization_manager.py__*__MODULE__*__CLASS-GraphDBSummarizationManager__*__FUNCTION-_process_summarization_map",
    "file_path": "fenec/ai_services/summarizer/graph_db_summarization_manager.py",
    "parent_id": "fenec:ai_services:summarizer:graph_db_summarization_manager.py__*__MODULE__*__CLASS-GraphDBSummarizationManager",
    "block_type": "FUNCTION",
    "start_line_num": 153,
    "end_line_num": 254,
    "code_content": "\ndef _process_summarization_map(\n    self,\n    summarization_map: list[ModelType],\n    pass_number: int,\n    models: list[ModelType] | None = None,\n    top_down: bool = False,\n) -> list[ModelType] | None:\n    \"\"\"\n        Processes a summarization map to create or update summaries for models.\n\n        Args:\n            - `summarization_map` (list[ModelType]): The map of models to summarize.\n            - `pass_number` (int): The current summarization pass number.\n            - `models` (list[ModelType] | None): Previously summarized models (if any).\n            - `top_down` (bool): Whether this is a top-down summarization pass.\n\n        Returns:\n            - `list[ModelType] | None`: Updated list of models with new summaries.\n        \"\"\"\n    models_to_summarize_count: int = len(summarization_map)\n    models_summarized_count: int = 0\n\n    for model in summarization_map:\n        models_summarized_count += 1\n        if isinstance(model, ImportModel):\n            import_details = self._get_import_details(model)\n        else:\n            import_details = None\n        logging.info(\n            f\"Summarizing model {models_summarized_count} out of {models_to_summarize_count}; {model.id}.\"\n        )\n\n        # Check if the model is an instance of ImportModel before calling _get_import_details\n        if isinstance(model, ImportModel):\n            import_details = self._get_import_details(model)\n\n        children_summaries: str | None = self._get_child_summaries(model)\n        dependency_summaries: str | None = self._get_dependencies_summaries(model)\n\n        parent_summary: str | None = None\n        if top_down and models:\n            parent_model = next(\n                (m for m in models if m.id == model.parent_id), None\n            )\n            if parent_model:\n                parent_summary = parent_model.summary\n\n        code_content: str = (\n            model.code_content if not isinstance(model, DirectoryModel) else \"\"\n        )\n\n        previous_summary: str | None = None\n        if not pass_number == 1:\n            previous_summary = model.summary\n\n        if isinstance(self.summarizer, OllamaSummarizer):\n            model_summary: str | None = self.summarizer.summarize_code(\n                code_content,\n                model_id=model.id,\n                children_summaries=children_summaries,\n                dependency_summaries=dependency_summaries,\n                import_details=import_details,\n                parent_summary=parent_summary,\n                pass_number=pass_number,\n                previous_summary=previous_summary,\n            )\n            if model_summary:\n                stripped_summary: str = model_summary.strip()\n                print(f\"[blue]Summary: [/blue]{stripped_summary}\")\n                self.graph_manager.update_vertex_summary_by_id(\n                    model.id, stripped_summary\n                )\n                model.summary = stripped_summary\n        else:\n            summary_return_context: OpenAIReturnContext | str | None = (\n                self.summarizer.summarize_code(\n                    code_content,\n                    model_id=model.id,\n                    children_summaries=children_summaries,\n                    dependency_summaries=dependency_summaries,\n                    import_details=import_details,\n                    parent_summary=parent_summary,\n                    pass_number=pass_number,\n                    previous_summary=previous_summary,\n                )\n            )\n            if summary_return_context and isinstance(\n                summary_return_context, OpenAIReturnContext\n            ):\n                if summary_return_context.summary:\n                    self.graph_manager.update_vertex_summary_by_id(\n                        model.id, summary_return_context.summary\n                    )\n                    model.summary = summary_return_context.summary\n                print(summary_return_context.summary)\n                self.prompt_tokens += summary_return_context.prompt_tokens\n                self.completion_tokens += summary_return_context.completion_tokens\n                logging.info(f\"Total cost: ${self.total_cost:.2f}\")\n\n    return self.graph_manager.get_all_vertices() if self.graph_manager else None\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "The `_process_summarization_map` method is a pivotal function within a summarization framework designed to generate or update summaries for a collection of models, which likely represent code or data structures. Its primary purpose is to iterate over a `summarization_map`, a list of models, and create or update their summaries by leveraging contextual information such as import details, child and dependency summaries, and parent summaries. This method is significant as it ensures that each model's summary is current and reflective of its context within the system, facilitating accurate analysis and visualization.\n\nKey components of this method include: the `_process_summarization_map` function itself, which orchestrates the summarization process; the `OllamaSummarizer` and `OpenAIReturnContext` classes, which are responsible for generating summaries; and the `graph_manager`, which manages the storage and retrieval of model summaries. The method also interacts with custom model types like `ImportModel` and `DirectoryModel`, which are part of the summarization framework.\n\nThe implementation involves iterating through each model in the `summarization_map`, checking if the model is an instance of `ImportModel` to fetch import details, and using the summarizer to generate a summary based on the model's code content and contextual information. The method supports both top-down and iterative summarization passes, updating the model's summary in the graph manager if a new summary is generated. It uses conditional logic to handle different types of models and summarizers, ensuring flexibility and adaptability in the summarization process. The method also tracks the number of models processed and utilizes a generator expression to efficiently find parent models when performing top-down summarization.\n\nThe technical stack includes custom classes like `ImportModel`, `DirectoryModel`, and `OllamaSummarizer`, which are likely part of a larger summarization framework. The code also potentially utilizes external APIs like OpenAI for generating summaries, as indicated by the use of `OpenAIReturnContext`. The `graph_manager` is a critical component that interfaces with the summarization process to maintain an updated graph of model summaries.\n\nIn the context of a larger system, this method is part of a summarization pipeline that processes models to maintain an updated graph of model summaries. It interacts with a graph manager to ensure that the summaries are stored and retrievable, facilitating further analysis or visualization within the system. This method is integral to the system's ability to provide accurate and contextually relevant summaries, which are essential for understanding the relationships and dependencies between different models in the codebase. The modular design of the method allows it to be easily integrated into various stages of the summarization process, supporting both initial and subsequent passes of summarization.",
    "children_ids": []
}