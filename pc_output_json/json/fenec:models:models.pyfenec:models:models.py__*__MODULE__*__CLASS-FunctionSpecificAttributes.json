{
    "class_name": "FunctionSpecificAttributes",
    "decorators": null,
    "bases": [
        "BaseModel"
    ],
    "docstring": "Function specific attributes.",
    "keywords": null,
    "id": "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models:models.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 895,
    "end_line_num": 1006,
    "code_content": "\n\nclass FunctionSpecificAttributes(BaseModel):\n    \"\"\"Function specific attributes.\"\"\"\n\n    function_name: str = Field(min_length=1)\n    docstring: str | None = None\n    decorators: list[DecoratorModel] | None = None\n    parameters: ParameterListModel | None = None\n    returns: str | None = None\n    is_method: bool = False\n    is_async: bool = False\n\n    def _convert_docstring_to_metadata(self) -> str:\n        \"\"\"Converts the docstring to a metadata string.\"\"\"\n        return f\"{self.docstring}\" if self.docstring else \"\"\n\n    def _convert_decorators_to_metadata(self) -> str:\n        \"\"\"Converts the decorators to a metadata string.\"\"\"\n        decorators_str: str = self.model_dump_json() if self.decorators else \"\"\n        return f\"{decorators_str}\"\n\n    def _convert_parameters_to_metadata(self) -> str:\n        \"\"\"Converts the parameters to a metadata string.\"\"\"\n        return (\n            self.parameters.convert_parameters_to_metadata() if self.parameters else \"\"\n        )\n\n    def _convert_returns_to_metadata(self) -> str:\n        \"\"\"Converts the returns to a metadata string.\"\"\"\n        return f\"{self.returns}\" if self.returns else \"\"\n\n    def _convert_function_attributes_to_metadata_dict(self) -> dict[str, str | bool]:\n        \"\"\"Converts the function attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"function_name\": self.function_name,\n            \"docstring\": self._convert_docstring_to_metadata(),\n            \"decorators\": self._convert_decorators_to_metadata(),\n            \"parameters\": self._convert_parameters_to_metadata(),\n            \"returns\": self._convert_returns_to_metadata(),\n            \"is_method\": self.is_method,\n            \"is_async\": self.is_async,\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | bool]\n    ) -> \"FunctionSpecificAttributes\":\n        \"\"\"Builds a FunctionSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            function_name = metadata.get(\"function_name\")\n            if not isinstance(function_name, str):\n                raise ValueError(\"Function name must be a string.\")\n\n            docstring = metadata.get(\"docstring\")\n            if not isinstance(docstring, str):\n                raise ValueError(\"Docstring must be a string.\")\n\n            decorators_data = metadata.get(\"decorators\", [])\n            if not isinstance(decorators_data, list):\n                raise ValueError(\"Decorators must be a list.\")\n\n            decorators: list[DecoratorModel] = []\n            for decorator_data in decorators_data:\n                if not isinstance(decorator_data, dict):\n                    raise ValueError(\"Each decorator must be a dictionary.\")\n                decorator: DecoratorModel = DecoratorModel._build_from_metadata(\n                    decorator_data\n                )\n                decorators.append(decorator)\n\n            parameters_data = metadata.get(\"parameters\")\n            if not isinstance(parameters_data, dict):\n                raise ValueError(\"Parameters must be a dictionary.\")\n\n            parameters: ParameterListModel = ParameterListModel._build_from_metadata(\n                parameters_data\n            )\n\n            returns = metadata.get(\"returns\")\n            if not isinstance(returns, str):\n                raise ValueError(\"Returns must be a string.\")\n\n            is_method = metadata.get(\"is_method\")\n            if not isinstance(is_method, bool):\n                raise ValueError(\"is_method must be a boolean.\")\n\n            is_async = metadata.get(\"is_async\")\n            if not isinstance(is_async, bool):\n                raise ValueError(\"is_async must be a boolean.\")\n\n            return cls(\n                function_name=function_name,\n                docstring=docstring,\n                decorators=decorators,\n                parameters=parameters,\n                returns=returns,\n                is_method=is_method,\n                is_async=is_async,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n",
    "important_comments": null,
    "dependencies": [
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
        },
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ParameterListModel"
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        }
    ],
    "summary": "The code defines a Python class `FunctionSpecificAttributes`, which is designed to encapsulate and process the attributes of a Python function, converting them into structured metadata suitable for storage or further processing, particularly in the context of ChromaDB, a database optimized for handling metadata. The primary goal of this class is to provide a comprehensive framework for capturing function-specific details such as the function name, docstring, decorators, parameters, return type, and flags indicating whether the function is a method or asynchronous. This metadata is crucial for tasks like documentation generation, code analysis, or database integration, enhancing the system's ability to manage and utilize function-related information efficiently.\n\nKey components of the code include the `FunctionSpecificAttributes` class, which inherits from `BaseModel` to leverage data validation and structured data representation; methods such as `_convert_docstring_to_metadata`, `_convert_decorators_to_metadata`, `_convert_parameters_to_metadata`, and `_convert_returns_to_metadata`, which handle the conversion of respective attributes to metadata strings; `_convert_function_attributes_to_metadata_dict`, which aggregates all function attributes into a metadata dictionary; and `_build_from_meta`, a class method that reconstructs a `FunctionSpecificAttributes` instance from a metadata dictionary, ensuring data integrity and type correctness.\n\nThe implementation employs a structured approach to data conversion and validation, using Python's type hinting and data validation features. It ensures that each attribute is correctly typed and formatted before being processed into metadata, with robust error handling that raises exceptions when metadata does not meet expected types. The design pattern used here is a combination of the builder pattern for constructing objects from metadata and the factory method pattern for creating instances from structured data. The code also utilizes helper methods from custom classes like `DecoratorModel` and `ParameterListModel` to handle specific attribute types, demonstrating a modular design that promotes code reuse and separation of concerns.\n\nThe technical stack includes Python's type hinting and data validation capabilities, with dependencies on `BaseModel` for structured data representation, `Field` for defining constraints on data fields, and custom models like `DecoratorModel` and `ParameterListModel` for handling specific attribute types. These components work together to provide a comprehensive framework for function metadata management.\n\nIn the broader context, this code is likely part of a larger system that requires detailed function metadata for various purposes, such as enhancing code documentation, performing static code analysis, or integrating with a database like ChromaDB. It interacts with other components that provide or consume function metadata, ensuring seamless data flow and integrity within the system. This class could be a critical part of a metadata management module, interfacing with other parts of the system that handle data storage, retrieval, and analysis, thereby contributing to the overall functionality and efficiency of the project. By converting function attributes into a structured format, this utility supports the indexing and search functionalities of ChromaDB, enabling efficient retrieval of function-related information and enhancing the system's ability to generate comprehensive and structured documentation, improving code maintainability and readability across the project.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_convert_docstring_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_convert_decorators_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_convert_parameters_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_convert_returns_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_convert_function_attributes_to_metadata_dict",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_build_from_meta"
    ]
}