{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ImportModuleType",
                    "as_name": null,
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-ImportModuleType"
                },
                {
                    "name": "CommentType",
                    "as_name": null,
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-CommentType"
                },
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-BlockType"
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:enums.py__*__MODULE"
        }
    ],
    "id": "fenec:models:models.py__*__MODULE",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 1322,
    "code_content": "import logging\nfrom pydantic import BaseModel, Field, field_validator\n\nfrom fenec.models.enums import (\n    BlockType,\n    ImportModuleType,\n    CommentType,\n)\n\n\nclass ImportNameModel(BaseModel):\n    \"\"\"Class representing the name of an import.\"\"\"\n\n    name: str\n    as_name: str | None = None\n    local_block_id: str | None = None\n\n    @classmethod\n    def _build_from_metadata(cls, metadata: dict[str, str]) -> \"ImportNameModel\":\n        \"\"\"\n        Builds an ImportNameModel from a metadata dictionary.\n\n        Args:\n            metadata (dict[str, str]): A dictionary containing metadata for an import name.\n\n        Returns:\n            ImportNameModel: An instance of ImportNameModel.\n        \"\"\"\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            name: str | None = metadata.get(\"name\")\n            if not name:\n                raise ValueError(\"Import name must be a string.\")\n\n            return cls(\n                name=name,\n                as_name=metadata.get(\"as_name\"),\n                local_block_id=metadata.get(\"local_block_id\"),\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ImportModel(BaseModel):\n    \"\"\"Class representing an import statement.\"\"\"\n\n    import_names: list[ImportNameModel]\n    imported_from: str | None = None\n    import_module_type: ImportModuleType = ImportModuleType.STANDARD_LIBRARY\n    local_module_id: str | None = None\n\n    def convert_import_to_metadata(self) -> str:\n        \"\"\"Converts the import to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(\n        cls, metadata: dict[str, str | list[dict[str, str]]]\n    ) -> \"ImportModel\":\n        \"\"\"\n        Builds an ImportModel from a metadata dictionary.\n\n        Args:\n            metadata (dict): A dictionary containing metadata for an import statement.\n\n        Returns:\n            ImportModel: An instance of ImportModel.\n        \"\"\"\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            import_names_data = metadata.get(\"import_names\", [])\n            if not isinstance(import_names_data, list):\n                raise ValueError(\"import_names must be a list.\")\n\n            import_names = [\n                ImportNameModel._build_from_metadata(name) for name in import_names_data\n            ]\n\n            import_from = metadata.get(\"imported_from\")\n\n            if not isinstance(import_from, str):\n                raise ValueError(\"imported_from must be a string.\")\n\n            if import_from == \"\":\n                import_from = None\n\n            import_module_type_raw = metadata.get(\"import_module_type\")\n            if not isinstance(import_module_type_raw, str):\n                raise ValueError(\"import_module_type must be a string.\")\n\n            try:\n                import_module_type = ImportModuleType(metadata[\"import_module_type\"])\n            except ValueError:\n                raise ValueError(\"Invalid import module type.\")\n\n            local_module_id = metadata.get(\"local_module_id\")\n            if not isinstance(local_module_id, str):\n                raise ValueError(\"local_module_id must be a string.\")\n\n            if not local_module_id:\n                raise ValueError(\"local_module_id cannot be empty.\")\n\n            return cls(\n                import_names=import_names,\n                imported_from=import_from,\n                import_module_type=import_module_type,\n                local_module_id=local_module_id,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass DependencyModel(BaseModel):\n    \"\"\"Class representing a module dependency.\"\"\"\n\n    code_block_id: str\n\n    def convert_dependency_to_metadata(self) -> str:\n        \"\"\"Converts the dependency to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(cls, metadata: dict[str, str]) -> \"DependencyModel\":\n        \"\"\"Builds a DependencyModel from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            return cls(\n                code_block_id=metadata[\"code_block_id\"],\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass CommentModel(BaseModel):\n    \"\"\"Class representing a comment.\"\"\"\n\n    content: str\n    comment_types: list[CommentType]\n\n    def convert_comment_to_metadata(self) -> str:\n        \"\"\"Converts the comment to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(\n        cls, metadata: dict[str, str | list[str]]\n    ) -> \"CommentModel\":\n        \"\"\"Builds a CommentModel from a metadata dictionary.\"\"\"\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            content = metadata.get(\"content\", \"\")\n            if not isinstance(content, str):\n                raise ValueError(\"Content must be a string.\")\n\n            comment_types_raw = metadata.get(\"comment_types\", [])\n            if not isinstance(comment_types_raw, list):\n                raise ValueError(\"Comment types must be a list.\")\n\n            comment_types: list[CommentType] = []\n            for comment_type_str in comment_types_raw:\n                try:\n                    comment_type = CommentType(comment_type_str)\n                    comment_types.append(comment_type)\n                except ValueError:\n                    raise ValueError(f\"Invalid comment type: {comment_type_str}\")\n\n            return cls(content=content, comment_types=comment_types)\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise\n\n\nclass DecoratorModel(BaseModel):\n    \"\"\"Class representing a decorator.\"\"\"\n\n    content: str\n    decorator_name: str\n    decorator_args: list[str] | None = None\n\n    def convert_decorator_to_metadata(self) -> str:\n        \"\"\"Converts the decorator to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(\n        cls, metadata: dict[str, str | list[str] | None]\n    ) -> \"DecoratorModel\":\n        \"\"\"Builds a DecoratorModel from a metadata dictionary.\"\"\"\n        try:\n            # Ensure the metadata is a dictionary\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            content = metadata.get(\"content\", \"\")\n            decorator_name = metadata.get(\"decorator_name\", \"\")\n\n            if not isinstance(decorator_name, str) and not isinstance(content, str):\n                raise ValueError(\"Decorator name and content must be strings.\")\n\n            # Handle decorator_args, ensuring it's a list[str] or None\n            decorator_args_raw = metadata.get(\"decorator_args\")\n            decorator_args = None  # Default to None\n            if isinstance(decorator_args_raw, list):\n                # If it's a list, ensure all elements are strings\n                if all(isinstance(arg, str) for arg in decorator_args_raw):\n                    decorator_args = decorator_args_raw\n                else:\n                    raise ValueError(\"All decorator arguments must be strings.\")\n            elif isinstance(decorator_args_raw, str):\n                # If it's a string, wrap it in a list\n                decorator_args = [decorator_args_raw]\n            elif decorator_args_raw is not None:\n                # If it's not a list, string, or None, it's an invalid type\n                raise ValueError(\n                    \"Decorator arguments must be a string, a list of strings, or None.\"\n                )\n\n            return cls(content=content, decorator_name=decorator_name, decorator_args=decorator_args)  # type: ignore # FIXME: fix type hinting error\n        except ValueError as ve:\n            print(f\"Error building from metadata: {ve}\")\n            raise\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n            raise\n\n\nclass ClassKeywordModel(BaseModel):\n    \"\"\"Class representing a class keyword.\"\"\"\n\n    content: str\n    keyword_name: str\n    args: str | None = None\n\n    def convert_class_keyword_to_metadata(self) -> str:\n        \"\"\"Converts the class keyword to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(cls, metadata: dict[str, str]) -> \"ClassKeywordModel\":\n        \"\"\"Builds a ClassKeywordModel from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            return cls(\n                content=metadata[\"content\"],\n                keyword_name=metadata[\"keyword_name\"],\n                args=metadata[\"args\"] if \"args\" in metadata else None,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ParameterModel(BaseModel):\n    \"\"\"Class representing a function parameter.\"\"\"\n\n    content: str\n\n\nclass ParameterListModel(BaseModel):\n    \"\"\"Class representing a list of parameters.\"\"\"\n\n    params: list[ParameterModel] | None = None\n    star_arg: ParameterModel | None = None\n    kwonly_params: list[ParameterModel] | None = None\n    star_kwarg: ParameterModel | None = None\n    posonly_params: list[ParameterModel] | None = None\n\n    def convert_parameters_to_metadata(self) -> str:\n        \"\"\"Converts the parameter list to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    @classmethod\n    def _build_from_metadata(cls, metadata: dict[str, str]) -> \"ParameterListModel\":\n        \"\"\"Builds a ParameterListModel from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            params: list[ParameterModel] | None = (\n                [ParameterModel(content=param) for param in metadata.get(\"params\", [])]\n                if \"params\" in metadata and isinstance(metadata[\"params\"], list)\n                else None\n            )\n            star_arg: ParameterModel | None = (\n                ParameterModel(content=metadata[\"star_arg\"])\n                if \"star_arg\" in metadata and isinstance(metadata[\"star_arg\"], str)\n                else None\n            )\n            kwonly_params: list[ParameterModel] | None = (\n                [\n                    ParameterModel(content=param)\n                    for param in metadata.get(\"kwonly_params\", [])\n                ]\n                if \"kwonly_params\" in metadata\n                and isinstance(metadata[\"kwonly_params\"], list)\n                else None\n            )\n            star_kwarg: ParameterModel | None = (\n                ParameterModel(content=metadata[\"star_kwarg\"])\n                if \"star_kwarg\" in metadata and isinstance(metadata[\"star_kwarg\"], str)\n                else None\n            )\n            posonly_params: list[ParameterModel] | None = (\n                [\n                    ParameterModel(content=param)\n                    for param in metadata.get(\"posonly_params\", [])\n                ]\n                if \"posonly_params\" in metadata\n                and isinstance(metadata[\"posonly_params\"], list)\n                else None\n            )\n\n            return cls(\n                params=params,\n                star_arg=star_arg,\n                kwonly_params=kwonly_params,\n                star_kwarg=star_kwarg,\n                posonly_params=posonly_params,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass BaseCodeBlockModel(BaseModel):\n    \"\"\"Attributes common to all code block models.\"\"\"\n\n    id: str\n    file_path: str = Field(min_length=1)\n    parent_id: str | None = None\n    block_type: BlockType\n    start_line_num: int\n    end_line_num: int\n    code_content: str = \"\"\n    important_comments: list[CommentModel] | None = None\n    dependencies: list[ImportModel | DependencyModel] | None = None\n    summary: str | None = None\n    children_ids: list[str] | None = []\n\n    @field_validator(\"parent_id\")\n    def check_parent_id(cls, v, values) -> str | None:\n        \"\"\"Validates that parent_id is a non-empty string unless block_type is MODULE.\"\"\"\n        block_type = (\n            values.get(\"block_type\")\n            if isinstance(values, dict)\n            else values.data.get(\"block_type\")\n        )\n\n        if block_type and block_type != BlockType.MODULE:\n            if v is None or len(v) < 1:\n                raise ValueError(\n                    \"parent_id must be a non-empty string unless block_type is MODULE\"\n                )\n        return v\n\n    def _convert_parent_id_to_metadata(self) -> str:\n        \"\"\"Converts the parent_id to a metadata string.\"\"\"\n        return f\"{self.parent_id}\" if self.parent_id else \"\"\n\n    def _convert_block_type_to_metadata(self) -> str:\n        \"\"\"Converts the block_type to a metadata string.\"\"\"\n        return f\"{self.block_type.name}\"\n\n    def _convert_important_comments_to_metadata(self) -> str:\n        \"\"\"Converts the important comments to a metadata string.\"\"\"\n\n        important_comments: str = (\n            self.model_dump_json() if self.important_comments else \"\"\n        )\n\n        return f\"{important_comments}\"\n\n    def _convert_dependencies_to_metadata(self) -> str:\n        \"\"\"Converts the dependencies to a metadata string.\"\"\"\n\n        dependencies_str: str = \"\"\n\n        if self.dependencies:\n            for dependency in self.dependencies:\n                if isinstance(dependency, ImportModel):\n                    dependencies_str += f\"{dependency.convert_import_to_metadata()}\\n\"\n                elif isinstance(dependency, DependencyModel):\n                    dependencies_str += (\n                        f\"{dependency.convert_dependency_to_metadata()}\\n\"\n                    )\n\n        return dependencies_str\n\n    def _convert_summary_to_metadata(self) -> str:\n        \"\"\"Converts the summary to a metadata string.\"\"\"\n        return f\"{self.summary}\" if self.summary else \"\"\n\n    def _convert_children_to_metadata(self) -> str:\n        \"\"\"Converts the children to a metadata string.\"\"\"\n\n        return str(self.children_ids) if self.children_ids else \"\"\n\n    def _convert_base_attributes_to_metadata_dict(self) -> dict[str, str | int]:\n        \"\"\"Converts the base attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"id\": self.id,\n            \"file_path\": self.file_path,\n            \"parent_id\": self._convert_parent_id_to_metadata(),\n            \"block_type\": self._convert_block_type_to_metadata(),\n            \"start_line_num\": self.start_line_num,\n            \"end_line_num\": self.end_line_num,\n            \"code_content\": self.code_content,\n            \"important_comments\": self._convert_important_comments_to_metadata(),\n            \"dependencies\": self._convert_dependencies_to_metadata(),\n            \"summary\": self._convert_summary_to_metadata(),\n            \"children\": self._convert_children_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_metadata(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"BaseCodeBlockModel\":\n        \"\"\"Builds a BaseCodeBlockModel from a metadata dictionary.\"\"\"\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            id = metadata.get(\"id\")\n            if not isinstance(id, str):\n                raise ValueError(\"ID must be a string.\")\n\n            file_path = metadata.get(\"file_path\")\n            if not isinstance(file_path, str):\n                raise ValueError(\"File path must be a string.\")\n\n            block_type = metadata.get(\"block_type\")\n            if (\n                not isinstance(block_type, str)\n                or block_type not in BlockType._member_names_\n            ):\n                raise ValueError(\"Invalid block type.\")\n\n            start_line_num = metadata.get(\"start_line_num\")\n            if not isinstance(start_line_num, int):\n                raise ValueError(\"Start line number must be an integer.\")\n\n            end_line_num = metadata.get(\"end_line_num\")\n            if not isinstance(end_line_num, int):\n                raise ValueError(\"End line number must be an integer.\")\n\n            parent_id = metadata.get(\"parent_id\")\n            if not isinstance(parent_id, str):\n                raise ValueError(\"Parent ID must be a string.\")\n\n            code_content = metadata.get(\"code_content\", \"\")\n            if not isinstance(code_content, str):\n                raise ValueError(\"Code content must be a string.\")\n\n            summary = metadata.get(\"summary\")\n            if not isinstance(summary, str):\n                raise ValueError(\"Summary must be a string.\")\n\n            children_ids = metadata.get(\"children_ids\", [])\n            if not isinstance(children_ids, list) or not all(\n                isinstance(child_id, str) for child_id in children_ids\n            ):\n                raise ValueError(\"Children IDs must be a list of strings.\")\n\n            important_comments_data = metadata.get(\"important_comments\", [])\n            if not isinstance(important_comments_data, list) or all(\n                isinstance(comment, dict) for comment in important_comments_data\n            ):\n                raise ValueError(\"Important comments must be a list.\")\n\n            important_comments: list[CommentModel] = []\n            for comment_data in important_comments_data:\n                if not isinstance(comment_data, dict):\n                    raise ValueError(\"Each important comment must be a dictionary.\")\n                comment: CommentModel = CommentModel._build_from_metadata(comment_data)\n                important_comments.append(comment)\n\n            dependencies: list[ImportModel | DependencyModel] = []\n            dependencies_data = metadata.get(\"dependencies\", [])\n            if isinstance(dependencies_data, list):\n                for dependency_data in dependencies_data:\n                    if not isinstance(dependency_data, dict):\n                        raise ValueError(\"Each dependency must be a dictionary.\")\n                    dependency = None\n                    if \"import_names\" in dependency_data:\n                        dependency = ImportModel._build_from_metadata(dependency_data)\n                    elif \"code_block_id\" in dependency_data:\n                        dependency = DependencyModel._build_from_metadata(\n                            dependency_data\n                        )\n                    if not dependency:\n                        raise ValueError(\"Invalid dependency.\")\n                    dependencies.append(dependency)\n            else:\n                raise ValueError(\"Dependencies must be a list.\")\n\n            return cls(\n                id=id,\n                file_path=file_path,\n                parent_id=parent_id,\n                block_type=BlockType[block_type],\n                start_line_num=start_line_num,\n                end_line_num=end_line_num,\n                code_content=code_content,\n                important_comments=important_comments,\n                dependencies=dependencies,\n                summary=summary if summary else None,\n                children_ids=children_ids,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ModuleSpecificAttributes(BaseModel):\n    \"\"\"Module specific attributes.\"\"\"\n\n    docstring: str | None = None\n    header: list[str] | None = None\n    footer: list[str] | None = None\n    imports: list[ImportModel] | None = None\n\n    def _convert_docstring_to_metadata(self) -> str:\n        \"\"\"Converts the docstring to a metadata string.\"\"\"\n        return f\"{self.docstring}\"\n\n    def _convert_header_to_metadata(self) -> str:\n        \"\"\"Converts the header and footer to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    def _convert_footer_to_metadata(self) -> str:\n        \"\"\"Converts the header and footer to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n    def _convert_imports_to_metadata(self) -> str:\n        \"\"\"Converts the imports to a metadata string.\"\"\"\n        imports_str: str = self.model_dump_json() if self.imports else \"\"\n        return f\"{imports_str}\"\n\n    def _convert_module_attributes_to_metadata_dict(self) -> dict[str, str | int]:\n        \"\"\"Converts the module attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"docstring\": self._convert_docstring_to_metadata(),\n            \"header\": self._convert_header_to_metadata(),\n            \"footer\": self._convert_footer_to_metadata(),\n            \"imports\": self._convert_imports_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"ModuleSpecificAttributes\":\n        \"\"\"Builds a ModuleSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            docstring = metadata.get(\"docstring\")\n            if not isinstance(docstring, str):\n                raise ValueError(\"Docstring must be a string.\")\n\n            header = metadata.get(\"header\")\n            if not isinstance(header, list):\n                raise ValueError(\"Header must be a list.\")\n\n            footer = metadata.get(\"footer\")\n            if not isinstance(footer, list):\n                raise ValueError(\"Footer must be a list.\")\n\n            imports_data = metadata.get(\"imports\")\n            if not isinstance(imports_data, list):\n                raise ValueError(\"Imports must be a list.\")\n\n            imports = []\n            for import_data in imports_data:\n                if not isinstance(import_data, dict):\n                    raise ValueError(\"Each import must be a dictionary.\")\n                import_model = ImportModel._build_from_metadata(import_data)\n                imports.append(import_model)\n\n            return cls(\n                docstring=docstring,\n                header=header,\n                footer=footer,\n                imports=imports,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ModuleModel(BaseCodeBlockModel, ModuleSpecificAttributes):\n    \"\"\"\n    Model for a module.\n\n    Attributes:\n        - id (str): The unique identifier for the module.\n        - file_path (str): The path to the Python file that the module represents.\n        - parent_id (str | None): The identifier of the parent (usually a directory).\n        - block_type (BlockType): The type of code block that the module represents.\n        - start_line_num (int): The line number of the first line of the module.\n        - end_line_num (int): The line number of the last line of the module.\n        - code_content (str): The string content of the module.\n        - important_comments (list[CommentModel] | None): A list of important comments in the module.\n        - dependencies (list[ImportModel | DependencyModel] | None): A list of dependencies for the module.\n        - summary (str | None): A summary of the module.\n        - children_ids (list[str] | None): A list of the identifiers of the children of the module.\n        - docstring (str | None): The docstring of the module.\n        - header (list[str] | None): The header of the module.\n        - footer (list[str] | None): The footer of the module.\n        - imports (list[ImportModel] | None): A list of import statements in the module.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the module model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata_dict: dict[str, str | int | list[str]]) -> ModuleModel`\n            - Builds a ModuleModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the module model to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata_dict(),\n            **self._convert_module_attributes_to_metadata_dict(),\n        }\n\n    @classmethod\n    def build_from_metadata(\n        cls, metadata_dict: dict[str, str | int | list[str]]\n    ) -> \"ModuleModel\":\n        \"\"\"\n        Builds a ModuleModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a module.\n\n        Returns:\n            ModuleModel: An instance of ModuleModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n        try:\n            if not isinstance(metadata_dict, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            module_specific_attributes: ModuleSpecificAttributes = (\n                ModuleSpecificAttributes._build_from_meta(metadata_dict)\n            )\n            base_code_block_model: BaseCodeBlockModel = (\n                BaseCodeBlockModel._build_from_metadata(metadata_dict)\n            )\n\n            return cls(\n                **module_specific_attributes.model_dump(),\n                **base_code_block_model.model_dump(),\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ClassSpecificAttributes(BaseModel):\n    \"\"\"Class specific attributes.\"\"\"\n\n    class_name: str = Field(min_length=1)\n    decorators: list[DecoratorModel] | None = None\n    bases: list[str] | None = None\n    docstring: str | None = None\n    keywords: list[ClassKeywordModel] | None = None\n    # attributes: list[dict] | None = None\n\n    def _convert_decorators_to_metadata(self) -> str:\n        \"\"\"Converts the decorators to a metadata string.\"\"\"\n        decorators_str: str = self.model_dump_json() if self.decorators else \"\"\n        return f\"{decorators_str}\"\n\n    def _convert_bases_to_metadata(self) -> str:\n        \"\"\"Converts the bases to a metadata string.\"\"\"\n        return self.model_dump_json() if self.bases else \"\"\n\n    def _convert_docstring_to_metadata(self) -> str:\n        \"\"\"Converts the docstring to a metadata string.\"\"\"\n        return f\"{self.docstring}\" if self.docstring else \"\"\n\n    def _convert_keywords_to_metadata(self) -> str:\n        \"\"\"Converts the keywords to a metadata string.\"\"\"\n        keywords_str: str = self.model_dump_json() if self.keywords else \"\"\n        return f\"{keywords_str}\"\n\n    def _convert_class_attributes_to_metadata_dict(self) -> dict[str, str | int]:\n        \"\"\"Converts the class attributes to a metadata dictionary.\"\"\"\n\n        return {\n            \"class_name\": self.class_name,\n            \"decorators\": self._convert_decorators_to_metadata(),\n            \"bases\": self._convert_bases_to_metadata(),\n            \"docstring\": self._convert_docstring_to_metadata(),\n            \"keywords\": self._convert_keywords_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"ClassSpecificAttributes\":\n        \"\"\"Builds a ClassSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            class_name = metadata.get(\"class_name\")\n            if not isinstance(class_name, str):\n                raise ValueError(\"Class name must be a string.\")\n\n            decorators_data = metadata.get(\"decorators\", [])\n            if not isinstance(decorators_data, list):\n                raise ValueError(\"Decorators must be a list.\")\n\n            decorators: list[DecoratorModel] = []\n            for decorator_data in decorators_data:\n                if not isinstance(decorator_data, dict):\n                    raise ValueError(\"Each decorator must be a dictionary.\")\n                decorator: DecoratorModel = DecoratorModel._build_from_metadata(\n                    decorator_data\n                )\n                decorators.append(decorator)\n\n            bases = metadata.get(\"bases\", [])\n            if not isinstance(bases, list) or all(\n                isinstance(base, str) for base in bases\n            ):\n                raise ValueError(\"Bases must be a list.\")\n\n            docstring = metadata.get(\"docstring\")\n            if not isinstance(docstring, str):\n                raise ValueError(\"Docstring must be a string.\")\n\n            keywords_data = metadata.get(\"keywords\", [])\n            if not isinstance(keywords_data, list) or all(\n                isinstance(keyword, dict) for keyword in keywords_data\n            ):\n                raise ValueError(\"Keywords must be a list.\")\n\n            keywords: list[ClassKeywordModel] = []\n            for keyword_data in keywords_data:\n                if not isinstance(keyword_data, dict):\n                    raise ValueError(\"Each keyword must be a dictionary.\")\n                keyword: ClassKeywordModel = ClassKeywordModel._build_from_metadata(\n                    keyword_data\n                )\n                keywords.append(keyword)\n\n            return cls(\n                class_name=class_name,\n                decorators=decorators,\n                bases=bases,\n                docstring=docstring,\n                keywords=keywords,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass ClassModel(BaseCodeBlockModel, ClassSpecificAttributes):\n    \"\"\"\n    Model for a class.\n\n    Attributes:\n        - id (str): The unique identifier for the class.\n        - file_path (str): The path to the Python file that the class represents.\n        - parent_id (str | None): The identifier of the parent (usually a module).\n        - block_type (BlockType): The type of code block that the class represents.\n        - start_line_num (int): The line number of the first line of the class.\n        - end_line_num (int): The line number of the last line of the class.\n        - code_content (str): The string content of the class.\n        - important_comments (list[CommentModel] | None): A list of important comments in the class.\n        - dependencies (list[ImportModel | DependencyModel] | None): A list of dependencies for the class.\n        - summary (str | None): A summary of the class.\n        - children_ids (list[str] | None): A list of the identifiers of the children of the class.\n        - class_name (str): The name of the class.\n        - decorators (list[DecoratorModel] | None): A list of decorators for the class.\n        - bases (list[str] | None): A list of base classes for the class.\n        - docstring (str | None): The docstring of the class.\n        - keywords (list[ClassKeywordModel] | None): A list of keywords for the class.\n\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the class model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata_dict: dict[str, str | int | list[str]]) -> ClassModel`\n            - Builds a ClassModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the class model to a metadata dictionary for ChromaDB.\"\"\"\n        return {\n            **self._convert_base_attributes_to_metadata_dict(),\n            **self._convert_class_attributes_to_metadata_dict(),\n        }\n\n    @classmethod\n    def build_from_metadata(\n        cls, metadata_dict: dict[str, str | int | list[str]]\n    ) -> \"ClassModel\":\n        \"\"\"\n        Builds a ClassModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a class.\n\n        Returns:\n            ClassModel: An instance of ClassModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n        try:\n            if not isinstance(metadata_dict, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            class_specific_attributes: ClassSpecificAttributes = (\n                ClassSpecificAttributes._build_from_meta(metadata_dict)\n            )\n            base_code_block_model: BaseCodeBlockModel = (\n                BaseCodeBlockModel._build_from_metadata(metadata_dict)\n            )\n\n            return cls(\n                **class_specific_attributes.model_dump(),\n                **base_code_block_model.model_dump(),\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass FunctionSpecificAttributes(BaseModel):\n    \"\"\"Function specific attributes.\"\"\"\n\n    function_name: str = Field(min_length=1)\n    docstring: str | None = None\n    decorators: list[DecoratorModel] | None = None\n    parameters: ParameterListModel | None = None\n    returns: str | None = None\n    is_method: bool = False\n    is_async: bool = False\n\n    def _convert_docstring_to_metadata(self) -> str:\n        \"\"\"Converts the docstring to a metadata string.\"\"\"\n        return f\"{self.docstring}\" if self.docstring else \"\"\n\n    def _convert_decorators_to_metadata(self) -> str:\n        \"\"\"Converts the decorators to a metadata string.\"\"\"\n        decorators_str: str = self.model_dump_json() if self.decorators else \"\"\n        return f\"{decorators_str}\"\n\n    def _convert_parameters_to_metadata(self) -> str:\n        \"\"\"Converts the parameters to a metadata string.\"\"\"\n        return (\n            self.parameters.convert_parameters_to_metadata() if self.parameters else \"\"\n        )\n\n    def _convert_returns_to_metadata(self) -> str:\n        \"\"\"Converts the returns to a metadata string.\"\"\"\n        return f\"{self.returns}\" if self.returns else \"\"\n\n    def _convert_function_attributes_to_metadata_dict(self) -> dict[str, str | bool]:\n        \"\"\"Converts the function attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"function_name\": self.function_name,\n            \"docstring\": self._convert_docstring_to_metadata(),\n            \"decorators\": self._convert_decorators_to_metadata(),\n            \"parameters\": self._convert_parameters_to_metadata(),\n            \"returns\": self._convert_returns_to_metadata(),\n            \"is_method\": self.is_method,\n            \"is_async\": self.is_async,\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | bool]\n    ) -> \"FunctionSpecificAttributes\":\n        \"\"\"Builds a FunctionSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            function_name = metadata.get(\"function_name\")\n            if not isinstance(function_name, str):\n                raise ValueError(\"Function name must be a string.\")\n\n            docstring = metadata.get(\"docstring\")\n            if not isinstance(docstring, str):\n                raise ValueError(\"Docstring must be a string.\")\n\n            decorators_data = metadata.get(\"decorators\", [])\n            if not isinstance(decorators_data, list):\n                raise ValueError(\"Decorators must be a list.\")\n\n            decorators: list[DecoratorModel] = []\n            for decorator_data in decorators_data:\n                if not isinstance(decorator_data, dict):\n                    raise ValueError(\"Each decorator must be a dictionary.\")\n                decorator: DecoratorModel = DecoratorModel._build_from_metadata(\n                    decorator_data\n                )\n                decorators.append(decorator)\n\n            parameters_data = metadata.get(\"parameters\")\n            if not isinstance(parameters_data, dict):\n                raise ValueError(\"Parameters must be a dictionary.\")\n\n            parameters: ParameterListModel = ParameterListModel._build_from_metadata(\n                parameters_data\n            )\n\n            returns = metadata.get(\"returns\")\n            if not isinstance(returns, str):\n                raise ValueError(\"Returns must be a string.\")\n\n            is_method = metadata.get(\"is_method\")\n            if not isinstance(is_method, bool):\n                raise ValueError(\"is_method must be a boolean.\")\n\n            is_async = metadata.get(\"is_async\")\n            if not isinstance(is_async, bool):\n                raise ValueError(\"is_async must be a boolean.\")\n\n            return cls(\n                function_name=function_name,\n                docstring=docstring,\n                decorators=decorators,\n                parameters=parameters,\n                returns=returns,\n                is_method=is_method,\n                is_async=is_async,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass FunctionModel(BaseCodeBlockModel, FunctionSpecificAttributes):\n    \"\"\"\n    A model for a function.\n\n    Attributes:\n        - id (str): The unique identifier for the function.\n        - file_path (str): The path to the Python file that the function represents.\n        - parent_id (str | None): The identifier of the parent (usually a module or class).\n        - block_type (BlockType): The type of code block that the function represents.\n        - start_line_num (int): The line number of the first line of the function.\n        - end_line_num (int): The line number of the last line of the function.\n        - code_content (str): The string content of the function.\n        - important_comments (list[CommentModel] | None): A list of important comments in the function.\n        - dependencies (list[ImportModel | DependencyModel] | None): A list of dependencies for the function.\n        - summary (str | None): A summary of the function.\n        - children_ids (list[str] | None): A list of the identifiers of the children of the function.\n        - function_name (str): The name of the function.\n        - docstring (str | None): The docstring of the function.\n        - decorators (list[DecoratorModel] | None): A list of decorators for the function.\n        - parameters (ParameterListModel | None): A model representing the function's parameters.\n        - returns (str | None): A string representing the function's return annotation.\n        - is_method (bool): True if the function is a method, False otherwise.\n        - is_async (bool): True if the function is asynchronous, False otherwise.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the function model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata_dict: dict[str, str | int | list[str]]) -> FunctionModel`\n            - Builds a FunctionModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the function model to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata_dict(),\n            **self._convert_function_attributes_to_metadata_dict(),\n        }\n\n    @classmethod\n    def build_from_metadata(\n        cls, metadata_dict: dict[str, str | int | list[str] | bool]\n    ) -> \"FunctionModel\":\n        \"\"\"\n        Builds a FunctionModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a function.\n\n        Returns:\n            FunctionModel: An instance of FunctionModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n        try:\n            if not isinstance(metadata_dict, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            function_specific_attributes: FunctionSpecificAttributes = (\n                FunctionSpecificAttributes._build_from_meta(metadata_dict)  # type: ignore # FIXME: fix type hinting error\n            )  # type: ignore # FIXME: fix type hinting error\n            base_code_block_model: BaseCodeBlockModel = (\n                BaseCodeBlockModel._build_from_metadata(metadata_dict)\n            )\n\n            return cls(\n                **function_specific_attributes.model_dump(),\n                **base_code_block_model.model_dump(),\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass StandaloneCodeBlockSpecificAttributes(BaseModel):\n    \"\"\"Standalone code block specific attributes.\"\"\"\n\n    variable_assignments: list[str] | None = None\n\n    def _convert_variable_assignments_to_metadata(self) -> str:\n        \"\"\"Converts the variable assignments to a metadata string.\"\"\"\n        return self.model_dump_json() if self.variable_assignments else \"\"\n\n    def _convert_standalone_block_attributes_to_metadata_dict(\n        self,\n    ) -> dict[str, str | int]:\n        \"\"\"Converts the standalone code block attributes to a metadata dictionary for ChromaDB.\"\"\"\n        return {\n            \"variable_assignments\": self._convert_variable_assignments_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"StandaloneCodeBlockSpecificAttributes\":\n        \"\"\"Builds a StandaloneCodeBlockSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            variable_assignments_data = metadata.get(\"variable_assignments\", [])\n            if not isinstance(variable_assignments_data, list):\n                raise ValueError(\"Variable assignments must be a list.\")\n\n            variable_assignments: list[str] = []\n            for variable_assignment_data in variable_assignments_data:\n                if not isinstance(variable_assignment_data, str):\n                    raise ValueError(\"Each variable assignment must be a string.\")\n                variable_assignments.append(variable_assignment_data)\n\n            return cls(\n                variable_assignments=variable_assignments,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass StandaloneCodeBlockModel(\n    BaseCodeBlockModel, StandaloneCodeBlockSpecificAttributes\n):\n    \"\"\"\n    Model for a standalone code block.\n\n    Attributes:\n        - id (str): The unique identifier for the standalone code block.\n        - file_path (str): The path to the Python file that the standalone code block represents.\n        - parent_id (str | None): The identifier of the parent (usually a module or class).\n        - block_type (BlockType): The type of code block that the standalone code block represents.\n        - start_line_num (int): The line number of the first line of the standalone code block.\n        - end_line_num (int): The line number of the last line of the standalone code block.\n        - code_content (str): The string content of the standalone code block.\n        - important_comments (list[CommentModel] | None): A list of important comments in the standalone code block.\n        - dependencies (list[ImportModel | DependencyModel] | None): A list of dependencies for the standalone code block.\n        - summary (str | None): A summary of the standalone code block.\n        - children_ids (list[str] | None): A list of the identifiers of the children of the standalone code block.\n        - variable_assignments (list[str] | None): A list of variable assignments in the standalone code block.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the standalone code block model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata_dict: dict[str, str | int | list[str]]) -> StandaloneCodeBlockModel`\n            - Builds a StandaloneCodeBlockModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the standalone code block model to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata_dict(),\n            **self._convert_standalone_block_attributes_to_metadata_dict(),\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"StandaloneCodeBlockModel\":\n        \"\"\"\n        Builds a StandaloneCodeBlockModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a standalone code block.\n\n        Returns:\n            - StandaloneCodeBlockModel: An instance of StandaloneCodeBlockModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            standalone_code_block_specific_attributes: (\n                StandaloneCodeBlockSpecificAttributes\n            ) = StandaloneCodeBlockSpecificAttributes._build_from_meta(metadata)\n            base_code_block_model: BaseCodeBlockModel = (\n                BaseCodeBlockModel._build_from_metadata(metadata)\n            )\n\n            return cls(\n                **standalone_code_block_specific_attributes.model_dump(),\n                **base_code_block_model.model_dump(),\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n\n\nclass DirectoryModel(BaseModel):\n    \"\"\"\n    Model for a directory.\n\n    Attributes:\n        - id (str): The unique identifier for the directory.\n        - block_type (BlockType): The type of code block that the directory represents.\n        - directory_name (str): The name of the directory.\n        - sub_directories_ids (list[str]): A list of the identifiers of the sub-directories of the directory.\n        - children_ids (list[str]): A list of the identifiers of the children of the directory.\n        - parent_id (str | None): The identifier of the parent (usually a directory).\n        - summary (str | None): A summary of the directory.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`:\n            Converts the directory model to a metadata dictionary for ChromaDB.\n    \"\"\"\n\n    id: str\n    block_type: BlockType = BlockType.DIRECTORY\n    directory_name: str\n    sub_directories_ids: list[str]\n    children_ids: list[str]\n    parent_id: str | None\n    summary: str | None = None\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the directory model to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"directory_name\": self.directory_name,\n            \"sub_directories\": (\n                str(self.sub_directories_ids) if self.sub_directories_ids else \"\"\n            ),\n            \"children_ids\": self.model_dump_json() if self.children_ids else \"\",\n            \"parent_id\": self.parent_id if self.parent_id else \"\",\n            \"summary\": self.summary if self.summary else \"\",\n        }\n\n    @classmethod\n    def build_from_metadata(\n        cls, metadata_dict: dict[str, str | list[str]]\n    ) -> \"DirectoryModel\":\n        \"\"\"\n        Builds a DirectoryModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a directory.\n\n        Returns:\n            - DirectoryModel: An instance of DirectoryModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n\n        try:\n            if not isinstance(metadata_dict, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            id = metadata_dict.get(\"id\")\n            if not isinstance(id, str):\n                raise ValueError(\"ID must be a string.\")\n\n            directory_name = metadata_dict.get(\"directory_name\")\n            if not isinstance(directory_name, str):\n                raise ValueError(\"Directory name must be a string.\")\n\n            sub_directories_ids = metadata_dict.get(\"sub_directories\")\n            if not isinstance(sub_directories_ids, list) or not all(\n                isinstance(sub_directory_id, str)\n                for sub_directory_id in sub_directories_ids\n            ):\n                raise ValueError(\"Sub-directories must be a list of strings.\")\n\n            children_ids = metadata_dict.get(\"children_ids\")\n            if not isinstance(children_ids, list) or not all(\n                isinstance(child_id, str) for child_id in children_ids\n            ):\n                raise ValueError(\"Children IDs must be a list of strings.\")\n\n            parent_id = metadata_dict.get(\"parent_id\")\n            if not isinstance(parent_id, str):\n                raise ValueError(\"Parent ID must be a string.\")\n\n            summary = metadata_dict.get(\"summary\")\n            if not isinstance(summary, str):\n                raise ValueError(\"Summary must be a string.\")\n\n            return cls(\n                id=id,\n                directory_name=directory_name,\n                sub_directories_ids=sub_directories_ids,\n                children_ids=children_ids,\n                parent_id=parent_id if parent_id else None,\n                summary=summary if summary else None,\n            )\n\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "The provided Python code defines a comprehensive framework for modeling and managing metadata of various code components, such as imports, dependencies, comments, decorators, classes, functions, standalone code blocks, and directories. The primary purpose of this code is to facilitate the conversion of these code components into metadata dictionaries suitable for storage and retrieval in a system like ChromaDB, which is used for vector-based search and retrieval. This is significant for applications requiring detailed code analysis, documentation generation, or integration with systems that need structured code metadata.\n\nKey components of the code include several classes: `ImportNameModel`, `ImportModel`, `DependencyModel`, `CommentModel`, `DecoratorModel`, `ClassKeywordModel`, `ParameterModel`, `ParameterListModel`, `BaseCodeBlockModel`, `ModuleSpecificAttributes`, `ModuleModel`, `ClassSpecificAttributes`, `ClassModel`, `FunctionSpecificAttributes`, `FunctionModel`, `StandaloneCodeBlockSpecificAttributes`, `StandaloneCodeBlockModel`, and `DirectoryModel`. Each class is responsible for representing a specific aspect of code structure and includes methods for converting to and from metadata dictionaries. For instance, `ImportModel` handles import statements, `DependencyModel` represents module dependencies, and `FunctionModel` encapsulates function-specific attributes like parameters and decorators.\n\nThe implementation leverages Pydantic's `BaseModel` for data validation and serialization, ensuring that metadata is accurately represented and validated. The design pattern used is object-oriented, with a focus on encapsulation and modularity, allowing for easy extension and maintenance. The code employs a methodical approach to metadata conversion, with each model class providing methods to convert its attributes to metadata strings or dictionaries, which are then used for storage in ChromaDB. Error handling is robust, with extensive validation checks to ensure the integrity of metadata inputs and outputs.\n\nThe technical stack includes Pydantic for data validation and serialization, which provides a structured way to define and validate data models. Logging is used for error handling and debugging, ensuring that any issues in metadata processing are captured and addressed. The code also imports custom enumerations from `fenec.models.enums`, which likely define specific types used across the models, such as `BlockType`, `ImportModuleType`, and `CommentType`.\n\nIn the context of a larger system, this code provides a structured way to represent and manipulate code metadata, which can be used for code analysis, documentation generation, or integration with other systems that require detailed code metadata. It interacts with other components by converting code structures into metadata that can be stored, searched, and retrieved efficiently. This framework could be part of a larger code analysis tool or integrated into a development environment to provide insights into code structure and dependencies, facilitating tasks such as refactoring, dependency management, and documentation. The modular design supports scalability and adaptability, making it suitable for various applications in software development and maintenance.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-ImportNameModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ImportModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DependencyModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-CommentModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassKeywordModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ParameterModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ParameterListModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ModuleSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-ModuleModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-StandaloneCodeBlockSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-StandaloneCodeBlockModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel"
    ]
}