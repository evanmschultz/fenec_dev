{
    "function_name": "upsert_models",
    "docstring": "Loads or updates the embeddings of the provided models into the collection.\n\nThe Pydantic models are converted to a dictionary with a format that ChromaDB can use, then the ids, documents, and metadatas\nare added to their respective lists. The lists are then either added to or updated in the collection depending on whether or\nnot the code blocks were in the the collection to begin with.\n\nArgs:\n    - models (tuple[ModelType, ...]): The models to load or update into the collection.\n\nExamples:\n    ```Python\n    # Upsert models into the collection\n    models = (model1, model2)\n    collection_manager.upsert_models(models)\n    ```",
    "decorators": null,
    "parameters": null,
    "returns": "None",
    "is_method": true,
    "is_async": false,
    "id": "fenec:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager__*__FUNCTION-upsert_models",
    "file_path": "fenec/databases/chroma/chromadb_collection_manager.py",
    "parent_id": "fenec:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager",
    "block_type": "FUNCTION",
    "start_line_num": 431,
    "end_line_num": 468,
    "code_content": "\ndef upsert_models(self, models: tuple[ModelType, ...]) -> None:\n    \"\"\"\n        Loads or updates the embeddings of the provided models into the collection.\n\n        The Pydantic models are converted to a dictionary with a format that ChromaDB can use, then the ids, documents, and metadatas\n        are added to their respective lists. The lists are then either added to or updated in the collection depending on whether or\n        not the code blocks were in the the collection to begin with.\n\n        Args:\n            - models (tuple[ModelType, ...]): The models to load or update into the collection.\n\n        Examples:\n            ```Python\n            # Upsert models into the collection\n            models = (model1, model2)\n            collection_manager.upsert_models(models)\n            ```\n        \"\"\"\n\n    ids: list[str] = []\n    documents: list[str] = []\n    metadatas: list[Mapping[str, str | int | float | bool]] = []\n\n    for model in models:\n        if model.summary:\n            ids.append(model.id)\n            documents.append(model.summary)\n            metadatas.append(model.convert_to_metadata())\n\n    logging.info(\n        f\"{self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n    )\n    self._upsert_documents(ids=ids, documents=documents, metadatas=metadatas)\n    logging.info(\n        f\"After upsert {self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n    )\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This code defines a method `upsert_models` within a class, designed to efficiently manage the storage and updating of model embeddings in a collection, likely managed by a system such as ChromaDB. The primary purpose of this method is to convert Pydantic models into a dictionary format compatible with ChromaDB, organizing the data into lists of IDs, documents, and metadata. These lists are then used to either add new entries or update existing ones in the collection, depending on whether the models' data already exists in the collection. Key components include the `upsert_models` method, which processes a tuple of models, extracting their IDs, summaries, and metadata through a loop, and the `_upsert_documents` method, which performs the actual insertion or update operation in the collection. The implementation involves iterating over the provided models, checking for the presence of a summary attribute, and appending relevant data to the respective lists. The method utilizes a list of strings for IDs and documents, and a list of mappings for metadata, which can include various data types such as strings, integers, floats, or booleans. The technical stack, while not explicitly detailed in the code snippet, implies the use of Pydantic for model handling, which provides data validation and settings management using Python type annotations, and ChromaDB for data storage and retrieval, which is a vector database optimized for handling embeddings. In the context of a larger system, this method serves as a utility for managing model data within a database, facilitating efficient updates and insertions of model embeddings, and ensuring that the collection remains current with the latest model information. This functionality is crucial in systems where model data is frequently updated or queried, such as in machine learning pipelines or recommendation systems, where maintaining up-to-date embeddings is essential for accurate predictions and recommendations. The method's design supports scalability and robustness, ensuring that the system can handle a large volume of model data efficiently.",
    "children_ids": []
}