{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ClassModelBuilder",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:class_model_builder.py__*__MODULE__*__CLASS-ClassModelBuilder"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.class_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:class_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "DecoratorModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                },
                {
                    "name": "ClassKeywordModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ClassKeywordModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "fenec.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "PositionData",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:processing_context.py__*__MODULE__*__CLASS-PositionData"
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:processing_context.py__*__MODULE"
        }
    ],
    "id": "fenec:python_parser:visitors:node_processing:class_def_functions.py__*__MODULE",
    "file_path": "fenec/python_parser/visitors/node_processing/class_def_functions.py",
    "parent_id": "fenec:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 119,
    "code_content": "from typing import Sequence\n\nimport libcst\n\nfrom fenec.python_parser.model_builders.class_model_builder import ClassModelBuilder\nfrom fenec.models.models import ClassKeywordModel, DecoratorModel\nimport fenec.python_parser.visitors.node_processing.common_functions as common_functions\n\nfrom fenec.utilities.processing_context import PositionData\n\n\ndef process_class_def(\n    node: libcst.ClassDef,\n    position_data: PositionData,\n    builder: ClassModelBuilder,\n) -> None:\n    \"\"\"\n    Processes a libcst.ClassDef node to build a class model.\n\n    Extracts various components of a class definition such as its docstring, code content, base classes, decorators, and keywords,\n    and updates the provided ClassModelBuilder with these details.\n\n    Args:\n        - node (libcst.ClassDef): The class definition node from the CST.\n        - position_data (PositionData): Positional data for the class in the source code.\n        - builder (ClassModelBuilder): The builder used to construct the class model.\n\n    Example:\n        ```Python\n        class_builder = ClassModelBuilder(id=\"class1\", ...)\n        process_class_def(class_node, position_data, class_builder)\n        # Processes the class definition and updates the class builder.\n        ```\n    \"\"\"\n\n    docstring: str | None = node.get_docstring()\n    code_content: str = common_functions.extract_code_content(node)\n    bases: list[str] | None = _extract_bases(node.bases)\n    keywords: list[ClassKeywordModel] | None = _extract_keywords(node.keywords)\n    decorators: list[DecoratorModel] | None = common_functions.extract_decorators(\n        node.decorators\n    )\n\n    (\n        builder.set_docstring(docstring)\n        .set_code_content(code_content)\n        .set_start_line_num(position_data.start)\n        .set_end_line_num(position_data.end)\n    )\n    builder.set_bases(bases).set_decorators(decorators).set_keywords(keywords)\n\n\ndef _extract_bases(bases: Sequence[libcst.Arg]) -> list[str] | None:\n    \"\"\"\n    Extracts the base classes from a sequence of libcst.Arg representing class bases.\n\n    Args:\n        - bases (Sequence[libcst.Arg]): A sequence of libcst.Arg nodes representing class base classes.\n\n    Returns:\n        - list[str] | None: A list of base class names, or None if there are no bases.\n\n    Example:\n        ```Python\n        class_bases = _extract_bases(class_node.bases)\n        # Returns a list of base class names from the class definition.\n        ```\n    \"\"\"\n\n    bases_list: list[str] = []\n    for base in bases:\n        if (\n            isinstance(base, libcst.Arg)\n            and isinstance(base.value, libcst.Name)\n            and base.value.value\n        ):\n            bases_list.append(base.value.value)\n    return bases_list if bases_list else None\n\n\ndef _extract_keywords(\n    keywords: Sequence[libcst.Arg],\n) -> list[ClassKeywordModel] | None:\n    \"\"\"\n    Extracts class keywords (like metaclass) from a sequence of libcst.Arg representing class keywords.\n\n    Args:\n        - keywords (Sequence[libcst.Arg]): A sequence of libcst.Arg nodes representing class keywords.\n\n    Returns:\n        - list[ClassKeywordModel] | None: A list of ClassKeywordModel objects representing each keyword,\n        or None if there are no keywords.\n\n    Example:\n        ```Python\n        class_keywords = _extract_keywords(class_node.keywords)\n        # Returns a list of ClassKeywordModel objects for each keyword in the class definition.\n        ```\n    \"\"\"\n\n    keywords_list: list[ClassKeywordModel] = []\n\n    for keyword in keywords:\n        if keyword.keyword is not None:\n            keyword_name: str = keyword.keyword.value\n            args: str | None = (\n                common_functions.extract_stripped_code_content(keyword.value)\n                if keyword.value\n                else None\n            )\n            content: str = common_functions.extract_stripped_code_content(keyword)\n\n            keyword_model = ClassKeywordModel(\n                content=content, keyword_name=keyword_name, args=args\n            )\n            keywords_list.append(keyword_model)\n\n    return keywords_list if keywords_list else None\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This code is part of a static analysis and code transformation framework, specifically designed to process Python class definitions using the `libcst` library to build detailed class models. Its primary purpose is to extract and organize various components of a class definition, such as docstrings, code content, base classes, decorators, and keywords, and update a `ClassModelBuilder` instance with these details. This functionality is crucial for enabling static analysis, refactoring, and documentation generation tasks within the `fenec` framework, providing a structured representation of class definitions that can be used for further analysis or transformation.\n\nKey components of the code include the `process_class_def` function, which serves as the main method for processing class nodes by orchestrating the extraction and updating process. It interacts with the `ClassModelBuilder` to set attributes like docstrings, code content, base classes, decorators, and keywords. The `_extract_bases` function retrieves base class names from a sequence of `libcst.Arg` nodes, ensuring that only valid base class names are extracted. The `_extract_keywords` function extracts class keywords, such as metaclasses, and constructs `ClassKeywordModel` objects to represent these keywords accurately. Additionally, utility functions from `common_functions` are used to extract specific code elements, such as stripped code content and decorators, ensuring that the extracted data is clean and ready for model building.\n\nThe implementation leverages the `libcst` library for parsing and manipulating Python code as concrete syntax trees, allowing for precise and non-destructive code transformations. The `ClassModelBuilder` employs a fluent interface pattern to streamline the setting of multiple attributes, enhancing the efficiency and readability of the code. The `PositionData` class from `fenec.utilities.processing_context` is used to manage positional information about the class in the source code, aiding in accurate model construction.\n\nThe technical stack includes `libcst` for code parsing, which provides a robust framework for working with Python's syntax trees. Custom models like `ClassKeywordModel` and `DecoratorModel` are used for representing class components, which are part of the `fenec.models` module. Utility functions from `fenec.python_parser.visitors.node_processing.common_functions` are employed for extracting and processing code elements. This stack ensures that the code can handle complex class structures and provide detailed insights into class definitions.\n\nIn the context of the larger `fenec` framework, this code fits into a Python parser module, interacting with other components to provide detailed class models that can be used for further analysis or transformation tasks. It plays a critical role in enabling the framework to perform static analysis, refactoring, and code generation tasks by providing a structured and detailed representation of class definitions. This integration allows for seamless interaction with other modules within the `fenec` system, supporting a wide range of applications from code quality analysis to automated code modifications. By extracting and organizing class components, this code contributes to a comprehensive understanding of the codebase, facilitating tasks such as dependency analysis, code quality checks, and automated refactoring.",
    "children_ids": [
        "fenec:python_parser:visitors:node_processing:class_def_functions.py__*__MODULE__*__FUNCTION-process_class_def",
        "fenec:python_parser:visitors:node_processing:class_def_functions.py__*__MODULE__*__FUNCTION-_extract_bases",
        "fenec:python_parser:visitors:node_processing:class_def_functions.py__*__MODULE__*__FUNCTION-_extract_keywords"
    ]
}