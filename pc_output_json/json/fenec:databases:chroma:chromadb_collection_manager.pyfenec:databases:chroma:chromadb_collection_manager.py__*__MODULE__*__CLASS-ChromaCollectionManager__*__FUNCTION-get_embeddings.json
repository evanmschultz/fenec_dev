{
    "function_name": "get_embeddings",
    "docstring": "Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\nArgs:\n    - ids (list[str]): A list of ids to get from the collection.\n    - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n    - limit (int | None): The maximum number of results to return.\n    - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n        e.g. `{$contains: {\"text\": \"hello\"}}`\n    - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\nReturns:\n    - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n        - ids: list[str]\n        - embeddings: list[Embedding] | None\n        - documents: list[str] | None\n        - uris: chroma_types.URIs | None\n        - data: chroma_types.Loadable | None\n        - metadatas: list[chroma_types.Metadata]]\n\nRaises:\n    - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n    - ValueError: If you provide an id that doesn't exist.\n\nExamples:\n    ```Python\n    import fenec.types.chromadb.types as chroma_types\n\n    # define the ids, filters to use to get embeddings from the collection\n    ids: list[str] = [\"my_id\", \"my_id2\"]\n    where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n    where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n    # define the data to return from the collection\n    include_in_result: chroma_types.Include = [\"metadatas\"]\n\n    # get the embeddings from the collection\n    embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n        ids,\n        where_filter=where_filter,\n        where_document_filter=where_document_filter,\n        include_in_result=include_in_result\n        )\n    ```",
    "decorators": null,
    "parameters": null,
    "returns": " | None",
    "is_method": true,
    "is_async": false,
    "id": "fenec:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager__*__FUNCTION-get_embeddings",
    "file_path": "fenec/databases/chroma/chromadb_collection_manager.py",
    "parent_id": "fenec:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager",
    "block_type": "FUNCTION",
    "start_line_num": 111,
    "end_line_num": 178,
    "code_content": "\ndef get_embeddings(\n    self,\n    ids: list[str] | None,\n    *,\n    where_filter: chroma_types.Where | None = None,\n    limit: int | None = None,\n    where_document_filter: chroma_types.WhereDocument | None = None,\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n) -> chroma_types.GetResult | None:\n    \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import fenec.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n    try:\n        logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n        return self.collection.get(\n            ids,\n            where=where_filter,\n            limit=limit,\n            where_document=where_document_filter,\n            include=include_in_result,\n        )\n    except Exception as exception:\n        raise exception\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "The `get_embeddings` method is a pivotal function within a class designed to efficiently retrieve embeddings and their associated metadata from a data collection, returning the results in a structured format. This method significantly enhances data retrieval efficiency and flexibility by allowing users to specify identifiers and apply optional filtering criteria, making it a versatile tool in data management systems. Key components include the `get_embeddings` method itself, which serves as the primary interface for fetching data; the use of `chroma_types` for type definitions, ensuring type safety and clarity in the data structure; and the integration with a collection object that performs the actual data retrieval. The method's implementation involves invoking the `get` method on a collection object, passing parameters such as `ids`, `where_filter`, `limit`, `where_document_filter`, and `include_in_result` to customize the query. It handles exceptions by re-raising them, ensuring that any issues during data retrieval are propagated for handling elsewhere, thus maintaining robustness.\n\nThe technical stack includes Python's type hinting for parameter and return type specifications, which enhances code readability and maintainability. The code relies on `chroma_types`, a module that provides type definitions like `Where`, `Include`, and `GetResult` to structure the data and filters, ensuring that the data retrieval process is both flexible and precise. This method is likely part of a larger data management or machine learning pipeline, where it interacts with a collection manager to fetch and process embedding data. This data could be used for various tasks such as similarity search, data analysis, or model training, making it a versatile tool in the system.\n\nIn the context of the larger project, this method is integral to systems requiring efficient and flexible data retrieval capabilities. It interfaces with a collection manager, which is responsible for managing and querying large datasets, potentially stored in a database or a distributed storage system. The method's design allows it to be easily integrated into larger systems, supporting tasks that require quick access to embedding data, such as real-time recommendation engines, natural language processing applications, or any system that leverages vector search for enhanced data insights. Its modular design ensures that it can be adapted to various data schemas and retrieval requirements, making it a valuable asset in a scalable data processing architecture.",
    "children_ids": []
}