{
    "class_name": "BaseCodeBlockModel",
    "decorators": null,
    "bases": [
        "BaseModel"
    ],
    "docstring": "Attributes common to all code block models.",
    "keywords": null,
    "id": "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models:models.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 357,
    "end_line_num": 550,
    "code_content": "\n\nclass BaseCodeBlockModel(BaseModel):\n    \"\"\"Attributes common to all code block models.\"\"\"\n\n    id: str\n    file_path: str = Field(min_length=1)\n    parent_id: str | None = None\n    block_type: BlockType\n    start_line_num: int\n    end_line_num: int\n    code_content: str = \"\"\n    important_comments: list[CommentModel] | None = None\n    dependencies: list[ImportModel | DependencyModel] | None = None\n    summary: str | None = None\n    children_ids: list[str] | None = []\n\n    @field_validator(\"parent_id\")\n    def check_parent_id(cls, v, values) -> str | None:\n        \"\"\"Validates that parent_id is a non-empty string unless block_type is MODULE.\"\"\"\n        block_type = (\n            values.get(\"block_type\")\n            if isinstance(values, dict)\n            else values.data.get(\"block_type\")\n        )\n\n        if block_type and block_type != BlockType.MODULE:\n            if v is None or len(v) < 1:\n                raise ValueError(\n                    \"parent_id must be a non-empty string unless block_type is MODULE\"\n                )\n        return v\n\n    def _convert_parent_id_to_metadata(self) -> str:\n        \"\"\"Converts the parent_id to a metadata string.\"\"\"\n        return f\"{self.parent_id}\" if self.parent_id else \"\"\n\n    def _convert_block_type_to_metadata(self) -> str:\n        \"\"\"Converts the block_type to a metadata string.\"\"\"\n        return f\"{self.block_type.name}\"\n\n    def _convert_important_comments_to_metadata(self) -> str:\n        \"\"\"Converts the important comments to a metadata string.\"\"\"\n\n        important_comments: str = (\n            self.model_dump_json() if self.important_comments else \"\"\n        )\n\n        return f\"{important_comments}\"\n\n    def _convert_dependencies_to_metadata(self) -> str:\n        \"\"\"Converts the dependencies to a metadata string.\"\"\"\n\n        dependencies_str: str = \"\"\n\n        if self.dependencies:\n            for dependency in self.dependencies:\n                if isinstance(dependency, ImportModel):\n                    dependencies_str += f\"{dependency.convert_import_to_metadata()}\\n\"\n                elif isinstance(dependency, DependencyModel):\n                    dependencies_str += (\n                        f\"{dependency.convert_dependency_to_metadata()}\\n\"\n                    )\n\n        return dependencies_str\n\n    def _convert_summary_to_metadata(self) -> str:\n        \"\"\"Converts the summary to a metadata string.\"\"\"\n        return f\"{self.summary}\" if self.summary else \"\"\n\n    def _convert_children_to_metadata(self) -> str:\n        \"\"\"Converts the children to a metadata string.\"\"\"\n\n        return str(self.children_ids) if self.children_ids else \"\"\n\n    def _convert_base_attributes_to_metadata_dict(self) -> dict[str, str | int]:\n        \"\"\"Converts the base attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"id\": self.id,\n            \"file_path\": self.file_path,\n            \"parent_id\": self._convert_parent_id_to_metadata(),\n            \"block_type\": self._convert_block_type_to_metadata(),\n            \"start_line_num\": self.start_line_num,\n            \"end_line_num\": self.end_line_num,\n            \"code_content\": self.code_content,\n            \"important_comments\": self._convert_important_comments_to_metadata(),\n            \"dependencies\": self._convert_dependencies_to_metadata(),\n            \"summary\": self._convert_summary_to_metadata(),\n            \"children\": self._convert_children_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_metadata(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"BaseCodeBlockModel\":\n        \"\"\"Builds a BaseCodeBlockModel from a metadata dictionary.\"\"\"\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            id = metadata.get(\"id\")\n            if not isinstance(id, str):\n                raise ValueError(\"ID must be a string.\")\n\n            file_path = metadata.get(\"file_path\")\n            if not isinstance(file_path, str):\n                raise ValueError(\"File path must be a string.\")\n\n            block_type = metadata.get(\"block_type\")\n            if (\n                not isinstance(block_type, str)\n                or block_type not in BlockType._member_names_\n            ):\n                raise ValueError(\"Invalid block type.\")\n\n            start_line_num = metadata.get(\"start_line_num\")\n            if not isinstance(start_line_num, int):\n                raise ValueError(\"Start line number must be an integer.\")\n\n            end_line_num = metadata.get(\"end_line_num\")\n            if not isinstance(end_line_num, int):\n                raise ValueError(\"End line number must be an integer.\")\n\n            parent_id = metadata.get(\"parent_id\")\n            if not isinstance(parent_id, str):\n                raise ValueError(\"Parent ID must be a string.\")\n\n            code_content = metadata.get(\"code_content\", \"\")\n            if not isinstance(code_content, str):\n                raise ValueError(\"Code content must be a string.\")\n\n            summary = metadata.get(\"summary\")\n            if not isinstance(summary, str):\n                raise ValueError(\"Summary must be a string.\")\n\n            children_ids = metadata.get(\"children_ids\", [])\n            if not isinstance(children_ids, list) or not all(\n                isinstance(child_id, str) for child_id in children_ids\n            ):\n                raise ValueError(\"Children IDs must be a list of strings.\")\n\n            important_comments_data = metadata.get(\"important_comments\", [])\n            if not isinstance(important_comments_data, list) or all(\n                isinstance(comment, dict) for comment in important_comments_data\n            ):\n                raise ValueError(\"Important comments must be a list.\")\n\n            important_comments: list[CommentModel] = []\n            for comment_data in important_comments_data:\n                if not isinstance(comment_data, dict):\n                    raise ValueError(\"Each important comment must be a dictionary.\")\n                comment: CommentModel = CommentModel._build_from_metadata(comment_data)\n                important_comments.append(comment)\n\n            dependencies: list[ImportModel | DependencyModel] = []\n            dependencies_data = metadata.get(\"dependencies\", [])\n            if isinstance(dependencies_data, list):\n                for dependency_data in dependencies_data:\n                    if not isinstance(dependency_data, dict):\n                        raise ValueError(\"Each dependency must be a dictionary.\")\n                    dependency = None\n                    if \"import_names\" in dependency_data:\n                        dependency = ImportModel._build_from_metadata(dependency_data)\n                    elif \"code_block_id\" in dependency_data:\n                        dependency = DependencyModel._build_from_metadata(\n                            dependency_data\n                        )\n                    if not dependency:\n                        raise ValueError(\"Invalid dependency.\")\n                    dependencies.append(dependency)\n            else:\n                raise ValueError(\"Dependencies must be a list.\")\n\n            return cls(\n                id=id,\n                file_path=file_path,\n                parent_id=parent_id,\n                block_type=BlockType[block_type],\n                start_line_num=start_line_num,\n                end_line_num=end_line_num,\n                code_content=code_content,\n                important_comments=important_comments,\n                dependencies=dependencies,\n                summary=summary if summary else None,\n                children_ids=children_ids,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n",
    "important_comments": null,
    "dependencies": [
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ImportModel"
        },
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DependencyModel"
        },
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-CommentModel"
        },
        {
            "import_names": [
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "ImportModuleType",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "CommentType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        }
    ],
    "summary": "The `BaseCodeBlockModel` class is a sophisticated data model designed to encapsulate and manage metadata for code blocks, playing a crucial role in systems that require detailed code analysis and documentation. Its primary purpose is to represent code blocks with comprehensive metadata, including their location, type, content, dependencies, and hierarchical relationships, and to facilitate the conversion of these attributes into structured metadata for storage or further processing. This metadata is essential for indexing, searching, and integrating with systems that require structured code information, such as code analysis tools, documentation generators, or integrated development environments (IDEs).\n\nKey components of the `BaseCodeBlockModel` include: the class itself, which extends Pydantic's `BaseModel` to leverage data validation and management features; attributes such as `id`, `file_path`, `parent_id`, `block_type`, `start_line_num`, `end_line_num`, `code_content`, `important_comments`, `dependencies`, `summary`, and `children_ids`; the `check_parent_id` method, a field validator ensuring the `parent_id` is valid based on the block type; and several private methods (`_convert_*_to_metadata`) responsible for converting attributes into metadata strings. The `_build_from_metadata` class method reconstructs a `BaseCodeBlockModel` instance from a metadata dictionary, ensuring all necessary attributes are correctly parsed and validated.\n\nThe implementation employs Pydantic for robust data validation, using field validators to enforce constraints on attributes. The design pattern emphasizes metadata conversion, with dedicated methods for transforming each attribute into a string or dictionary format suitable for storage in systems like ChromaDB. The code includes comprehensive error handling to ensure metadata is correctly structured and valid, raising exceptions when necessary. Custom types like `BlockType`, `CommentModel`, `ImportModel`, and `DependencyModel` are used, suggesting a modular design where these types are defined elsewhere in the project to represent specific aspects of code blocks and their dependencies.\n\nThe technical stack primarily involves Pydantic, which provides the `BaseModel` class and `Field` function for defining and validating model attributes. The code also references custom types, indicating a reliance on a broader codebase where these types are defined to encapsulate specific metadata aspects. This modular approach allows for easy extension and integration with other models and systems.\n\nIn the context of a larger project, this code is likely part of a code analysis or documentation tool that processes and organizes code into structured metadata. It interacts with other components that define the custom types used in the model and may interface with databases or storage systems to persist the metadata it generates. The class's modular design supports its integration into larger systems, enabling it to provide detailed code block metadata for indexing, searching, or further analysis. This functionality is crucial for systems that require a deep understanding of code structure and dependencies, such as IDEs, code review tools, or automated documentation generators.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-check_parent_id",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_parent_id_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_block_type_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_important_comments_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_dependencies_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_summary_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_children_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_convert_base_attributes_to_metadata_dict",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel__*__FUNCTION-_build_from_metadata"
    ]
}