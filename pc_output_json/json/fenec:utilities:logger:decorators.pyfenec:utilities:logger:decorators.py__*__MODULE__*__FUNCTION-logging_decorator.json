{
    "function_name": "logging_decorator",
    "docstring": "A decorator for adding enhanced logging to functions, with optional syntax highlighting.\n\nThis decorator logs the call to the decorated function at the specified logging level. If syntax_highlighting is enabled and the first argument of the function is a libcst.CSTNode, the decorator logs the node's content with syntax highlighting.\n\nArgs:\n    level (int): The logging level. Defaults to logging.DEBUG.\n    message (str | None): Custom log message. If None, a default message is generated.\n    syntax_highlighting (bool): If True, enables syntax highlighting for libcst.CSTNode arguments.\n\nReturns:\n    Callable: The decorated function with enhanced logging capability.\n\nExample:\n    >>> @logging_decorator(level=logging.INFO, message=\"Function start\", syntax_highlighting=True)\n    >>> def sample_function(arg1):\n    >>>     pass\n    # This decorates 'sample_function' with enhanced logging at INFO level.",
    "decorators": null,
    "parameters": null,
    "returns": "Callable",
    "is_method": false,
    "is_async": false,
    "id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-logging_decorator",
    "file_path": "fenec/utilities/logger/decorators.py",
    "parent_id": "fenec:utilities:logger:decorators.py__*__MODULE",
    "block_type": "FUNCTION",
    "start_line_num": 12,
    "end_line_num": 65,
    "code_content": "\n\ndef logging_decorator(\n    level=logging.DEBUG,\n    *,\n    message: str | None = None,\n    syntax_highlighting: bool = False,\n) -> Callable:\n    \"\"\"\n    A decorator for adding enhanced logging to functions, with optional syntax highlighting.\n\n    This decorator logs the call to the decorated function at the specified logging level. If syntax_highlighting is enabled and the first argument of the function is a libcst.CSTNode, the decorator logs the node's content with syntax highlighting.\n\n    Args:\n        level (int): The logging level. Defaults to logging.DEBUG.\n        message (str | None): Custom log message. If None, a default message is generated.\n        syntax_highlighting (bool): If True, enables syntax highlighting for libcst.CSTNode arguments.\n\n    Returns:\n        Callable: The decorated function with enhanced logging capability.\n\n    Example:\n        >>> @logging_decorator(level=logging.INFO, message=\"Function start\", syntax_highlighting=True)\n        >>> def sample_function(arg1):\n        >>>     pass\n        # This decorates 'sample_function' with enhanced logging at INFO level.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            log_message: str = (\n                message if message else (f\"Calling function: {func.__name__}\")\n            )\n            frame_info: inspect.FrameInfo = inspect.stack()[1]\n            caller_info: LoggingCallerInfo = _get_caller_info(frame_info)\n            code_content: str = _gather_code_content(syntax_highlighting, args)\n            logger: Logger = _get_logger(caller_info.caller_module_name)\n\n            _handle_logging(\n                logger,\n                caller_info,\n                level,\n                log_message,\n                syntax_highlighting,\n                code_content,\n            )\n\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n",
    "important_comments": null,
    "dependencies": [
        {
            "code_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-_get_caller_info"
        },
        {
            "code_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-_get_logger"
        },
        {
            "code_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-_gather_code_content"
        },
        {
            "code_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-_handle_logging"
        },
        {
            "import_names": [
                {
                    "name": "LoggingCallerInfo",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "NodeAndPositionData",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "wraps",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "functools",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "inspect",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "FrameInfo",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "inspect",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "LogRecord",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Logger",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "logging",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Callable",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        }
    ],
    "summary": "The provided Python code defines a `logging_decorator` function, which serves to augment the logging capabilities of other functions by introducing detailed and customizable log outputs. Its primary purpose is to log function calls at a specified logging level, with an optional feature to include syntax highlighting for arguments that are instances of `libcst.CSTNode`. This functionality is particularly advantageous for developers engaged in code transformations or static analysis using the `libcst` library, as it enhances readability and provides more informative logs.\n\nKey components of the code include the `logging_decorator` function, which accepts parameters such as `level`, `message`, and `syntax_highlighting` to configure the logging behavior; the `decorator` function, which wraps the target function to apply the logging enhancements; and the `wrapper` function, which executes the logging logic before invoking the original function. The implementation involves capturing the caller's frame information using the `inspect` module to obtain context about the function call, retrieving caller details through a helper function `_get_caller_info`, and gathering code content for logging via `_gather_code_content`. The logger is obtained using `_get_logger`, and the logging operation is managed by `_handle_logging`, which processes the log message, level, and syntax highlighting options.\n\nThe technical stack includes the `logging` module, which is used for performing logging operations, `inspect` for stack inspection to gather caller information, and `libcst` for enabling syntax highlighting capabilities when dealing with code represented as `CSTNode` objects. This decorator can be integrated into a logging utility module within a larger system, enhancing the logging functionality across various components by providing detailed and customizable log outputs. This integration is particularly useful in projects involving code analysis or transformation, where understanding the context and content of code elements is crucial. By improving debugging and monitoring processes, this decorator contributes to a more robust and maintainable codebase, facilitating easier identification and resolution of issues.\n\nIn the context of a larger system, this code fits as a utility that enhances the observability of function executions, particularly in environments where code analysis and transformation are frequent. It interacts with other components by providing enriched logging data that can be used for debugging, auditing, or performance monitoring. This decorator is especially beneficial in development environments where understanding the flow and transformation of code is essential, thereby supporting developers in maintaining high code quality and reliability.",
    "children_ids": [
        "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-logging_decorator__*__FUNCTION-decorator"
    ]
}