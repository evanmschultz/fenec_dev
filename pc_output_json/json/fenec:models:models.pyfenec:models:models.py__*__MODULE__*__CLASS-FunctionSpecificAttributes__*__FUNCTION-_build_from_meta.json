{
    "function_name": "_build_from_meta",
    "docstring": "Builds a FunctionSpecificAttributes from a metadata dictionary.",
    "decorators": [
        {
            "content": "@classmethod",
            "decorator_name": "classmethod",
            "decorator_args": null
        }
    ],
    "parameters": null,
    "returns": "No return annotation",
    "is_method": true,
    "is_async": false,
    "id": "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes__*__FUNCTION-_build_from_meta",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes",
    "block_type": "FUNCTION",
    "start_line_num": 939,
    "end_line_num": 1006,
    "code_content": "\n@classmethod\ndef _build_from_meta(\n    cls, metadata: dict[str, str | bool]\n) -> \"FunctionSpecificAttributes\":\n    \"\"\"Builds a FunctionSpecificAttributes from a metadata dictionary.\"\"\"\n\n    try:\n        if not isinstance(metadata, dict):\n            raise ValueError(\"Metadata must be a dictionary.\")\n\n        function_name = metadata.get(\"function_name\")\n        if not isinstance(function_name, str):\n            raise ValueError(\"Function name must be a string.\")\n\n        docstring = metadata.get(\"docstring\")\n        if not isinstance(docstring, str):\n            raise ValueError(\"Docstring must be a string.\")\n\n        decorators_data = metadata.get(\"decorators\", [])\n        if not isinstance(decorators_data, list):\n            raise ValueError(\"Decorators must be a list.\")\n\n        decorators: list[DecoratorModel] = []\n        for decorator_data in decorators_data:\n            if not isinstance(decorator_data, dict):\n                raise ValueError(\"Each decorator must be a dictionary.\")\n            decorator: DecoratorModel = DecoratorModel._build_from_metadata(\n                decorator_data\n            )\n            decorators.append(decorator)\n\n        parameters_data = metadata.get(\"parameters\")\n        if not isinstance(parameters_data, dict):\n            raise ValueError(\"Parameters must be a dictionary.\")\n\n        parameters: ParameterListModel = ParameterListModel._build_from_metadata(\n            parameters_data\n        )\n\n        returns = metadata.get(\"returns\")\n        if not isinstance(returns, str):\n            raise ValueError(\"Returns must be a string.\")\n\n        is_method = metadata.get(\"is_method\")\n        if not isinstance(is_method, bool):\n            raise ValueError(\"is_method must be a boolean.\")\n\n        is_async = metadata.get(\"is_async\")\n        if not isinstance(is_async, bool):\n            raise ValueError(\"is_async must be a boolean.\")\n\n        return cls(\n            function_name=function_name,\n            docstring=docstring,\n            decorators=decorators,\n            parameters=parameters,\n            returns=returns,\n            is_method=is_method,\n            is_async=is_async,\n        )\n    except ValueError as ve:\n        logging.error(f\"Error building from metadata: {ve}\")\n        raise ve\n    except Exception as e:\n        logging.error(f\"An unexpected error occurred: {e}\")\n        raise e\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This code defines a class method `_build_from_meta` within the `FunctionSpecificAttributes` class, designed to construct an instance of this class from a metadata dictionary. The primary purpose of this method is to parse and validate metadata related to a function's attributes, ensuring that each component is correctly typed and structured before creating a `FunctionSpecificAttributes` object. This method is significant as it provides a structured way to dynamically generate function attribute objects, which can be crucial for introspection, code analysis, or documentation generation tasks.\n\nKey components of this method include: `function_name`, `docstring`, `decorators`, `parameters`, `returns`, `is_method`, and `is_async`. Each of these components is extracted from the metadata dictionary and validated for type correctness. The `decorators` are processed using a list of `DecoratorModel` objects, each constructed from nested metadata using the `DecoratorModel._build_from_metadata` method. Similarly, the `parameters` are handled by the `ParameterListModel`, which is built from its respective metadata using `ParameterListModel._build_from_metadata`.\n\nThe implementation involves a series of type checks and error handling to ensure the metadata dictionary contains valid entries. It uses Python's built-in data structures such as dictionaries and lists, along with exception handling mechanisms to manage errors gracefully. The method employs helper methods from custom classes like `DecoratorModel` and `ParameterListModel` to construct complex objects from nested metadata, demonstrating a modular design pattern that promotes code reuse and separation of concerns. The method returns an instance of `FunctionSpecificAttributes` populated with the validated and parsed data.\n\nThe technical stack is primarily based on Python, utilizing its standard library for data handling and error management. The custom classes `DecoratorModel` and `ParameterListModel` are integral to the metadata parsing process, providing specialized functionality for handling decorators and parameters, respectively.\n\nIn the context of a larger system, this method likely serves as a utility for dynamically generating function attribute objects, facilitating introspection or code analysis tasks. It interacts with other components by leveraging metadata to instantiate objects that represent function characteristics, potentially integrating with systems that require detailed function metadata for processing or documentation purposes. This method could be part of a larger framework or toolset aimed at enhancing code analysis capabilities, supporting features like automated documentation generation, code refactoring, or dynamic function invocation based on metadata. Its role in the system is to ensure that function attributes are accurately represented and accessible for further processing or analysis, thereby contributing to the overall robustness and flexibility of the system.",
    "children_ids": []
}