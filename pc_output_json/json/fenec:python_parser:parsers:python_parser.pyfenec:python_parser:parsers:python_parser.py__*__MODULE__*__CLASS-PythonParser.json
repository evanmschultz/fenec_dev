{
    "class_name": "PythonParser",
    "decorators": null,
    "bases": null,
    "docstring": "A parser for Python source code, using libcst to parse and construct a module model.\n\nThis class takes the path to a Python file, reads its contents, and parses it into a structured\nmodule model using the libcst library. It is designed to work with a specific file at a time.\n\nAttributes:\n    - file_path (str): The path to the Python file to be parsed.\n\nExample:\n    ```Python\n    python_parser = PythonParser(\"/path/to/python/file.py\")\n    code = python_parser.open_file()\n    module_model = python_parser.parse(code, parent_id=\"parent_module_id\")\n    # Parses the provided code and returns a structured module model.\n    ```",
    "keywords": null,
    "id": "fenec:python_parser:parsers:python_parser.py__*__MODULE__*__CLASS-PythonParser",
    "file_path": "fenec/python_parser/parsers/python_parser.py",
    "parent_id": "fenec:python_parser:parsers:python_parser.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 32,
    "end_line_num": 115,
    "code_content": "\n\nclass PythonParser:\n    \"\"\"\n    A parser for Python source code, using libcst to parse and construct a module model.\n\n    This class takes the path to a Python file, reads its contents, and parses it into a structured\n    module model using the libcst library. It is designed to work with a specific file at a time.\n\n    Attributes:\n        - file_path (str): The path to the Python file to be parsed.\n\n    Example:\n        ```Python\n        python_parser = PythonParser(\"/path/to/python/file.py\")\n        code = python_parser.open_file()\n        module_model = python_parser.parse(code, parent_id=\"parent_module_id\")\n        # Parses the provided code and returns a structured module model.\n        ```\n    \"\"\"\n\n    def __init__(self, file_path: str) -> None:\n        self.file_path: str = file_path\n\n    def open_file(self) -> str:\n        \"\"\"\n        Opens and reads the contents of the Python file specified in the file_path attribute.\n\n        Returns:\n            - str: The contents of the file as a string.\n\n        Example:\n            ```Python\n            python_parser = PythonParser(\"/path/to/python/file.py\")\n            code = python_parser.open_file()\n            # Reads and returns the contents of the Python file.\n            ```\n        \"\"\"\n\n        with open(self.file_path, \"r\") as file:\n            return file.read()\n\n    def parse(self, code: str, parent_id: str) -> ModuleModelBuilder | None:\n        \"\"\"\n        Parses the provided Python code into a structured module model.\n\n        Uses libcst to parse the provided code using the ModuleVisitor class. A ModuleModelBuilder instance is returned\n        along with its hierarchy of child builders.\n\n        Args:\n            - code (str): The Python code to be parsed.\n            - parent_id (str): The ID of the parent module or block.\n\n        Returns:\n            - ModuleModelBuilder | None: The module model builder for the provided code.\n\n        Example:\n            ```Python\n            python_parser = PythonParser(\"/path/to/python/file.py\")\n            code = python_parser.open_file()\n            module_model = python_parser.parse(code, parent_id=\"parent_module_id\")\n            # Parses the provided code and returns a module model builder.\n            ```\n        \"\"\"\n\n        wrapper = MetadataWrapper(libcst.parse_module(code))\n        module_id: str = ModuleIDGenerationStrategy.generate_id(\n            file_path=self.file_path\n        )\n        module_builder: ModuleModelBuilder = BuilderFactory.create_builder_instance(\n            block_type=BlockType.MODULE,\n            id=module_id,\n            file_path=self.file_path,\n            parent_id=parent_id,\n        )\n        visitor = ModuleVisitor(id=module_id, module_builder=module_builder)\n        wrapper.visit(visitor)\n\n        return (\n            visitor.builder_stack[0]\n            if isinstance(visitor.builder_stack[0], ModuleModelBuilder)\n            else None\n        )\n",
    "important_comments": null,
    "dependencies": [
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "MetadataWrapper",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "libcst.metadata",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ModuleIDGenerationStrategy",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:id_generation:id_generation_strategies.py__*__MODULE__*__CLASS-ModuleIDGenerationStrategy"
                }
            ],
            "imported_from": "fenec.python_parser.id_generation.id_generation_strategies",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:id_generation:id_generation_strategies.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BuilderFactory",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:builder_factory.py__*__MODULE__*__CLASS-BuilderFactory"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.builder_factory",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:builder_factory.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModuleModelBuilder",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:module_model_builder.py__*__MODULE__*__CLASS-ModuleModelBuilder"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.module_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:module_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModuleVisitor",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:visitors:module_visitor.py__*__MODULE__*__CLASS-ModuleVisitor"
                }
            ],
            "imported_from": "fenec.python_parser.visitors.module_visitor",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:module_visitor.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-BlockType"
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:enums.py__*__MODULE"
        }
    ],
    "summary": "The `PythonParser` class is a specialized tool designed to parse Python source code files into structured module models, utilizing the `libcst` library to enable detailed code analysis and transformation. Its primary function is to convert Python code into a structured format that can be programmatically manipulated, which is essential for applications such as code linters, formatters, or static analysis tools. Key components of the class include the `__init__` method, which initializes the parser with a specified file path; the `open_file` method, responsible for reading the contents of the Python file; and the `parse` method, which leverages `libcst` to parse the code into a module model, returning a `ModuleModelBuilder` instance. The `parse` method is particularly significant as it employs a `MetadataWrapper` to enhance the abstract syntax tree (AST) with metadata, and a `ModuleVisitor` to traverse the tree and build a module model. The `BuilderFactory` is used to create instances of `ModuleModelBuilder` based on the parsed structure, while the `ModuleIDGenerationStrategy` generates unique identifiers for modules, ensuring each parsed module is distinct.\n\nThe implementation of the `PythonParser` class is centered around the `libcst` library, which provides a concrete syntax tree with metadata support, allowing for detailed and accurate parsing of Python code. The `MetadataWrapper` is used to wrap the parsed module, adding metadata that can be utilized during the traversal and model-building process. The `ModuleVisitor` class is a custom visitor that traverses the syntax tree, using a stack to manage the hierarchy of builders, and the `BuilderFactory` is responsible for instantiating the appropriate builder objects. The `ModuleIDGenerationStrategy` ensures that each module is uniquely identifiable, which is crucial for maintaining the integrity of the module models within a larger system.\n\nThe technical stack includes `libcst` for parsing and manipulating Python code, and custom classes such as `ModuleVisitor`, `ModuleModelBuilder`, and `BuilderFactory` for constructing and managing the module models. These components work together to provide a robust framework for parsing and analyzing Python code, with the potential for integration into larger systems that require detailed code analysis or transformation capabilities.\n\nIn the context of a larger project or system, the `PythonParser` class serves as a foundational component for tools that require a structured representation of Python code. It interacts with other components by providing a detailed and manipulable model of the code, which can be further processed or analyzed by other tools or systems. This makes it an essential part of any system that involves code analysis, transformation, or generation, providing a reliable and extensible framework for working with Python code at a granular level. Its design supports integration with various subsystems, such as syntax checkers, code analyzers, or documentation generators, which rely on accurate and detailed code representations for their operations.",
    "children_ids": [
        "fenec:python_parser:parsers:python_parser.py__*__MODULE__*__CLASS-PythonParser__*__FUNCTION-__init__",
        "fenec:python_parser:parsers:python_parser.py__*__MODULE__*__CLASS-PythonParser__*__FUNCTION-open_file",
        "fenec:python_parser:parsers:python_parser.py__*__MODULE__*__CLASS-PythonParser__*__FUNCTION-parse"
    ]
}