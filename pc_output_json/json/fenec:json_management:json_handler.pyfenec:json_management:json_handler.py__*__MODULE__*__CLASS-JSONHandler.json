{
    "class_name": "JSONHandler",
    "decorators": null,
    "bases": null,
    "docstring": "A class for handling the serialization and storage of parsed code models in JSON format.\n\nThis class provides methods to save parsed code models, such as modules, classes, functions, standalone code blocks, and directory maps, as JSON files. It ensures proper organization and cleanup of the output directory.\n\nAttributes:\n    - directory (str): The base directory of the parsed code.\n    - output_directory (str): The directory where JSON output files are stored.\n    - directory_modules (dict[str, list[str]]): A mapping of directories to their corresponding Python files.\n\nExample:\n    ```Python\n    # This example demonstrates how to use JSONHandler to save a parsed model as JSON.\n    handler = JSONHandler(directory=\"/path/to/code\", directory_modules={})\n    module_model = ModuleModel(id='module1', file_path='/path/to/code/module1.py')\n    handler.save_model_as_json(module_model, file_path='/path/to/code/module1.py')\n    ```",
    "keywords": null,
    "id": "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler",
    "file_path": "fenec/json_management/json_handler.py",
    "parent_id": "fenec:json_management:json_handler.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 23,
    "end_line_num": 186,
    "code_content": "\n\nclass JSONHandler:\n    \"\"\"\n    A class for handling the serialization and storage of parsed code models in JSON format.\n\n    This class provides methods to save parsed code models, such as modules, classes, functions, standalone code blocks, and directory maps, as JSON files. It ensures proper organization and cleanup of the output directory.\n\n    Attributes:\n        - directory (str): The base directory of the parsed code.\n        - output_directory (str): The directory where JSON output files are stored.\n        - directory_modules (dict[str, list[str]]): A mapping of directories to their corresponding Python files.\n\n    Example:\n        ```Python\n        # This example demonstrates how to use JSONHandler to save a parsed model as JSON.\n        handler = JSONHandler(directory=\"/path/to/code\", directory_modules={})\n        module_model = ModuleModel(id='module1', file_path='/path/to/code/module1.py')\n        handler.save_model_as_json(module_model, file_path='/path/to/code/module1.py')\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        directory: str,\n        directory_modules: dict[str, list[str]],\n        output_directory: str = \"output_json\",\n    ) -> None:\n        self.directory: str = directory\n        self.output_directory: str = output_directory\n        self.directory_modules: dict[str, list[str]] = directory_modules\n\n        self._clean_output_directory()\n        self._create_output_directory()\n\n    @logging_decorator(message=\"Saving model as JSON\")\n    def save_model_as_json(\n        self,\n        model: ModelType,\n        file_path: str,\n    ) -> None:\n        \"\"\"\n        Saves a parsed ModelType as JSON.\n\n        Args:\n            - model (ModelType): The parsed code model to be saved.\n            - file_path (str): The file path of the original Python file.\n\n        Example:\n            ```Python\n            # This example demonstrates how to use JSONHandler to save a parsed model as JSON.\n            handler = JSONHandler(directory=\"/path/to/code\", directory_modules={})\n            module_model = ModuleModel(id='module1', file_path='/path/to/code/module1.py')\n            handler.save_model_as_json(module_model, file_path='/path/to/code/module1.py')\n            ```\n        \"\"\"\n\n        json_output_directory: str = self._create_json_output_directory()\n        output_path: str = self._get_json_output_path(file_path, json_output_directory)\n        self._write_json_file(model, output_path)\n\n    @logging_decorator(message=\"Saving visited directories\")\n    def save_visited_directories(\n        self, directory_mape_name: str = \"directory_map.json\"\n    ) -> None:\n        \"\"\"\n        Saves a JSON file mapping each visited directory to its Python files.\n\n        The output is saved in a file named 'directory_map.json' within the specified output directory.\n\n        Args:\n            - directory_map_name (str, optional): The name of the output file for the directory map. Defaults to \"directory_map.json\".\n\n        Example:\n            ```Python\n            # This example demonstrates how to save visited directories as a JSON map.\n            handler = JSONHandler(directory=\"/path/to/code\", directory_modules={})\n            handler.save_visited_directories(directory_map_name=\"custom_map.json\")\n            ```\n        \"\"\"\n\n        output_path: str = self._get_directory_map_output_path(directory_mape_name)\n        self._write_json_directory_map(output_path)\n\n    def _create_output_directory(self) -> None:\n        \"\"\"Creates the output directory if it does not already exist.\"\"\"\n\n        Path(self.output_directory).mkdir(exist_ok=True)\n\n    def _create_json_output_directory(self) -> str:\n        \"\"\"\n        Creates the JSON output directory if it does not already exist.\n\n        Returns:\n            str: The path to the created JSON output directory.\n        \"\"\"\n\n        json_output_directory: Path = Path(self.output_directory) / \"json\"\n        json_output_directory.mkdir(exist_ok=True)\n        return str(json_output_directory)\n\n    def _get_json_output_path(self, file_path: str, json_output_directory: str) -> str:\n        \"\"\"\n        Gets the output path for a JSON file.\n\n        Args:\n            - file_path (str): The file path of the original Python file.\n            - json_output_directory (str): The path to the JSON output directory.\n\n        Returns:\n            str: The output path for the JSON file.\n        \"\"\"\n\n        if \"DIRECTORY\" in file_path:\n            safe_file_path: str = file_path.replace(\"/\", \":\")\n            return str(Path(json_output_directory) / f\"{safe_file_path}.json\")\n        else:\n            relative_path: Path = Path(file_path).relative_to(Path(self.directory))\n            safe_relative_path: str = str(relative_path).replace(\"/\", \":\").rstrip(\".py\")\n            return str(Path(json_output_directory) / f\"{safe_relative_path}.json\")\n\n    def _write_json_file(\n        self,\n        module_model: ModelType,\n        output_path: str,\n    ) -> None:\n        \"\"\"\n        Writes a JSON file containing the parsed data from a ModuleModel.\n\n        Args:\n            - module_model (ModelType): The parsed code model.\n            - output_path (str): The path where the JSON file will be saved.\n        \"\"\"\n\n        parsed_data_json: str = module_model.model_dump_json(indent=4)\n        with open(output_path, \"w\") as json_file:\n            json_file.write(parsed_data_json)\n\n    def _get_directory_map_output_path(self, directory_output_name: str) -> str:\n        \"\"\"\n        Gets the output path for the directory map JSON file.\n\n        Args:\n            - directory_output_name (str): The name of the output file for the directory map.\n\n        Returns:\n            str: The output path for the directory map JSON file.\n        \"\"\"\n\n        return str(Path(self.output_directory) / directory_output_name)\n\n    def _write_json_directory_map(self, output_path: str) -> None:\n        \"\"\"Writes the directory map JSON file.\"\"\"\n\n        with open(output_path, \"w\") as json_file:\n            json.dump(self.directory_modules, json_file, indent=4)\n\n    def _clean_output_directory(self) -> None:\n        \"\"\"Deletes the output directory and all its contents.\"\"\"\n\n        output_dir = Path(self.output_directory)\n        if output_dir.exists() and output_dir.is_dir():\n            rmtree(output_dir)\n",
    "important_comments": null,
    "dependencies": [
        {
            "import_names": [
                {
                    "name": "json",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Path",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pathlib",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "rmtree",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "shutil",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ModuleModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ModuleModel"
                },
                {
                    "name": "ClassModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ClassModel"
                },
                {
                    "name": "FunctionModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-FunctionModel"
                },
                {
                    "name": "StandaloneCodeBlockModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-StandaloneCodeBlockModel"
                },
                {
                    "name": "DirectoryModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "logging_decorator",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-logging_decorator"
                }
            ],
            "imported_from": "fenec.utilities.logger.decorators",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:logger:decorators.py__*__MODULE"
        }
    ],
    "summary": "The `JSONHandler` class is a Python utility designed to facilitate the serialization and storage of parsed code models into JSON format, playing a crucial role in managing the conversion of various code components such as modules, classes, functions, standalone code blocks, and directory mappings into structured JSON files. This class ensures the organized storage and cleanup of the output directory, which is essential for maintaining a tidy and accessible repository of code analysis results. Key components of the `JSONHandler` class include: the `__init__` method, which initializes the handler with directory paths and cleans the output directory; `save_model_as_json`, which saves parsed models as JSON files; `save_visited_directories`, which creates a JSON map of visited directories and their Python files; and several private methods like `_create_output_directory`, `_create_json_output_directory`, `_get_json_output_path`, `_write_json_file`, `_get_directory_map_output_path`, `_write_json_directory_map`, and `_clean_output_directory`, which handle directory creation, path management, and file writing operations.\n\nThe implementation employs a structured approach to directory and file management, leveraging the `Path` class from the `pathlib` module to handle file paths and directories, ensuring cross-platform compatibility and ease of use. The `rmtree` function from the `shutil` module is utilized for directory cleanup, providing a robust mechanism for removing directories and their contents. The class also incorporates a `logging_decorator` to log operations such as saving models and directories, enhancing traceability and debugging capabilities. The design pattern follows a modular approach, encapsulating functionality within methods that handle specific tasks related to JSON file management, thereby promoting code reusability and maintainability.\n\nThe technical stack primarily consists of Python's standard library modules, including `pathlib` for path manipulations and `shutil` for directory operations, along with a custom `logging_decorator` for logging purposes. This choice of stack ensures that the code remains lightweight and does not introduce unnecessary dependencies, which is advantageous for integration into larger systems.\n\nIn the context of a larger project or system, the `JSONHandler` class serves as a utility for converting and storing code analysis results in a structured format, potentially interfacing with other components that perform code parsing and analysis. It ensures that the output is organized and easily accessible for further processing or review, fitting into a workflow that involves code analysis, documentation, or archiving. The `JSONHandler` class is a crucial part of a system that requires efficient management of code metadata and structure, supporting tasks like code review, refactoring, or documentation generation. Its role in the larger codebase is to provide a reliable and consistent method for handling the output of code analysis tools, ensuring that the data is stored in a format that is both human-readable and machine-processable, thereby facilitating downstream processing and integration with other systems.",
    "children_ids": [
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-__init__",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-save_model_as_json",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-save_visited_directories",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_create_output_directory",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_create_json_output_directory",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_get_json_output_path",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_write_json_file",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_get_directory_map_output_path",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_write_json_directory_map",
        "fenec:json_management:json_handler.py__*__MODULE__*__CLASS-JSONHandler__*__FUNCTION-_clean_output_directory"
    ]
}