{
    "function_name": "_get_caller_info",
    "docstring": "Extracts and returns caller information from a frame object.",
    "decorators": null,
    "parameters": null,
    "returns": "LoggingCallerInfo",
    "is_method": false,
    "is_async": false,
    "id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-_get_caller_info",
    "file_path": "fenec/utilities/logger/decorators.py",
    "parent_id": "fenec:utilities:logger:decorators.py__*__MODULE",
    "block_type": "FUNCTION",
    "start_line_num": 81,
    "end_line_num": 90,
    "code_content": "\n\ndef _get_caller_info(frame_info: FrameInfo) -> LoggingCallerInfo:\n    \"\"\"Extracts and returns caller information from a frame object.\"\"\"\n\n    caller_module_name: str = frame_info.filename.split(\"/\")[-1].split(\".\")[0]\n    caller_file_path: str = frame_info.filename\n    caller_line_no: int = frame_info.lineno\n    return LoggingCallerInfo(caller_module_name, caller_file_path, caller_line_no)\n",
    "important_comments": null,
    "dependencies": [
        {
            "import_names": [
                {
                    "name": "LoggingCallerInfo",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "NodeAndPositionData",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "FrameInfo",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "inspect",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        }
    ],
    "summary": "This code snippet is a specialized utility function designed to enhance logging and debugging capabilities by extracting detailed caller information from a given frame object. Its primary purpose is to provide structured metadata about the caller of a function, which is crucial for improving the granularity and context of log messages in software systems. The main function, `_get_caller_info`, takes a `FrameInfo` object as input and returns a `LoggingCallerInfo` object. This object is a structured data type that encapsulates the module name, file path, and line number of the caller, facilitating easy access and integration into logging systems. Key components include the `_get_caller_info` function, which parses the `filename` attribute of the `FrameInfo` object to derive the module name by splitting the path and file extension, and the `LoggingCallerInfo` class, which stores the extracted information.\n\nThe implementation leverages Python's standard library, specifically the `inspect` module, to obtain the `FrameInfo` object, which provides comprehensive details about the stack frame. The function extracts the module name by splitting the file path string, isolates the file name, and removes the extension, while the line number is directly accessed from the `lineno` attribute. This method ensures accurate capture and formatting of the caller's metadata, making it suitable for logging purposes.\n\nThe technical stack is minimal, relying solely on Python's built-in capabilities, particularly the `inspect` module, which is widely used for introspection tasks such as retrieving stack frames and examining the call stack. This makes the function lightweight and easy to integrate into existing Python applications without additional dependencies.\n\nIn the context of a larger logging or debugging system, this function plays a critical role by providing essential metadata about code execution. It can be seamlessly integrated with logging frameworks like Python's `logging` module or custom logging solutions to enhance the detail and context of log messages. By supplying detailed caller information, it aids developers in tracing the flow of execution and diagnosing issues more effectively, thereby improving the overall maintainability and reliability of the software system. This utility is particularly valuable in complex applications where understanding the execution context is key to identifying and resolving issues efficiently.",
    "children_ids": []
}