{
    "class_name": "DirectoryModel",
    "decorators": null,
    "bases": [
        "BaseModel"
    ],
    "docstring": "Model for a directory.\n\nAttributes:\n    - id (str): The unique identifier for the directory.\n    - block_type (BlockType): The type of code block that the directory represents.\n    - directory_name (str): The name of the directory.\n    - sub_directories_ids (list[str]): A list of the identifiers of the sub-directories of the directory.\n    - children_ids (list[str]): A list of the identifiers of the children of the directory.\n    - parent_id (str | None): The identifier of the parent (usually a directory).\n    - summary (str | None): A summary of the directory.\n\nMethods:\n    - `convert_to_metadata() -> dict[str, str | int]`:\n        Converts the directory model to a metadata dictionary for ChromaDB.",
    "keywords": null,
    "id": "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models:models.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 1213,
    "end_line_num": 1322,
    "code_content": "\n\nclass DirectoryModel(BaseModel):\n    \"\"\"\n    Model for a directory.\n\n    Attributes:\n        - id (str): The unique identifier for the directory.\n        - block_type (BlockType): The type of code block that the directory represents.\n        - directory_name (str): The name of the directory.\n        - sub_directories_ids (list[str]): A list of the identifiers of the sub-directories of the directory.\n        - children_ids (list[str]): A list of the identifiers of the children of the directory.\n        - parent_id (str | None): The identifier of the parent (usually a directory).\n        - summary (str | None): A summary of the directory.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`:\n            Converts the directory model to a metadata dictionary for ChromaDB.\n    \"\"\"\n\n    id: str\n    block_type: BlockType = BlockType.DIRECTORY\n    directory_name: str\n    sub_directories_ids: list[str]\n    children_ids: list[str]\n    parent_id: str | None\n    summary: str | None = None\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the directory model to a metadata dictionary for ChromaDB.\"\"\"\n\n        return {\n            \"directory_name\": self.directory_name,\n            \"sub_directories\": (\n                str(self.sub_directories_ids) if self.sub_directories_ids else \"\"\n            ),\n            \"children_ids\": self.model_dump_json() if self.children_ids else \"\",\n            \"parent_id\": self.parent_id if self.parent_id else \"\",\n            \"summary\": self.summary if self.summary else \"\",\n        }\n\n    @classmethod\n    def build_from_metadata(\n        cls, metadata_dict: dict[str, str | list[str]]\n    ) -> \"DirectoryModel\":\n        \"\"\"\n        Builds a DirectoryModel from a metadata dictionary.\n\n        Args:\n            - metadata_dict (dict[str, str | int | list[str]]): A dictionary containing metadata for a directory.\n\n        Returns:\n            - DirectoryModel: An instance of DirectoryModel.\n\n        Raises:\n            - ValueError: If the metadata is not a dictionary.\n            - ValueError: If the metadata is missing required keys.\n            - ValueError: If the metadata contains invalid values.\n            - Exception: If an unexpected error occurs.\n        \"\"\"\n\n        try:\n            if not isinstance(metadata_dict, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            id = metadata_dict.get(\"id\")\n            if not isinstance(id, str):\n                raise ValueError(\"ID must be a string.\")\n\n            directory_name = metadata_dict.get(\"directory_name\")\n            if not isinstance(directory_name, str):\n                raise ValueError(\"Directory name must be a string.\")\n\n            sub_directories_ids = metadata_dict.get(\"sub_directories\")\n            if not isinstance(sub_directories_ids, list) or not all(\n                isinstance(sub_directory_id, str)\n                for sub_directory_id in sub_directories_ids\n            ):\n                raise ValueError(\"Sub-directories must be a list of strings.\")\n\n            children_ids = metadata_dict.get(\"children_ids\")\n            if not isinstance(children_ids, list) or not all(\n                isinstance(child_id, str) for child_id in children_ids\n            ):\n                raise ValueError(\"Children IDs must be a list of strings.\")\n\n            parent_id = metadata_dict.get(\"parent_id\")\n            if not isinstance(parent_id, str):\n                raise ValueError(\"Parent ID must be a string.\")\n\n            summary = metadata_dict.get(\"summary\")\n            if not isinstance(summary, str):\n                raise ValueError(\"Summary must be a string.\")\n\n            return cls(\n                id=id,\n                directory_name=directory_name,\n                sub_directories_ids=sub_directories_ids,\n                children_ids=children_ids,\n                parent_id=parent_id if parent_id else None,\n                summary=summary if summary else None,\n            )\n\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n",
    "important_comments": null,
    "dependencies": [
        {
            "import_names": [
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "ImportModuleType",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "CommentType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        }
    ],
    "summary": "The provided Python code defines a `DirectoryModel` class, which serves as a data model for representing directory structures within a system, likely for organizational or metadata management purposes. The main goal of this code is to encapsulate directory-related information, such as identifiers, names, and hierarchical relationships, and to facilitate the conversion of this information to and from a metadata format suitable for storage or processing in systems like ChromaDB. This is significant for systems that require efficient storage and retrieval of hierarchical data structures, such as content management systems or data processing pipelines.\n\nKey components of the code include the `DirectoryModel` class itself, which inherits from `BaseModel`, suggesting the use of a data modeling library like Pydantic for data validation and serialization. The class defines several attributes: `id`, `block_type`, `directory_name`, `sub_directories_ids`, `children_ids`, `parent_id`, and `summary`. Two primary methods are implemented: `convert_to_metadata` and `build_from_metadata`. The `convert_to_metadata` method transforms the directory's attributes into a dictionary format, which is useful for integration with ChromaDB, handling optional fields gracefully by checking for their presence. The `build_from_metadata` method is a class method that reconstructs a `DirectoryModel` instance from a given metadata dictionary, ensuring data integrity through rigorous type and value checks.\n\nThe implementation leverages object-oriented programming principles, focusing on data encapsulation and validation. The `convert_to_metadata` method uses Python's ternary conditional operator to check the presence of optional attributes and serialize them into strings or JSON format as appropriate. It also utilizes a `model_dump_json` function, assumed to serialize the `children_ids` into a JSON string, indicating potential use of a serialization library or custom serialization logic. The `build_from_metadata` method involves a series of type checks and validations, using Python's built-in `dict` type for metadata storage and retrieval. It raises `ValueError` exceptions for various validation failures, ensuring robust error handling, and uses exception handling to manage unexpected errors gracefully.\n\nThe technical stack primarily consists of Python, utilizing standard language features such as type annotations, dictionary comprehensions, and conditional expressions. The `BaseModel` inheritance suggests the use of Pydantic, known for its data validation and serialization capabilities. The code assumes the existence of a `BlockType` enumeration or class, which categorizes the type of code block the directory represents.\n\nIn the context of a larger system, this code fits into a data management or storage module, where it serves as a utility function for integrating directory metadata into ChromaDB. The `DirectoryModel` class, along with its methods, encapsulates directory information and facilitates its conversion to and from a metadata format, ensuring data integrity and consistency. This functionality is crucial for systems that require structured data input and efficient querying and manipulation of directory metadata within the broader system architecture. The modular design of the `DirectoryModel` class allows it to be easily extended or adapted for various use cases within the system, supporting seamless integration with storage systems and ensuring data consistency across different parts of the application.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel__*__FUNCTION-convert_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel__*__FUNCTION-build_from_metadata"
    ]
}