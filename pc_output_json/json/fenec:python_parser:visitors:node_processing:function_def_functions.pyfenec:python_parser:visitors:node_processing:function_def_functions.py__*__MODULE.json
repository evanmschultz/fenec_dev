{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "FunctionModelBuilder",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:function_model_builder.py__*__MODULE__*__CLASS-FunctionModelBuilder"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.function_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:function_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "DecoratorModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                },
                {
                    "name": "ParameterModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ParameterModel"
                },
                {
                    "name": "ParameterListModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ParameterListModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-BlockType"
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:enums.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "fenec.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "PositionData",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:processing_context.py__*__MODULE__*__CLASS-PositionData"
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:processing_context.py__*__MODULE"
        }
    ],
    "id": "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE",
    "file_path": "fenec/python_parser/visitors/node_processing/function_def_functions.py",
    "parent_id": "fenec:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 200,
    "code_content": "from typing import Sequence\n\nimport libcst\n\nfrom fenec.python_parser.model_builders.function_model_builder import (\n    FunctionModelBuilder,\n)\n\nfrom fenec.models.models import (\n    DecoratorModel,\n    ParameterListModel,\n    ParameterModel,\n)\nfrom fenec.models.enums import BlockType\nimport fenec.python_parser.visitors.node_processing.common_functions as common_functions\n\nfrom fenec.utilities.processing_context import PositionData\n\n\ndef process_func_def(\n    func_id: str,\n    node: libcst.FunctionDef,\n    position_data: PositionData,\n    func_builder: FunctionModelBuilder,\n) -> None:\n    \"\"\"\n    Processes a libcst.FunctionDef node to build a function model.\n\n    Extracts various components of a function definition such as its docstring, code content, decorators, and return annotations,\n    and updates the provided FunctionModelBuilder with these details.\n\n    Args:\n        - func_id (str): The unique identifier for the function.\n        - node (libcst.FunctionDef): The function definition node from the CST.\n        - position_data (PositionData): Positional data for the function in the source code.\n        - func_builder (FunctionModelBuilder): The builder used to construct the function model.\n\n    Example:\n        ```Python\n        func_builder = FunctionModelBuilder(id=\"func1\", ...)\n        process_func_def(\"func1\", function_node, position_data, func_builder)\n        # Processes the function definition and updates the function builder.\n        ```\n    \"\"\"\n\n    docstring: str | None = node.get_docstring()\n    code_content: str = common_functions.extract_code_content(node)\n    decorators: list[DecoratorModel] | None = common_functions.extract_decorators(\n        node.decorators\n    )\n\n    returns: str = (\n        _extract_return_annotation(node.returns)\n        if node.returns\n        else \"Function has no return annotation\"\n    )\n    (\n        func_builder.set_docstring(docstring)\n        .set_code_content(code_content)\n        .set_start_line_num(position_data.start)\n        .set_end_line_num(position_data.end)\n    )\n    (\n        func_builder.set_decorators(decorators)\n        .set_is_method(_func_is_method(func_id))\n        .set_is_async(_func_is_async(node))\n        .set_return_annotation(returns)\n    )\n\n\ndef process_parameters(\n    node: libcst.Parameters,\n) -> ParameterListModel | None:\n    \"\"\"\n    Processes libcst.Parameters node to create a ParameterListModel.\n\n    Extracts parameters, keyword-only parameters, positional-only parameters, and special arguments (like *args and **kwargs)\n    from the function definition and forms a model representing these parameters.\n\n    Args:\n        - node (libcst.Parameters): The parameters node from a function definition.\n\n    Returns:\n        - ParameterListModel | None: A model representing the function's parameters, or None if there are no parameters.\n\n    Example:\n        ```Python\n        parameters_model = process_parameters(function_node.params)\n        # Processes the function parameters and returns a parameter model.\n        ```\n    \"\"\"\n\n    params: list[ParameterModel] | None = (\n        _get_parameters_list(node.params) if node.params else []\n    )\n    kwonly_params: list[ParameterModel] | None = (\n        _get_parameters_list(node.kwonly_params) if node.kwonly_params else []\n    )\n    posonly_params: list[ParameterModel] | None = (\n        _get_parameters_list(node.posonly_params) if node.posonly_params else []\n    )\n\n    star_arg: ParameterModel | None = (\n        ParameterModel(\n            content=common_functions.extract_stripped_code_content(node.star_arg)\n        )\n        if node.star_arg and isinstance(node.star_arg, libcst.Param)\n        else None\n    )\n    star_kwarg: ParameterModel | None = (\n        ParameterModel(\n            content=common_functions.extract_stripped_code_content(node.star_kwarg)\n        )\n        if node.star_kwarg\n        else None\n    )\n\n    if params and kwonly_params and posonly_params and star_arg and star_kwarg:\n        return ParameterListModel(\n            params=params,\n            kwonly_params=kwonly_params,\n            posonly_params=posonly_params,\n            star_arg=star_arg,\n            star_kwarg=star_kwarg,\n        )\n\n\ndef _func_is_method(id: str) -> bool:\n    \"\"\"\n    Returns true if an ancestor of the function is a class.\n\n    Args:\n        - id (str): The identifier of the function.\n\n    Returns:\n        - bool: True if the function is a method, False otherwise.\n    \"\"\"\n\n    return str(BlockType.CLASS) in id\n\n\ndef _func_is_async(node: libcst.FunctionDef) -> bool:\n    \"\"\"\n    Returns true if the function is async.\n\n    Args:\n        - node (libcst.FunctionDef): The function definition node.\n\n    Returns:\n        - bool: True if the function is async, False otherwise.\n    \"\"\"\n\n    return True if node.asynchronous else False\n\n\ndef _get_parameters_list(\n    parameter_sequence: Sequence[libcst.Param],\n) -> list[ParameterModel] | None:\n    \"\"\"\n    Returns a list of ParameterModel representing the parameters in a function definition.\n\n    Args:\n        - parameter_sequence (Sequence[libcst.Param]): The sequence of parameters from the function definition.\n\n    Returns:\n        - list[ParameterModel] | None: A list of ParameterModel instances or None if there are no parameters.\n    \"\"\"\n\n    params: list[ParameterModel] | None = None\n\n    if parameter_sequence:\n        params = []\n        for parameter in parameter_sequence:\n            param: ParameterModel = ParameterModel(\n                content=common_functions.extract_stripped_code_content(parameter)\n            )\n            params.append(param)\n\n    return params if params else None\n\n\ndef _extract_return_annotation(\n    node_returns: libcst.Annotation | None,\n) -> str:\n    \"\"\" \"\n    Extracts the return annotation from a function definition.\n\n    Args:\n        - node_returns (libcst.Annotation | None): The return annotation node.\n\n    Returns:\n        - str: The extracted return annotation or \"No return annotation\" if none is found.\n    \"\"\"\n\n    if isinstance(node_returns, libcst.Annotation) and node_returns:\n        annotation: str | None = common_functions.extract_type_annotation(node_returns)\n        return annotation if annotation else \"No return annotation\"\n    else:\n        return \"No return annotation\"\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This code is part of a Python code analysis tool that processes and models Python function definitions using the LibCST library, which provides a concrete syntax tree (CST) for Python code. Its primary purpose is to construct detailed models of function definitions by extracting and organizing components such as docstrings, code content, decorators, return annotations, and parameters. This functionality is significant for applications like documentation generation, code quality analysis, and refactoring tools. Key components include the `process_func_def` function, which builds a function model by extracting details from a `libcst.FunctionDef` node and updating a `FunctionModelBuilder`; the `process_parameters` function, which creates a `ParameterListModel` from a `libcst.Parameters` node; and helper functions like `_func_is_method`, `_func_is_async`, `_get_parameters_list`, and `_extract_return_annotation` for determining method status, async status, parameter extraction, and return annotation extraction, respectively.\n\nThe implementation leverages the LibCST library to parse and traverse the abstract syntax tree (AST) of Python code, employing a builder pattern to incrementally construct function models. It uses data structures such as `DecoratorModel`, `ParameterListModel`, and `ParameterModel` to encapsulate function attributes. The `process_func_def` function extracts the docstring, code content, decorators, and return annotations, updating the `FunctionModelBuilder` with these details. It also determines if the function is a method or asynchronous. The `process_parameters` function handles the extraction of various parameter types, including positional, keyword-only, and special arguments like `*args` and `**kwargs`, returning a `ParameterListModel` that encapsulates these details. The helper functions provide utility operations for extracting specific attributes and determining function characteristics.\n\nThe technical stack includes LibCST for code parsing, which provides a concrete syntax tree representation of Python code, allowing for precise manipulation and analysis. The `fenec` package contributes custom modules such as `FunctionModelBuilder` for constructing function models and `common_functions` for utility operations like extracting code content and type annotations. The `PositionData` class from `fenec.utilities.processing_context` is used to manage positional information of function definitions within the source code.\n\nIn the context of a larger system, this code serves as a component of a Python code analysis tool, interfacing with other modules to provide detailed insights into function definitions. It fits into a broader framework that may include modules for analyzing other code constructs, integrating with systems for documentation generation, and tools for code quality assessment and refactoring. Its modular design allows it to be extended or integrated with other analysis tools, supporting a wide range of applications in software development and maintenance. By providing a detailed and structured representation of function definitions, this code enables other parts of the system to perform more advanced analyses, such as detecting code smells, generating API documentation, or suggesting code improvements. This modular approach allows for easy integration with other tools and systems, making it a valuable component in a software development or maintenance workflow.",
    "children_ids": [
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-process_func_def",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-process_parameters",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_func_is_method",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_func_is_async",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_get_parameters_list",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_extract_return_annotation"
    ]
}