{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging_decorator",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-logging_decorator"
                }
            ],
            "imported_from": "fenec.utilities.logger.decorators",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:logger:decorators.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "StandaloneCodeBlockIDGenerationStrategy",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:id_generation:id_generation_strategies.py__*__MODULE__*__CLASS-StandaloneCodeBlockIDGenerationStrategy"
                }
            ],
            "imported_from": "fenec.python_parser.id_generation.id_generation_strategies",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:id_generation:id_generation_strategies.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BuilderFactory",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:builder_factory.py__*__MODULE__*__CLASS-BuilderFactory"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.builder_factory",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:builder_factory.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "StandaloneBlockModelBuilder",
                    "as_name": null,
                    "local_block_id": "fenec:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE__*__CLASS-StandaloneBlockModelBuilder"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.standalone_block_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "CommentModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-CommentModel"
                },
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "fenec.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "NodeAndPositionData",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:processing_context.py__*__MODULE__*__CLASS-NodeAndPositionData"
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:processing_context.py__*__MODULE"
        }
    ],
    "id": "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE",
    "file_path": "fenec/python_parser/visitors/node_processing/standalone_code_block_functions.py",
    "parent_id": "fenec:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 198,
    "code_content": "from typing import Sequence\nimport libcst\n\nfrom fenec.utilities.logger.decorators import logging_decorator\n\nfrom fenec.python_parser.id_generation.id_generation_strategies import (\n    StandaloneCodeBlockIDGenerationStrategy,\n)\n\nfrom fenec.python_parser.model_builders.builder_factory import BuilderFactory\nfrom fenec.python_parser.model_builders.standalone_block_model_builder import (\n    StandaloneBlockModelBuilder,\n)\nfrom fenec.models.models import CommentModel, BlockType\n\nimport fenec.python_parser.visitors.node_processing.common_functions as common_functions\nfrom fenec.utilities.processing_context import NodeAndPositionData\n\n\ndef gather_standalone_lines(\n    node_body: Sequence[libcst.CSTNode], visitor_instance\n) -> list[NodeAndPositionData]:\n    \"\"\"\n    Gathers standalone lines of code that are not part of class or function definitions or import statements.\n\n    This function iterates over a sequence of libcst.CSTNode, identifying blocks of code that stand alone.\n    Standalone blocks are those not encapsulated in class or function definitions and not part of import statements.\n\n    Args:\n        - node_body (Sequence[libcst.CSTNode]): A sequence of CSTNodes representing the body of a module or a block.\n        - visitor_instance: An instance of a visitor class that provides additional context and utilities.\n\n    Returns:\n        - list[NodeAndPositionData]: A list of NodeAndPositionData, each representing a standalone block of code with its start and end line numbers.\n\n    Example:\n        ```Python\n        visitor_instance = ModuleVisitor(id=\"module1\", ...)\n        standalone_blocks = gather_standalone_lines(module_ast.body, visitor_instance)\n        # This will process the module AST and return standalone blocks of code.\n        ```\n    \"\"\"\n\n    standalone_blocks: list[NodeAndPositionData] = []\n    standalone_block: list[libcst.CSTNode] = []\n    start_line = end_line = 0\n\n    for statement in node_body:\n        if _is_class_or_function_def(statement) or _is_import_statement(statement):\n            if standalone_block:\n                end_line = visitor_instance.get_node_position_data(\n                    standalone_block[-1]\n                ).end\n                standalone_blocks.append(\n                    NodeAndPositionData(standalone_block, start_line, end_line)\n                )\n                standalone_block = []\n                start_line = end_line = 0\n        else:\n            if not standalone_block:\n                start_line = visitor_instance.get_node_position_data(statement).start\n            standalone_block.append(statement)\n\n    if standalone_block:\n        end_line = visitor_instance.get_node_position_data(standalone_block[-1]).end\n        standalone_blocks.append(\n            NodeAndPositionData(standalone_block, start_line, end_line)\n        )\n\n    return standalone_blocks\n\n\ndef process_standalone_blocks(\n    code_blocks: list[NodeAndPositionData], parent_id: str, file_path: str\n) -> list[StandaloneBlockModelBuilder]:\n    \"\"\"\n    Processes standalone blocks of code and builds models for each block.\n\n    Iterates over a list of standalone code blocks, processing each to build a model representing the block.\n    Each block is assigned an identifier and associated with a parent identifier.\n\n    Args:\n        - code_blocks (list[NodeAndPositionData]): A list of NodeAndPositionData representing standalone code blocks.\n        - parent_id (str): The identifier of the parent (usually a module or class).\n        - file_path (str): The file path of the module containing the standalone blocks.\n\n    Returns:\n        - list[StandaloneBlockModelBuilder]: A list of StandaloneBlockModelBuilder, each representing a processed standalone block.\n\n    Example:\n        ```Python\n        standalone_blocks_models = process_standalone_blocks(standalone_blocks, \"module1\")\n        # Processes standalone blocks and creates models for them.\n        ```\n    \"\"\"\n\n    models: list[StandaloneBlockModelBuilder] = []\n    for count, code_block in enumerate(code_blocks):\n        models.append(\n            _process_standalone_block(\n                code_block, parent_id, count + 1, file_path=file_path\n            )\n        )\n\n    return models\n\n\ndef _is_class_or_function_def(statement: libcst.CSTNode) -> bool:\n    \"\"\"Returns True if the statement is a class or function definition.\"\"\"\n\n    return isinstance(statement, (libcst.ClassDef, libcst.FunctionDef))\n\n\ndef _is_import_statement(statement: libcst.CSTNode) -> bool:\n    \"\"\"Returns True if the statement is an import statement.\"\"\"\n\n    return isinstance(statement, libcst.SimpleStatementLine) and any(\n        isinstance(elem, (libcst.Import, libcst.ImportFrom)) for elem in statement.body\n    )\n\n\n# TODO: Fix important comment logic\ndef _process_standalone_block(\n    standalone_block: NodeAndPositionData, parent_id: str, count: int, file_path: str\n) -> StandaloneBlockModelBuilder:\n    \"\"\"Processes a standalone block of code and sets the attributes in the model builder, returns the builder instance.\"\"\"\n\n    id: str = StandaloneCodeBlockIDGenerationStrategy.generate_id(parent_id, count)\n    builder: StandaloneBlockModelBuilder = BuilderFactory.create_builder_instance(\n        block_type=BlockType.STANDALONE_CODE_BLOCK,\n        id=id,\n        parent_id=parent_id,\n        file_path=file_path,\n    )\n    content, variable_assignments, important_comments = _process_nodes(standalone_block)\n    (\n        builder.set_start_line_num(standalone_block.start)\n        .set_end_line_num(standalone_block.end)\n        .set_code_content(content)\n    )\n    for important_comment in important_comments:\n        builder.add_important_comment(important_comment)\n    builder.set_variable_assignments(variable_assignments)\n\n    return builder\n\n\n@logging_decorator(syntax_highlighting=True)\ndef _process_nodes(\n    standalone_block: NodeAndPositionData,\n) -> tuple[str, list[str], list[CommentModel]]:\n    \"\"\"Processes the nodes in a standalone block of code and returns the content, variable assignments and important comments.\"\"\"\n\n    content: str = \"\"\n    variable_assignments: list[str] = []\n    important_comments: list[CommentModel] = []\n\n    for line in standalone_block.nodes:\n        if isinstance(line, libcst.SimpleStatementLine):\n            variable_assignments.extend(_extract_variable_assignments(line))\n\n        important_comments.extend(_process_leading_lines(line))\n        line_content: str = common_functions.extract_stripped_code_content(line)\n        content += line_content + \"\\n\"\n\n    return content, variable_assignments, important_comments\n\n\ndef _process_leading_lines(line: libcst.CSTNode) -> list[CommentModel]:\n    \"\"\"Processes the leading lines of a node and returns the important comments.\"\"\"\n\n    important_comments: list[CommentModel] = []\n\n    if isinstance(line, libcst.SimpleStatementLine):\n        for leading_line in line.leading_lines:\n            important_comment: CommentModel | None = (\n                common_functions.extract_important_comment(leading_line)\n            )\n            if important_comment:\n                important_comments.append(important_comment)\n\n    return important_comments\n\n\ndef _extract_variable_assignments(\n    node: libcst.SimpleStatementLine,\n) -> list[str]:\n    \"\"\"Extracts variable assignments from a SimpleStatementLine node.\"\"\"\n\n    variable_assignments: list[str] = []\n    for stmt in node.body:\n        if isinstance(stmt, (libcst.AnnAssign, libcst.Assign)):\n            variable_assignments.append(\n                common_functions.extract_stripped_code_content(stmt)\n            )\n\n    return variable_assignments\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This Python code is part of a sophisticated system designed to parse, analyze, and model standalone blocks of code within a Python module, specifically targeting those not encapsulated in class or function definitions or import statements. Its primary purpose is to identify these blocks, extract relevant information, and construct models representing each block for further analysis or processing, which is crucial for static code analysis, refactoring tools, or code quality assessment frameworks. Key components include the `gather_standalone_lines` function, which identifies standalone code blocks by iterating over a sequence of `libcst.CSTNode` objects and checking if they are not part of class or function definitions or import statements; the `process_standalone_blocks` function, which builds models for each identified block using a factory method to instantiate model builders; and several helper functions such as `_is_class_or_function_def`, `_is_import_statement`, `_process_standalone_block`, `_process_nodes`, `_process_leading_lines`, and `_extract_variable_assignments` that facilitate the identification and processing of code blocks.\n\nThe implementation leverages the `libcst` library to parse and traverse the abstract syntax tree (AST) of Python code, using data structures like `NodeAndPositionData` to store information about code blocks, including their start and end line numbers. The design pattern involves a factory method (`BuilderFactory.create_builder_instance`) to instantiate model builders, and a strategy pattern (`StandaloneCodeBlockIDGenerationStrategy`) for generating unique identifiers for each block. The `_process_standalone_block` function processes each standalone block by generating a unique ID, setting attributes in the model builder, and extracting content, variable assignments, and important comments using the `_process_nodes` function. The `_process_nodes` function further processes each node in a block to extract stripped code content, variable assignments, and important comments, utilizing common functions from the `fenec` package.\n\nThe technical stack includes `libcst` for code parsing, which provides a concrete syntax tree for Python code, allowing precise manipulation and analysis of code structure. The `fenec` package is used extensively, providing utilities for logging, ID generation, and model building, as well as common functions for node processing. The `logging_decorator` from `fenec.utilities.logger.decorators` is used to enhance logging with syntax highlighting, aiding in debugging and analysis.\n\nIn the context of a larger project, this code is part of a Python parser module that interacts with other components like visitors and model builders to provide a comprehensive analysis of Python code. It fits into a system that requires detailed understanding and manipulation of code structure, such as in static analysis tools, refactoring utilities, or code quality assessment frameworks. By focusing on standalone code blocks, this module complements other components that may handle class and function definitions, providing a holistic view of the codebase. This modular design allows the system to be easily extended or modified, accommodating new types of code blocks or analysis techniques as needed, making it a versatile tool in the realm of code analysis and transformation.",
    "children_ids": [
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-gather_standalone_lines",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-process_standalone_blocks",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_class_or_function_def",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_import_statement",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_standalone_block",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_nodes",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_leading_lines",
        "fenec:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_extract_variable_assignments"
    ]
}