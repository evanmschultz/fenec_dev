{
    "class_name": "ClassSpecificAttributes",
    "decorators": null,
    "bases": [
        "BaseModel"
    ],
    "docstring": "Class specific attributes.",
    "keywords": null,
    "id": "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models:models.py__*__MODULE",
    "block_type": "CLASS",
    "start_line_num": 710,
    "end_line_num": 816,
    "code_content": "\n\nclass ClassSpecificAttributes(BaseModel):\n    \"\"\"Class specific attributes.\"\"\"\n\n    class_name: str = Field(min_length=1)\n    decorators: list[DecoratorModel] | None = None\n    bases: list[str] | None = None\n    docstring: str | None = None\n    keywords: list[ClassKeywordModel] | None = None\n    # attributes: list[dict] | None = None\n\n    def _convert_decorators_to_metadata(self) -> str:\n        \"\"\"Converts the decorators to a metadata string.\"\"\"\n        decorators_str: str = self.model_dump_json() if self.decorators else \"\"\n        return f\"{decorators_str}\"\n\n    def _convert_bases_to_metadata(self) -> str:\n        \"\"\"Converts the bases to a metadata string.\"\"\"\n        return self.model_dump_json() if self.bases else \"\"\n\n    def _convert_docstring_to_metadata(self) -> str:\n        \"\"\"Converts the docstring to a metadata string.\"\"\"\n        return f\"{self.docstring}\" if self.docstring else \"\"\n\n    def _convert_keywords_to_metadata(self) -> str:\n        \"\"\"Converts the keywords to a metadata string.\"\"\"\n        keywords_str: str = self.model_dump_json() if self.keywords else \"\"\n        return f\"{keywords_str}\"\n\n    def _convert_class_attributes_to_metadata_dict(self) -> dict[str, str | int]:\n        \"\"\"Converts the class attributes to a metadata dictionary.\"\"\"\n\n        return {\n            \"class_name\": self.class_name,\n            \"decorators\": self._convert_decorators_to_metadata(),\n            \"bases\": self._convert_bases_to_metadata(),\n            \"docstring\": self._convert_docstring_to_metadata(),\n            \"keywords\": self._convert_keywords_to_metadata(),\n        }\n\n    @classmethod\n    def _build_from_meta(\n        cls, metadata: dict[str, str | int | list[str]]\n    ) -> \"ClassSpecificAttributes\":\n        \"\"\"Builds a ClassSpecificAttributes from a metadata dictionary.\"\"\"\n\n        try:\n            if not isinstance(metadata, dict):\n                raise ValueError(\"Metadata must be a dictionary.\")\n\n            class_name = metadata.get(\"class_name\")\n            if not isinstance(class_name, str):\n                raise ValueError(\"Class name must be a string.\")\n\n            decorators_data = metadata.get(\"decorators\", [])\n            if not isinstance(decorators_data, list):\n                raise ValueError(\"Decorators must be a list.\")\n\n            decorators: list[DecoratorModel] = []\n            for decorator_data in decorators_data:\n                if not isinstance(decorator_data, dict):\n                    raise ValueError(\"Each decorator must be a dictionary.\")\n                decorator: DecoratorModel = DecoratorModel._build_from_metadata(\n                    decorator_data\n                )\n                decorators.append(decorator)\n\n            bases = metadata.get(\"bases\", [])\n            if not isinstance(bases, list) or all(\n                isinstance(base, str) for base in bases\n            ):\n                raise ValueError(\"Bases must be a list.\")\n\n            docstring = metadata.get(\"docstring\")\n            if not isinstance(docstring, str):\n                raise ValueError(\"Docstring must be a string.\")\n\n            keywords_data = metadata.get(\"keywords\", [])\n            if not isinstance(keywords_data, list) or all(\n                isinstance(keyword, dict) for keyword in keywords_data\n            ):\n                raise ValueError(\"Keywords must be a list.\")\n\n            keywords: list[ClassKeywordModel] = []\n            for keyword_data in keywords_data:\n                if not isinstance(keyword_data, dict):\n                    raise ValueError(\"Each keyword must be a dictionary.\")\n                keyword: ClassKeywordModel = ClassKeywordModel._build_from_metadata(\n                    keyword_data\n                )\n                keywords.append(keyword)\n\n            return cls(\n                class_name=class_name,\n                decorators=decorators,\n                bases=bases,\n                docstring=docstring,\n                keywords=keywords,\n            )\n        except ValueError as ve:\n            logging.error(f\"Error building from metadata: {ve}\")\n            raise ve\n        except Exception as e:\n            logging.error(f\"An unexpected error occurred: {e}\")\n            raise e\n",
    "important_comments": null,
    "dependencies": [
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
        },
        {
            "code_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ClassKeywordModel"
        },
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Field",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "field_validator",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        }
    ],
    "summary": "The code defines a Python class `ClassSpecificAttributes`, which is designed to encapsulate and manage metadata for a Python class, focusing on attributes such as class name, decorators, base classes, docstring, and keywords. Its primary purpose is to facilitate the conversion of these attributes into a structured metadata dictionary and to reconstruct the class attributes from such metadata, which is crucial for tasks like code analysis, documentation generation, or ORM system integration. Key components include: the `ClassSpecificAttributes` class itself, which inherits from `BaseModel` to leverage Pydantic's data validation capabilities; methods like `_convert_decorators_to_metadata`, `_convert_bases_to_metadata`, `_convert_docstring_to_metadata`, and `_convert_keywords_to_metadata` for converting respective attributes to metadata strings; `_convert_class_attributes_to_metadata_dict` for aggregating these into a dictionary; and `_build_from_meta`, a class method for instantiating `ClassSpecificAttributes` from a metadata dictionary, ensuring type safety and data integrity through extensive validation checks.\n\nThe implementation employs a robust data validation and conversion approach, utilizing Python's type hinting and exception handling to ensure that metadata is correctly structured and type-checked. The class methods systematically convert class attributes into metadata strings or dictionaries, with `_convert_class_attributes_to_metadata_dict` serving as a central aggregator. The `_build_from_meta` method is particularly noteworthy for its detailed validation logic, which checks the types and structures of metadata components before reconstructing the `ClassSpecificAttributes` instance. This method also demonstrates the use of custom models like `DecoratorModel` and `ClassKeywordModel`, which likely encapsulate specific metadata structures for decorators and keywords, respectively.\n\nThe technical stack prominently features Python's standard library and Pydantic, inferred from the inheritance of `BaseModel`, which is used for data validation and settings management. Pydantic provides a robust framework for defining and validating data models, ensuring that the metadata conforms to expected formats and types. This code fits into a larger system as part of a code analysis or generation tool, interacting with other components that manage or utilize class metadata. It could be integrated with code parsers, documentation generators, or ORM systems, providing a structured representation of Python class metadata that supports extensibility and integration with systems requiring detailed class attribute information. The design of `ClassSpecificAttributes` supports modularity and reusability, making it a valuable component in systems that need to handle class metadata in a consistent and validated manner.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_convert_decorators_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_convert_bases_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_convert_docstring_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_convert_keywords_to_metadata",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_convert_class_attributes_to_metadata_dict",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes__*__FUNCTION-_build_from_meta"
    ]
}