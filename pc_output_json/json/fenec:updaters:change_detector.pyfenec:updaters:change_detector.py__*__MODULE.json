{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "ArangoDBManager",
                    "as_name": null,
                    "local_block_id": "fenec:databases:arangodb:arangodb_manager.py__*__MODULE__*__CLASS-ArangoDBManager"
                }
            ],
            "imported_from": "fenec.databases.arangodb.arangodb_manager",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:databases:arangodb:arangodb_manager.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModuleModel",
                    "as_name": null,
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ModuleModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModelType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "fenec.types.fenec",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:types:fenec.py__*__MODULE"
        }
    ],
    "id": "fenec:updaters:change_detector.py__*__MODULE",
    "file_path": "fenec/updaters/change_detector.py",
    "parent_id": "fenec:updaters__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 49,
    "code_content": "from fenec.databases.arangodb.arangodb_manager import ArangoDBManager\nfrom fenec.models.models import ModuleModel\nfrom fenec.types.fenec import ModelType\n\n\nclass ChangeDetector:\n    def __init__(\n        self, all_models: tuple[ModelType, ...], arangodb_manager: ArangoDBManager\n    ) -> None:\n        self.all_models: tuple[ModelType, ...] = all_models\n        self.id_to_model: dict[str, ModelType] = {\n            model.id: model for model in all_models\n        }\n        self.arangodb_manager: ArangoDBManager = arangodb_manager\n\n    def get_affected_models(\n        self, changed_files: list[str], both_directions: bool = False\n    ) -> set[str]:\n        affected_models = set()\n\n        for model in self.all_models:\n            if isinstance(model, ModuleModel) and model.file_path in changed_files:\n                affected_models.add(model.id)\n                affected_models.update(\n                    self._get_connected_models(model.id, both_directions)\n                )\n\n        return affected_models\n\n    def _get_connected_models(self, model_id: str, both_directions: bool) -> set[str]:\n        connected_models = set()\n\n        # Get outbound models (dependencies and children)\n        outbound_models: list[ModelType] | None = (\n            self.arangodb_manager.get_outbound_models(model_id)\n        )\n        if outbound_models:\n            connected_models.update(model.id for model in outbound_models)\n\n        if both_directions:\n            # Get inbound models (dependents and parents)\n            inbound_models: list[ModelType] | None = (\n                self.arangodb_manager.get_inbound_models(model_id)\n            )\n            if inbound_models:\n                connected_models.update(model.id for model in inbound_models)\n\n        return connected_models\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "The code implements a sophisticated change detection mechanism within a system that manages model dependencies and relationships, leveraging an ArangoDB database to track these connections. Its primary purpose is to efficiently identify models affected by changes in specific files, ensuring the integrity and consistency of the system's model architecture. This is crucial in environments where model dependencies are complex, and changes must be accurately propagated to maintain system coherence. Key components include the `ChangeDetector` class, which encapsulates the core logic for detecting affected models; the `get_affected_models` method, which iterates over all models to determine which are impacted by changes in a specified list of files, utilizing set operations to efficiently manage collections of affected models; and the `_get_connected_models` method, which retrieves models connected to a given model ID, considering both outbound (dependencies and children) and inbound (dependents and parents) relationships based on the `both_directions` flag.\n\nThe implementation employs a dictionary to map model IDs to their respective model instances, facilitating quick access and manipulation. The `get_affected_models` method checks if a model is an instance of `ModuleModel` and if its file path is among the changed files, adding it to the set of affected models and further expanding this set by including connected models through the `_get_connected_models` method. This method interacts with the `ArangoDBManager` to fetch outbound and inbound model relationships, which are crucial for understanding and managing model dependencies within the database. The use of a set data structure ensures that each model is processed only once, optimizing performance in large systems.\n\nThe technical stack includes the `fenec` library, which provides essential components such as the `ArangoDBManager` for database operations, enabling efficient retrieval of model relationships, and the `ModuleModel` class for representing models. The `ModelType` from `fenec.types.fenec` is used to define the types of models handled by the system. This code is part of a larger module responsible for updating and maintaining model consistency in response to file changes, ensuring that all dependencies and relationships are accurately reflected in the database. It interacts with the database layer to support the system's overall integrity and responsiveness to changes, playing a critical role in the system's ability to adapt to modifications and maintain a coherent model structure. This change detection mechanism is integral to the system's ability to dynamically update and manage model dependencies, ensuring that any modifications are accurately reflected across the entire model architecture.",
    "children_ids": [
        "fenec:updaters:change_detector.py__*__MODULE__*__CLASS-ChangeDetector"
    ]
}