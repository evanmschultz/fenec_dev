{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "typer",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Annotated",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Literal",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Optional",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Any",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Path",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "pathlib",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "print",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "rich",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Fenec",
                    "as_name": null,
                    "local_block_id": "fenec:api.py__*__MODULE__*__CLASS-Fenec"
                }
            ],
            "imported_from": "fenec",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:api.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "GraphDBUpdater",
                    "as_name": null,
                    "local_block_id": "fenec:updaters:graph_db_updater.py__*__MODULE__*__CLASS-GraphDBUpdater"
                }
            ],
            "imported_from": "fenec.updaters.graph_db_updater",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:updaters:graph_db_updater.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "setup_logging",
                    "as_name": null,
                    "local_block_id": "fenec:utilities:logger:logging_config.py__*__MODULE__*__FUNCTION-setup_logging"
                }
            ],
            "imported_from": "fenec.utilities.logger.logging_config",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:logger:logging_config.py__*__MODULE"
        }
    ],
    "id": "fenec:cli_app.py__*__MODULE",
    "file_path": "fenec/cli_app.py",
    "parent_id": "fenec__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 159,
    "code_content": "import logging\nimport typer\nfrom typing import Annotated, Literal, Optional, Any\nfrom pathlib import Path\nfrom fenec import Fenec\nfrom fenec.updaters.graph_db_updater import GraphDBUpdater\nfrom rich import print\nfrom fenec.utilities.logger.logging_config import setup_logging\n\napp = typer.Typer()\n\nfenec_instance: Optional[Fenec] = None\n\n\ndef process_codebase(\n    fenec_instance: Fenec,\n    num_of_passes: int = 1,\n    process_all: bool = False,\n) -> None:\n    \"\"\"\n    Process the codebase at the given path.\n    \"\"\"\n    try:\n        fenec_instance.process_codebase(num_of_passes, process_all)\n        typer.echo(\"Codebase processing complete.\")\n    except Exception as e:\n        logging.exception(\"Error processing codebase\")\n        typer.echo(f\"Error processing codebase: {e}\")\n        raise typer.Exit(1)\n\n\ndef connect_to_vectorstore(fenec_instance: Fenec) -> None:\n    \"\"\"\n    Connect to an existing vectorstore.\n    \"\"\"\n    try:\n        fenec_instance.connect_to_vectorstore()\n        typer.echo(\"Connected to existing vectorstore.\")\n    except Exception as e:\n        logging.exception(\"Error connecting to vectorstore\")\n        typer.echo(f\"Error connecting to vectorstore: {e}\")\n        raise typer.Exit(1)\n\n\ndef chat_loop() -> None:\n    \"\"\"\n    Start a chat session with Fenec.\n    \"\"\"\n    if not fenec_instance:\n        typer.echo(\n            \"Error: Codebase has not been processed. Please process the codebase first.\"\n        )\n        raise typer.Exit(1)\n\n    print(\n        \"[blue]Chat[/blue] session started. Type [magenta]'exit'[/magenta] to end the chat.\"\n    )\n    while True:\n        user_input = typer.prompt(\"You\")\n        if user_input.lower() == \"exit\":\n            break\n        try:\n            response = fenec_instance.chat(user_input)\n            typer.echo(f\"AI: {response}\")\n        except Exception as e:\n            logging.exception(\"Error during chat\")\n            typer.echo(f\"Error during chat: {e}\")\n            break\n\n\ndef get_path_from_option(option_value: Any) -> Path:\n    if hasattr(option_value, \"default\"):\n        # If it's an OptionInfo object, use its default value\n        path_str = str(option_value.default)\n    else:\n        # Otherwise, assume it's already a string\n        path_str = str(option_value)\n\n    path: Path = Path(path_str).resolve()\n    if not path.exists():\n        raise typer.BadParameter(f\"The path '{path}' does not exist.\")\n    return path\n\n\n@app.command()\ndef main(\n    path: Annotated[\n        str, typer.Argument(help=\"The path to the directory containing the codebase\")\n    ] = \".\",\n    update: Annotated[\n        bool,\n        typer.Option(\n            help=\"Whether to update the summaries and databases with the code that has changed since the last git commit\"\n        ),\n    ] = False,\n    update_all: Annotated[\n        bool,\n        typer.Option(\n            help=\"Whether to update the summaries and databases for the whole project, `update` must be False\"\n        ),\n    ] = False,\n    chat: Annotated[\n        bool,\n        typer.Option(\n            help=\"Whether to start a chat session with Fenec, if updating it will run after processing the codebase\"\n        ),\n    ] = True,\n    passes: Annotated[\n        int,\n        typer.Argument(\n            help=\"The number of passes the summarizer will take, 1 is bottom-up, 3 is bottom-up, top-down, then bottom-up again\"\n        ),\n    ] = 1,\n) -> None:\n    \"\"\"\n    Process the codebase and start a chat session with Fenec.\n    \"\"\"\n    setup_logging()\n\n    try:\n        resolved_path: Path = Path(path).resolve()\n\n        if passes not in {1, 3}:\n            raise typer.BadParameter(\"Number of passes must be 1 or 3\")\n\n        global fenec_instance\n        fenec_instance = Fenec(path=resolved_path)\n\n        if update:\n            print(\n                f\"[bold blue]FENEC[/bold blue]\\n\\nProcessing updated codebase at path: '{resolved_path}'\"\n            )\n            process_codebase(fenec_instance, passes, False)\n        elif update_all:\n            print(\n                f\"[bold blue]FENEC[/bold blue]\\n\\nProcessing the entire codebase at path: '{resolved_path}'\"\n            )\n            process_codebase(fenec_instance, passes, True)\n        else:\n            print(\"[blue]FENEC[/blue]\\n\\nConnecting to existing vectorstore\")\n            connect_to_vectorstore(fenec_instance)\n        if chat:\n            chat_loop()\n    except typer.BadParameter as e:\n        logging.error(f\"Invalid parameter: {e}\")\n        typer.echo(str(e))\n        raise typer.Exit(1)\n    except typer.Exit:\n        logging.error(\"Codebase processing failed\")\n        raise\n    except Exception as e:\n        logging.exception(\"An unexpected error occurred\")\n        typer.echo(f\"An unexpected error occurred: {e}\")\n        raise typer.Exit(1)\n\n\nif __name__ == \"__main__\":\n    app()\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "This Python script serves as a command-line interface (CLI) application designed to streamline codebase analysis and interaction with a vector store using the Fenec library. Its primary purpose is to process a codebase, update summaries and databases, and initiate a chat session with the Fenec system, thereby enabling efficient codebase analysis and integration with vector stores. The application is built using the Typer library, which simplifies the creation of CLI applications by leveraging Python's type hints and decorators, providing a user-friendly interface for specifying paths, update options, and initiating chat sessions.\n\nKey components of the script include: the `process_codebase` function, which processes the codebase with a specified number of passes and handles exceptions to ensure robust execution; the `connect_to_vectorstore` function, which establishes a connection to an existing vector store, crucial for data retrieval and storage operations; the `chat_loop` function, which initiates and manages an interactive chat session with Fenec, providing a user-friendly interface for real-time interaction; the `get_path_from_option` function, which resolves and validates file paths from user input, ensuring correct path handling; and the `main` function, which orchestrates the overall process flow based on user inputs, managing the sequence of operations from path resolution to codebase processing and chat initiation.\n\nThe implementation leverages Typer for defining CLI commands and options, allowing users to specify paths, update options, and initiate chat sessions with ease. The script uses a global `fenec_instance` to manage the state and operations of the Fenec object, which is responsible for processing the codebase and connecting to the vector store. The `process_codebase` function utilizes a try-except block to handle potential exceptions, ensuring that the application exits gracefully in case of errors. The `main` function employs conditional logic to determine whether to update the codebase or connect to the vector store, and it uses the `setup_logging` function from Fenec's utilities to configure logging, providing detailed feedback and error handling throughout the application's execution.\n\nThe technical stack includes Typer for CLI management, which simplifies the creation of command-line interfaces with automatic help messages and argument parsing; Fenec for codebase processing and vector store interactions, which provides the core functionality for analyzing and managing codebases; and Rich for enhanced terminal output, which improves the user experience with styled text and formatted messages. Logging is configured using a custom setup to handle errors and provide feedback, ensuring that users are informed of the application's status and any issues that arise.\n\nIn the context of a larger system, this script acts as an interface for developers to interact with the Fenec library, enabling efficient codebase analysis and integration with vector stores. It supports modular updates and interactive sessions, fitting into a workflow that requires dynamic code analysis and data management. The script's design allows it to be integrated into larger development environments, where it can facilitate continuous integration and deployment processes by providing insights into code changes and maintaining up-to-date summaries and databases. Its modular architecture and use of a global Fenec instance make it adaptable to various project requirements, supporting both incremental updates and comprehensive project analyses.",
    "children_ids": [
        "fenec:cli_app.py__*__MODULE__*__STANDALONE_BLOCK-1",
        "fenec:cli_app.py__*__MODULE__*__STANDALONE_BLOCK-2",
        "fenec:cli_app.py__*__MODULE__*__FUNCTION-process_codebase",
        "fenec:cli_app.py__*__MODULE__*__FUNCTION-connect_to_vectorstore",
        "fenec:cli_app.py__*__MODULE__*__FUNCTION-chat_loop",
        "fenec:cli_app.py__*__MODULE__*__FUNCTION-get_path_from_option",
        "fenec:cli_app.py__*__MODULE__*__FUNCTION-main"
    ]
}