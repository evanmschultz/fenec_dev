{
    "file_path": "postcode/databases/chroma/chromadb_collection_manager.py",
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Any",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Mapping",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "postcode.types.chroma",
                    "as_name": "chroma_types",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:types:chroma.py__*__MODULE"
        }
    ],
    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE",
    "parent_id": null,
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 431,
    "code_content": "import logging\nfrom typing import Any, Mapping\n\nimport postcode.types.chroma as chroma_types\n\n\nclass ChromaDBCollectionManager:\n    \"\"\"\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\n    and querying embeddings, and their associated metadata.\n\n    This class serves as an interface to interact with a specific collection in ChromaDB.\n\n    Attributes:\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\n            which this manager is responsible for.\n\n    Methods:\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\n        - `add_embeddings`: Adds embeddings to the collection.\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder\n        import postcode.types.chromadb.types as chroma_types\n\n        # Create a persistent ChromaDB client\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Instantiate the ChromaDBCollectionManager with a specific collection\n        collection_manager: ChromaDBCollectionManager = (\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\n        )\n\n        # Example usage of the collection manager\n        embedding_count: int = collection_manager.collection_embedding_count()\n        print(f\"Total embeddings: {embedding_count}\")\n        ```\n    \"\"\"\n\n    def __init__(self, collection: chroma_types.Collection) -> None:\n        self.collection: chroma_types.Collection = collection\n\n    def collection_embedding_count(self) -> int:\n        \"\"\"\n        Gets the total number of embeddings in the collection.\n\n        Returns:\n            - embedding_count (int): The total number of embeddings in the collection.\n\n        Examples:\n            ```Python\n            embedding_count: int = collection_manager.get_collection_embedding_count()\n            ```\n        \"\"\"\n\n        embedding_count: int = self.collection.count()\n        logging.info(\n            f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\n        )\n\n        return embedding_count\n\n    def add_embeddings(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n    ) -> None:\n        \"\"\"\n        Adds embeddings to the collection.\n\n        Args:\n            - ids (list[str]): A list of ids to add to the collection.\n            - documents (list[str]): A list of documents to add to the collection.\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\n        Raises:\n            - ValueError - If you don't provide either embeddings or documents.\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError - If you provide an id that already exists.\n\n        Examples:\n            ```Python\n            # define the ids, metadatas, and documents to add to the collection\n            id: list[str] = [\"my_id\", \"my_id2\"]\n            metadatas: list[dict[str, Any]] = [\n                {\"my_metadata\": \"my_metadata_value\"},\n                {\"my_metadata2\": \"my_metadata_value2\"},\n            ]\n            documents: list[str] = [\"my_document\", \"my_document2\"]\n\n            # add the embeddings to the collection\n            collection_manager.add_embeddings(id, metadatas, documents)\n            ```\n        \"\"\"\n\n        if not len(ids) == len(documents) == len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        try:\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\n        except Exception as exception:\n            raise exception\n\n    def get_embeddings(\n        self,\n        ids: list[str] | None,\n        *,\n        where_filter: chroma_types.Where | None = None,\n        limit: int | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.GetResult | None:\n        \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n            return self.collection.get(\n                ids,\n                where=where_filter,\n                limit=limit,\n                where_document=where_document_filter,\n                include=include_in_result,\n            )\n        except Exception as exception:\n            raise exception\n\n    def query_collection(\n        self,\n        queries: list[str],\n        n_results: int = 10,\n        where_filter: chroma_types.Where | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.QueryResult | None:\n        \"\"\"\n        Queries and returns the `n` nearest neighbors from the collection.\n\n        Args:\n            - queries (list[str]): A list of queries to search the collection for.\n            - n_results (int): The number of results to return.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                - e.g. `{$contains: \"binary search\"}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n                `include_in_result` parameter:\n                - ids: list[str] # The ids are always returned.\n                - embeddings: List[list[Embedding]] | None\n                - documents: list[list[str]]] | None\n                - uris: list[list[URI]]] | None\n                - data: list[Loadable] | None\n                - metadatas: list[list[Metadata]] | None\n                - distances: list[list[float]] | None\n\n        Raises:\n            - ValueError: If you don't provide query_texts.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma\n\n            # define the queries and filters used to search the collection\n            queries: list[str] = [\"binary search\", \"linear search\"]\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n            # query the collection and return the results from the collection\n            results: chroma_types.QueryResult = collection_manager.query_collection(\n                queries,\n                where_filter=where_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Querying collection {self.collection.name}\")\n\n            if results := self.collection.query(\n                query_texts=queries,\n                n_results=n_results,\n                where=where_filter,\n                where_document=where_document_filter,\n                include=include_in_result,\n            ):\n                logging.info(\n                    f\"Got {len(results)} results from collection {self.collection.name}.\"\n                )\n                return results\n            else:\n                logging.warning(\n                    f\"No results found from collection {self.collection.name}.\"\n                )\n\n        except Exception as exception:\n            raise exception\n\n    def modify_collection_name(self, name: str) -> None:\n        \"\"\"\n        Modifies the name of the collection managed by this class.\n\n        Args:\n            - name (str): The new name to assign to the collection.\n\n        Examples:\n            ```Python\n            # Rename the collection to 'new_collection_name'\n            collection_manager.modify_collection_name('new_collection_name')\n            ```\n        \"\"\"\n\n        self.collection.modify(name=name)\n\n    def modify_collection_metadata(\n        self, metadata: dict[str, Any] | None = None\n    ) -> None:\n        \"\"\"\n        Modifies the metadata of the collection managed by this class.\n\n        Args:\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\n        Examples:\n            ```Python\n            # Update metadata of the collection\n            new_metadata = {\"description\": \"Updated collection metadata\"}\n            collection_manager.modify_collection_metadata(new_metadata)\n            ```\n        \"\"\"\n\n        self.collection.modify(metadata=metadata)\n\n    def update_metadata_or_documents_by_ids(\n        self,\n        ids: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\n        documents: list[str] | None = None,\n    ) -> None:\n        \"\"\"\n        Updates the metadata or documents of specific entries in the collection by their ids.\n\n        Args:\n            - ids (list[str]): List of ids of the entries to be updated.\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n            - documents (list[str] | None): List of document updates corresponding to the ids.\n\n        Raises:\n            - ValueError: If neither metadatas nor documents are provided.\n            - ValueError: If the length of ids and documents don't match.\n            - ValueError: If the length of ids and metadatas don't match.\n            - ValueError: If the length of ids, metadatas, and documents don't match.\n\n        Notes:\n            - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            # Update metadata and documents for specific ids\n            ids_to_update = ['id1', 'id2']\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n            document_updates = [\"new document 1\", \"new document 2\"]\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n            ```\n        \"\"\"\n\n        if not metadatas and not documents:\n            raise ValueError(\"You must provide either metadatas or documents.\")\n        if not metadatas and documents:\n            if len(ids) != len(documents):\n                raise ValueError(\"The length of ids and documents must match.\")\n        if metadatas and not documents:\n            if len(ids) != len(metadatas):\n                raise ValueError(\"The length of ids and metadatas must match.\")\n        if metadatas and documents:\n            if len(ids) != len(metadatas) != len(documents):\n                raise ValueError(\n                    \"The length of ids, metadatas, and documents must match.\"\n                )\n        for index, id in enumerate(ids):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids.pop(index)\n                if metadatas:\n                    popped_metadata = metadatas.pop(index)\n                    if popped_metadata:\n                        logging.warning(\n                            f\"Removing metadata at index {index} from update.\"\n                        )\n                if documents:\n                    popped_document = documents.pop(index)\n                    if popped_document:\n                        logging.warning(\n                            f\"Removing document at index {index} from update.\"\n                        )\n\n        if not ids:\n            logging.warning(\"All updates failed.\")\n            return None\n        else:\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\n\n    def upsert_documents(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n        # embeddings: list[chroma_types.Embedding],\n    ) -> None:\n        \"\"\"\n        Inserts or updates documents in the collection, based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\n            - documents (list[str]): List of documents corresponding to the ids.\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\n        Raises:\n            - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\n        Examples:\n            ```Python\n            # Upsert documents in the collection\n            ids = ['id1', 'id2']\n            documents = ['doc1', 'doc2']\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n            # Upsert documents in the collection\n            collection_manager.upsert_documents(ids, documents, metadatas)\n            ```\n        \"\"\"\n\n        if len(ids) != len(documents) != len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\n        self.collection.upsert(\n            ids=ids,\n            # embeddings=embeddings,\n            metadatas=metadatas,\n            documents=documents,\n        )\n\n    def delete_embeddings(self, ids: list[str]) -> None:\n        \"\"\"\n        Deletes embeddings from the collection based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\n        Examples:\n            ```Python\n            # Delete specific embeddings by ids\n            ids_to_delete = ['id1', 'id2']\n            collection_manager.delete_embeddings(ids_to_delete)\n            ```\n        \"\"\"\n\n        ids_to_delete: list[str] = ids.copy()\n        for index, id in enumerate(ids_to_delete):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids_to_delete.pop(index)\n\n        if not ids_to_delete:\n            logging.warning(\"No IDs given were in the database.\")\n            return None\n\n        logging.info(\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\n        )\n        self.collection.delete(ids_to_delete)\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\nimport logging\\nfrom typing import Any, Mapping\\n\\nimport postcode.types.chroma as chroma_types\\n\\n\\nclass ChromaDBCollectionManager:\\n    \"\"\"\\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\\n    and querying embeddings, and their associated metadata.\\n\\n    This class serves as an interface to interact with a specific collection in ChromaDB.\\n\\n    Attributes:\\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\\n            which this manager is responsible for.\\n\\n    Methods:\\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\\n        - `add_embeddings`: Adds embeddings to the collection.\\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\\n\\n    Examples:\\n        ```Python\\n        from postcode.databases.chroma import ChromaDBClientBuilder\\n        import postcode.types.chromadb.types as chroma_types\\n\\n        # Create a persistent ChromaDB client\\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\n\\n        # Instantiate the ChromaDBCollectionManager with a specific collection\\n        collection_manager: ChromaDBCollectionManager = (\\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\\n        )\\n\\n        # Example usage of the collection manager\\n        embedding_count: int = collection_manager.collection_embedding_count()\\n        print(f\"Total embeddings: {embedding_count}\")\\n        ```\\n    \"\"\"\\n\\n    def __init__(self, collection: chroma_types.Collection) -> None:\\n        self.collection: chroma_types.Collection = collection\\n\\n    def collection_embedding_count(self) -> int:\\n        \"\"\"\\n        Gets the total number of embeddings in the collection.\\n\\n        Returns:\\n            - embedding_count (int): The total number of embeddings in the collection.\\n\\n        Examples:\\n            ```Python\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\n            ```\\n        \"\"\"\\n\\n        embedding_count: int = self.collection.count()\\n        logging.info(\\n            f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\n        )\\n\\n        return embedding_count\\n\\n    def add_embeddings(\\n        self,\\n        ids: list[str],\\n        documents: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\n    ) -> None:\\n        \"\"\"\\n        Adds embeddings to the collection.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to add to the collection.\\n            - documents (list[str]): A list of documents to add to the collection.\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\n\\n        Raises:\\n            - ValueError - If you don\\'t provide either embeddings or documents.\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError - If you provide an id that already exists.\\n\\n        Examples:\\n            ```Python\\n            # define the ids, metadatas, and documents to add to the collection\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\n            metadatas: list[dict[str, Any]] = [\\n                {\"my_metadata\": \"my_metadata_value\"},\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\n            ]\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\n\\n            # add the embeddings to the collection\\n            collection_manager.add_embeddings(id, metadatas, documents)\\n            ```\\n        \"\"\"\\n\\n        if not len(ids) == len(documents) == len(metadatas):\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n        try:\\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\\n        except Exception as exception:\\n            raise exception\\n\\n    def get_embeddings(\\n        self,\\n        ids: list[str] | None,\\n        *,\\n        where_filter: chroma_types.Where | None = None,\\n        limit: int | None = None,\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n    ) -> chroma_types.GetResult | None:\\n        \"\"\"\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to get from the collection.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n            - limit (int | None): The maximum number of results to return.\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\n                - ids: list[str]\\n                - embeddings: list[Embedding] | None\\n                - documents: list[str] | None\\n                - uris: chroma_types.URIs | None\\n                - data: chroma_types.Loadable | None\\n                - metadatas: list[chroma_types.Metadata]]\\n\\n        Raises:\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError: If you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            # define the ids, filters to use to get embeddings from the collection\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\n\\n            # get the embeddings from the collection\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\n                ids,\\n                where_filter=where_filter,\\n                where_document_filter=where_document_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n        try:\\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\n            return self.collection.get(\\n                ids,\\n                where=where_filter,\\n                limit=limit,\\n                where_document=where_document_filter,\\n                include=include_in_result,\\n            )\\n        except Exception as exception:\\n            raise exception\\n\\n    def query_collection(\\n        self,\\n        queries: list[str],\\n        n_results: int = 10,\\n        where_filter: chroma_types.Where | None = None,\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n    ) -> chroma_types.QueryResult | None:\\n        \"\"\"\\n        Queries and returns the `n` nearest neighbors from the collection.\\n\\n        Args:\\n            - queries (list[str]): A list of queries to search the collection for.\\n            - n_results (int): The number of results to return.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                - e.g. `{$contains: \"binary search\"}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\n                `include_in_result` parameter:\\n                - ids: list[str] # The ids are always returned.\\n                - embeddings: List[list[Embedding]] | None\\n                - documents: list[list[str]]] | None\\n                - uris: list[list[URI]]] | None\\n                - data: list[Loadable] | None\\n                - metadatas: list[list[Metadata]] | None\\n                - distances: list[list[float]] | None\\n\\n        Raises:\\n            - ValueError: If you don\\'t provide query_texts.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma\\n\\n            # define the queries and filters used to search the collection\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\n\\n            # query the collection and return the results from the collection\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\n                queries,\\n                where_filter=where_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n        try:\\n            logging.info(f\"Querying collection {self.collection.name}\")\\n\\n            if results := self.collection.query(\\n                query_texts=queries,\\n                n_results=n_results,\\n                where=where_filter,\\n                where_document=where_document_filter,\\n                include=include_in_result,\\n            ):\\n                logging.info(\\n                    f\"Got {len(results)} results from collection {self.collection.name}.\"\\n                )\\n                return results\\n            else:\\n                logging.warning(\\n                    f\"No results found from collection {self.collection.name}.\"\\n                )\\n\\n        except Exception as exception:\\n            raise exception\\n\\n    def modify_collection_name(self, name: str) -> None:\\n        \"\"\"\\n        Modifies the name of the collection managed by this class.\\n\\n        Args:\\n            - name (str): The new name to assign to the collection.\\n\\n        Examples:\\n            ```Python\\n            # Rename the collection to \\'new_collection_name\\'\\n            collection_manager.modify_collection_name(\\'new_collection_name\\')\\n            ```\\n        \"\"\"\\n\\n        self.collection.modify(name=name)\\n\\n    def modify_collection_metadata(\\n        self, metadata: dict[str, Any] | None = None\\n    ) -> None:\\n        \"\"\"\\n        Modifies the metadata of the collection managed by this class.\\n\\n        Args:\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata of the collection\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\n            collection_manager.modify_collection_metadata(new_metadata)\\n            ```\\n        \"\"\"\\n\\n        self.collection.modify(metadata=metadata)\\n\\n    def update_metadata_or_documents_by_ids(\\n        self,\\n        ids: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\n        documents: list[str] | None = None,\\n    ) -> None:\\n        \"\"\"\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids of the entries to be updated.\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If neither metadatas nor documents are provided.\\n            - ValueError: If the length of ids and documents don\\'t match.\\n            - ValueError: If the length of ids and metadatas don\\'t match.\\n            - ValueError: If the length of ids, metadatas, and documents don\\'t match.\\n\\n        Notes:\\n            - As of now, ChromaDB doesn\\'t raise an exception if you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata and documents for specific ids\\n            ids_to_update = [\\'id1\\', \\'id2\\']\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\n            document_updates = [\"new document 1\", \"new document 2\"]\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\n            ```\\n        \"\"\"\\n\\n        if not metadatas and not documents:\\n            raise ValueError(\"You must provide either metadatas or documents.\")\\n        if not metadatas and documents:\\n            if len(ids) != len(documents):\\n                raise ValueError(\"The length of ids and documents must match.\")\\n        if metadatas and not documents:\\n            if len(ids) != len(metadatas):\\n                raise ValueError(\"The length of ids and metadatas must match.\")\\n        if metadatas and documents:\\n            if len(ids) != len(metadatas) != len(documents):\\n                raise ValueError(\\n                    \"The length of ids, metadatas, and documents must match.\"\\n                )\\n        for index, id in enumerate(ids):\\n            if not self.collection.get(id):\\n                logging.error(\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\n                )\\n                ids.pop(index)\\n                if metadatas:\\n                    popped_metadata = metadatas.pop(index)\\n                    if popped_metadata:\\n                        logging.warning(\\n                            f\"Removing metadata at index {index} from update.\"\\n                        )\\n                if documents:\\n                    popped_document = documents.pop(index)\\n                    if popped_document:\\n                        logging.warning(\\n                            f\"Removing document at index {index} from update.\"\\n                        )\\n\\n        if not ids:\\n            logging.warning(\"All updates failed.\")\\n            return None\\n        else:\\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\n\\n    def upsert_documents(\\n        self,\\n        ids: list[str],\\n        documents: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\n        # embeddings: list[chroma_types.Embedding],\\n    ) -> None:\\n        \"\"\"\\n        Inserts or updates documents in the collection, based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\n            - documents (list[str]): List of documents corresponding to the ids.\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\'t match.\\n\\n        Examples:\\n            ```Python\\n            # Upsert documents in the collection\\n            ids = [\\'id1\\', \\'id2\\']\\n            documents = [\\'doc1\\', \\'doc2\\']\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\n\\n            # Upsert documents in the collection\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\n            ```\\n        \"\"\"\\n\\n        if len(ids) != len(documents) != len(metadatas):\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\n        self.collection.upsert(\\n            ids=ids,\\n            # embeddings=embeddings,\\n            metadatas=metadatas,\\n            documents=documents,\\n        )\\n\\n    def delete_embeddings(self, ids: list[str]) -> None:\\n        \"\"\"\\n        Deletes embeddings from the collection based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\n\\n        Examples:\\n            ```Python\\n            # Delete specific embeddings by ids\\n            ids_to_delete = [\\'id1\\', \\'id2\\']\\n            collection_manager.delete_embeddings(ids_to_delete)\\n            ```\\n        \"\"\"\\n\\n        ids_to_delete: list[str] = ids.copy()\\n        for index, id in enumerate(ids_to_delete):\\n            if not self.collection.get(id):\\n                logging.error(\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\n                )\\n                ids_to_delete.pop(index)\\n\\n        if not ids_to_delete:\\n            logging.warning(\"No IDs given were in the database.\")\\n            return None\\n\\n        logging.info(\\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\n        )\\n        self.collection.delete(ids_to_delete)\\n\\n```\\n\\nCHILDREN_SUMMARIES:\\n\\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\\\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\\\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\nclass ChromaDBCollectionManager:\\\\n    \"\"\"\\\\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\\\\n    and querying embeddings, and their associated metadata.\\\\n\\\\n    This class serves as an interface to interact with a specific collection in ChromaDB.\\\\n\\\\n    Attributes:\\\\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\\\\n            which this manager is responsible for.\\\\n\\\\n    Methods:\\\\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\\\\n        - `add_embeddings`: Adds embeddings to the collection.\\\\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\\\\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\\\\n\\\\n    Examples:\\\\n        ```Python\\\\n        from postcode.databases.chroma import ChromaDBClientBuilder\\\\n        import postcode.types.chromadb.types as chroma_types\\\\n\\\\n        # Create a persistent ChromaDB client\\\\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\\\n\\\\n        # Instantiate the ChromaDBCollectionManager with a specific collection\\\\n        collection_manager: ChromaDBCollectionManager = (\\\\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\\\\n        )\\\\n\\\\n        # Example usage of the collection manager\\\\n        embedding_count: int = collection_manager.collection_embedding_count()\\\\n        print(f\"Total embeddings: {embedding_count}\")\\\\n        ```\\\\n    \"\"\"\\\\n\\\\n    def __init__(self, collection: chroma_types.Collection) -> None:\\\\n        self.collection: chroma_types.Collection = collection\\\\n\\\\n    def collection_embedding_count(self) -> int:\\\\n        \"\"\"\\\\n        Gets the total number of embeddings in the collection.\\\\n\\\\n        Returns:\\\\n            - embedding_count (int): The total number of embeddings in the collection.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        embedding_count: int = self.collection.count()\\\\n        logging.info(\\\\n            f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\\\n        )\\\\n\\\\n        return embedding_count\\\\n\\\\n    def add_embeddings(\\\\n        self,\\\\n        ids: list[str],\\\\n        documents: list[str],\\\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\\\n    ) -> None:\\\\n        \"\"\"\\\\n        Adds embeddings to the collection.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): A list of ids to add to the collection.\\\\n            - documents (list[str]): A list of documents to add to the collection.\\\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\\\n\\\\n        Raises:\\\\n            - ValueError - If you don\\\\\\'t provide either embeddings or documents.\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\'t match.\\\\n            - ValueError - If you provide an id that already exists.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # define the ids, metadatas, and documents to add to the collection\\\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\\\n            metadatas: list[dict[str, Any]] = [\\\\n                {\"my_metadata\": \"my_metadata_value\"},\\\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\\\n            ]\\\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\\\n\\\\n            # add the embeddings to the collection\\\\n            collection_manager.add_embeddings(id, metadatas, documents)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        if not len(ids) == len(documents) == len(metadatas):\\\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\n\\\\n        try:\\\\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\\\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\\\\n        except Exception as exception:\\\\n            raise exception\\\\n\\\\n    def get_embeddings(\\\\n        self,\\\\n        ids: list[str] | None,\\\\n        *,\\\\n        where_filter: chroma_types.Where | None = None,\\\\n        limit: int | None = None,\\\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\n    ) -> chroma_types.GetResult | None:\\\\n        \"\"\"\\\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): A list of ids to get from the collection.\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\n            - limit (int | None): The maximum number of results to return.\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\n\\\\n        Returns:\\\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\\\n                - ids: list[str]\\\\n                - embeddings: list[Embedding] | None\\\\n                - documents: list[str] | None\\\\n                - uris: chroma_types.URIs | None\\\\n                - data: chroma_types.Loadable | None\\\\n                - metadatas: list[chroma_types.Metadata]]\\\\n\\\\n        Raises:\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\'t match.\\\\n            - ValueError: If you provide an id that doesn\\\\\\'t exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            import postcode.types.chromadb.types as chroma_types\\\\n\\\\n            # define the ids, filters to use to get embeddings from the collection\\\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\\\n\\\\n            # define the data to return from the collection\\\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\\\n\\\\n            # get the embeddings from the collection\\\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\\\n                ids,\\\\n                where_filter=where_filter,\\\\n                where_document_filter=where_document_filter,\\\\n                include_in_result=include_in_result\\\\n                )\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        try:\\\\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\\\n            return self.collection.get(\\\\n                ids,\\\\n                where=where_filter,\\\\n                limit=limit,\\\\n                where_document=where_document_filter,\\\\n                include=include_in_result,\\\\n            )\\\\n        except Exception as exception:\\\\n            raise exception\\\\n\\\\n    def query_collection(\\\\n        self,\\\\n        queries: list[str],\\\\n        n_results: int = 10,\\\\n        where_filter: chroma_types.Where | None = None,\\\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\n    ) -> chroma_types.QueryResult | None:\\\\n        \"\"\"\\\\n        Queries and returns the `n` nearest neighbors from the collection.\\\\n\\\\n        Args:\\\\n            - queries (list[str]): A list of queries to search the collection for.\\\\n            - n_results (int): The number of results to return.\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\n                - e.g. `{$contains: \"binary search\"}`\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\n\\\\n        Returns:\\\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\\\n                `include_in_result` parameter:\\\\n                - ids: list[str] # The ids are always returned.\\\\n                - embeddings: List[list[Embedding]] | None\\\\n                - documents: list[list[str]]] | None\\\\n                - uris: list[list[URI]]] | None\\\\n                - data: list[Loadable] | None\\\\n                - metadatas: list[list[Metadata]] | None\\\\n                - distances: list[list[float]] | None\\\\n\\\\n        Raises:\\\\n            - ValueError: If you don\\\\\\'t provide query_texts.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            import postcode.types.chromadb.types as chroma\\\\n\\\\n            # define the queries and filters used to search the collection\\\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\\\n\\\\n            # define the data to return from the collection\\\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\\\n\\\\n            # query the collection and return the results from the collection\\\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\\\n                queries,\\\\n                where_filter=where_filter,\\\\n                include_in_result=include_in_result\\\\n                )\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        try:\\\\n            logging.info(f\"Querying collection {self.collection.name}\")\\\\n\\\\n            if results := self.collection.query(\\\\n                query_texts=queries,\\\\n                n_results=n_results,\\\\n                where=where_filter,\\\\n                where_document=where_document_filter,\\\\n                include=include_in_result,\\\\n            ):\\\\n                logging.info(\\\\n                    f\"Got {len(results)} results from collection {self.collection.name}.\"\\\\n                )\\\\n                return results\\\\n            else:\\\\n                logging.warning(\\\\n                    f\"No results found from collection {self.collection.name}.\"\\\\n                )\\\\n\\\\n        except Exception as exception:\\\\n            raise exception\\\\n\\\\n    def modify_collection_name(self, name: str) -> None:\\\\n        \"\"\"\\\\n        Modifies the name of the collection managed by this class.\\\\n\\\\n        Args:\\\\n            - name (str): The new name to assign to the collection.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Rename the collection to \\\\\\'new_collection_name\\\\\\'\\\\n            collection_manager.modify_collection_name(\\\\\\'new_collection_name\\\\\\')\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        self.collection.modify(name=name)\\\\n\\\\n    def modify_collection_metadata(\\\\n        self, metadata: dict[str, Any] | None = None\\\\n    ) -> None:\\\\n        \"\"\"\\\\n        Modifies the metadata of the collection managed by this class.\\\\n\\\\n        Args:\\\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Update metadata of the collection\\\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\\\n            collection_manager.modify_collection_metadata(new_metadata)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        self.collection.modify(metadata=metadata)\\\\n\\\\n    def update_metadata_or_documents_by_ids(\\\\n        self,\\\\n        ids: list[str],\\\\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\\\n        documents: list[str] | None = None,\\\\n    ) -> None:\\\\n        \"\"\"\\\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids of the entries to be updated.\\\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\\\n\\\\n        Raises:\\\\n            - ValueError: If neither metadatas nor documents are provided.\\\\n            - ValueError: If the length of ids and documents don\\\\\\'t match.\\\\n            - ValueError: If the length of ids and metadatas don\\\\\\'t match.\\\\n            - ValueError: If the length of ids, metadatas, and documents don\\\\\\'t match.\\\\n\\\\n        Notes:\\\\n            - As of now, ChromaDB doesn\\\\\\'t raise an exception if you provide an id that doesn\\\\\\'t exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Update metadata and documents for specific ids\\\\n            ids_to_update = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\\\n            document_updates = [\"new document 1\", \"new document 2\"]\\\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        if not metadatas and not documents:\\\\n            raise ValueError(\"You must provide either metadatas or documents.\")\\\\n        if not metadatas and documents:\\\\n            if len(ids) != len(documents):\\\\n                raise ValueError(\"The length of ids and documents must match.\")\\\\n        if metadatas and not documents:\\\\n            if len(ids) != len(metadatas):\\\\n                raise ValueError(\"The length of ids and metadatas must match.\")\\\\n        if metadatas and documents:\\\\n            if len(ids) != len(metadatas) != len(documents):\\\\n                raise ValueError(\\\\n                    \"The length of ids, metadatas, and documents must match.\"\\\\n                )\\\\n        for index, id in enumerate(ids):\\\\n            if not self.collection.get(id):\\\\n                logging.error(\\\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\n                )\\\\n                ids.pop(index)\\\\n                if metadatas:\\\\n                    popped_metadata = metadatas.pop(index)\\\\n                    if popped_metadata:\\\\n                        logging.warning(\\\\n                            f\"Removing metadata at index {index} from update.\"\\\\n                        )\\\\n                if documents:\\\\n                    popped_document = documents.pop(index)\\\\n                    if popped_document:\\\\n                        logging.warning(\\\\n                            f\"Removing document at index {index} from update.\"\\\\n                        )\\\\n\\\\n        if not ids:\\\\n            logging.warning(\"All updates failed.\")\\\\n            return None\\\\n        else:\\\\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\\\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\\\n\\\\n    def upsert_documents(\\\\n        self,\\\\n        ids: list[str],\\\\n        documents: list[str],\\\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\\\n        # embeddings: list[chroma_types.Embedding],\\\\n    ) -> None:\\\\n        \"\"\"\\\\n        Inserts or updates documents in the collection, based on the provided ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\\\n            - documents (list[str]): List of documents corresponding to the ids.\\\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\\\n\\\\n        Raises:\\\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\\\\\'t match.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Upsert documents in the collection\\\\n            ids = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            documents = [\\\\\\'doc1\\\\\\', \\\\\\'doc2\\\\\\']\\\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\\\n\\\\n            # Upsert documents in the collection\\\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        if len(ids) != len(documents) != len(metadatas):\\\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\n\\\\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\\\n        self.collection.upsert(\\\\n            ids=ids,\\\\n            # embeddings=embeddings,\\\\n            metadatas=metadatas,\\\\n            documents=documents,\\\\n        )\\\\n\\\\n    def delete_embeddings(self, ids: list[str]) -> None:\\\\n        \"\"\"\\\\n        Deletes embeddings from the collection based on the provided ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Delete specific embeddings by ids\\\\n            ids_to_delete = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            collection_manager.delete_embeddings(ids_to_delete)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        ids_to_delete: list[str] = ids.copy()\\\\n        for index, id in enumerate(ids_to_delete):\\\\n            if not self.collection.get(id):\\\\n                logging.error(\\\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\n                )\\\\n                ids_to_delete.pop(index)\\\\n\\\\n        if not ids_to_delete:\\\\n            logging.warning(\"No IDs given were in the database.\")\\\\n            return None\\\\n\\\\n        logging.info(\\\\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\\\n        )\\\\n        self.collection.delete(ids_to_delete)\\\\n\\\\n```\\\\n\\\\nCHILDREN_SUMMARIES:\\\\n\\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef __init__(self, collection: chroma_types.Collection) -> None:\\\\\\\\n    self.collection: chroma_types.Collection = collection\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef collection_embedding_count(self) -> int:\\\\\\\\n    \"\"\"\\\\\\\\n        Gets the total number of embeddings in the collection.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - embedding_count (int): The total number of embeddings in the collection.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    embedding_count: int = self.collection.count()\\\\\\\\n    logging.info(\\\\\\\\n        f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\\\\\\\n    )\\\\\\\\n\\\\\\\\n    return embedding_count\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef add_embeddings(\\\\\\\\n    self,\\\\\\\\n    ids: list[str],\\\\\\\\n    documents: list[str],\\\\\\\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\\\\\\\n) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Adds embeddings to the collection.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - ids (list[str]): A list of ids to add to the collection.\\\\\\\\n            - documents (list[str]): A list of documents to add to the collection.\\\\\\\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError - If you don\\\\\\\\\\\\\\'t provide either embeddings or documents.\\\\\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\\\\\\\\\'t match.\\\\\\\\n            - ValueError - If you provide an id that already exists.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # define the ids, metadatas, and documents to add to the collection\\\\\\\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\\\\\\\n            metadatas: list[dict[str, Any]] = [\\\\\\\\n                {\"my_metadata\": \"my_metadata_value\"},\\\\\\\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\\\\\\\n            ]\\\\\\\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\\\\\\\n\\\\\\\\n            # add the embeddings to the collection\\\\\\\\n            collection_manager.add_embeddings(id, metadatas, documents)\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    if not len(ids) == len(documents) == len(metadatas):\\\\\\\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\\\\\n\\\\\\\\n    try:\\\\\\\\n        logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\\\\\\\n        self.collection.add(ids, documents=documents, metadatas=metadatas)\\\\\\\\n    except Exception as exception:\\\\\\\\n        raise exception\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef get_embeddings(\\\\\\\\n    self,\\\\\\\\n    ids: list[str] | None,\\\\\\\\n    *,\\\\\\\\n    where_filter: chroma_types.Where | None = None,\\\\\\\\n    limit: int | None = None,\\\\\\\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\\\\\\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\\\\\n) -> chroma_types.GetResult | None:\\\\\\\\n    \"\"\"\\\\\\\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - ids (list[str]): A list of ids to get from the collection.\\\\\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\\\\\n            - limit (int | None): The maximum number of results to return.\\\\\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\\\\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\\\\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\\\\\\\n                - ids: list[str]\\\\\\\\n                - embeddings: list[Embedding] | None\\\\\\\\n                - documents: list[str] | None\\\\\\\\n                - uris: chroma_types.URIs | None\\\\\\\\n                - data: chroma_types.Loadable | None\\\\\\\\n                - metadatas: list[chroma_types.Metadata]]\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\\\\\\\\\'t match.\\\\\\\\n            - ValueError: If you provide an id that doesn\\\\\\\\\\\\\\'t exist.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            import postcode.types.chromadb.types as chroma_types\\\\\\\\n\\\\\\\\n            # define the ids, filters to use to get embeddings from the collection\\\\\\\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\\\\\\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\\\\\\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\\\\\\\n\\\\\\\\n            # define the data to return from the collection\\\\\\\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\\\\\\\n\\\\\\\\n            # get the embeddings from the collection\\\\\\\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\\\\\\\n                ids,\\\\\\\\n                where_filter=where_filter,\\\\\\\\n                where_document_filter=where_document_filter,\\\\\\\\n                include_in_result=include_in_result\\\\\\\\n                )\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    try:\\\\\\\\n        logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\\\\\\\n        return self.collection.get(\\\\\\\\n            ids,\\\\\\\\n            where=where_filter,\\\\\\\\n            limit=limit,\\\\\\\\n            where_document=where_document_filter,\\\\\\\\n            include=include_in_result,\\\\\\\\n        )\\\\\\\\n    except Exception as exception:\\\\\\\\n        raise exception\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef query_collection(\\\\\\\\n    self,\\\\\\\\n    queries: list[str],\\\\\\\\n    n_results: int = 10,\\\\\\\\n    where_filter: chroma_types.Where | None = None,\\\\\\\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\\\\\\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\\\\\n) -> chroma_types.QueryResult | None:\\\\\\\\n    \"\"\"\\\\\\\\n        Queries and returns the `n` nearest neighbors from the collection.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - queries (list[str]): A list of queries to search the collection for.\\\\\\\\n            - n_results (int): The number of results to return.\\\\\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\\\\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\\\\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\\\\\n                - e.g. `{$contains: \"binary search\"}`\\\\\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\\\\\\\n                `include_in_result` parameter:\\\\\\\\n                - ids: list[str] # The ids are always returned.\\\\\\\\n                - embeddings: List[list[Embedding]] | None\\\\\\\\n                - documents: list[list[str]]] | None\\\\\\\\n                - uris: list[list[URI]]] | None\\\\\\\\n                - data: list[Loadable] | None\\\\\\\\n                - metadatas: list[list[Metadata]] | None\\\\\\\\n                - distances: list[list[float]] | None\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError: If you don\\\\\\\\\\\\\\'t provide query_texts.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            import postcode.types.chromadb.types as chroma\\\\\\\\n\\\\\\\\n            # define the queries and filters used to search the collection\\\\\\\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\\\\\\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\\\\\\\n\\\\\\\\n            # define the data to return from the collection\\\\\\\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\\\\\\\n\\\\\\\\n            # query the collection and return the results from the collection\\\\\\\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\\\\\\\n                queries,\\\\\\\\n                where_filter=where_filter,\\\\\\\\n                include_in_result=include_in_result\\\\\\\\n                )\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    try:\\\\\\\\n        logging.info(f\"Querying collection {self.collection.name}\")\\\\\\\\n\\\\\\\\n        if results := self.collection.query(\\\\\\\\n            query_texts=queries,\\\\\\\\n            n_results=n_results,\\\\\\\\n            where=where_filter,\\\\\\\\n            where_document=where_document_filter,\\\\\\\\n            include=include_in_result,\\\\\\\\n        ):\\\\\\\\n            logging.info(\\\\\\\\n                f\"Got {len(results)} results from collection {self.collection.name}.\"\\\\\\\\n            )\\\\\\\\n            return results\\\\\\\\n        else:\\\\\\\\n            logging.warning(\\\\\\\\n                f\"No results found from collection {self.collection.name}.\"\\\\\\\\n            )\\\\\\\\n\\\\\\\\n    except Exception as exception:\\\\\\\\n        raise exception\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef modify_collection_name(self, name: str) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Modifies the name of the collection managed by this class.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - name (str): The new name to assign to the collection.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # Rename the collection to \\\\\\\\\\\\\\'new_collection_name\\\\\\\\\\\\\\'\\\\\\\\n            collection_manager.modify_collection_name(\\\\\\\\\\\\\\'new_collection_name\\\\\\\\\\\\\\')\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    self.collection.modify(name=name)\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef modify_collection_metadata(\\\\\\\\n    self, metadata: dict[str, Any] | None = None\\\\\\\\n) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Modifies the metadata of the collection managed by this class.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # Update metadata of the collection\\\\\\\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\\\\\\\n            collection_manager.modify_collection_metadata(new_metadata)\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    self.collection.modify(metadata=metadata)\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef update_metadata_or_documents_by_ids(\\\\\\\\n    self,\\\\\\\\n    ids: list[str],\\\\\\\\n    metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\\\\\\\n    documents: list[str] | None = None,\\\\\\\\n) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - ids (list[str]): List of ids of the entries to be updated.\\\\\\\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\\\\\\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError: If neither metadatas nor documents are provided.\\\\\\\\n            - ValueError: If the length of ids and documents don\\\\\\\\\\\\\\'t match.\\\\\\\\n            - ValueError: If the length of ids and metadatas don\\\\\\\\\\\\\\'t match.\\\\\\\\n            - ValueError: If the length of ids, metadatas, and documents don\\\\\\\\\\\\\\'t match.\\\\\\\\n\\\\\\\\n        Notes:\\\\\\\\n            - As of now, ChromaDB doesn\\\\\\\\\\\\\\'t raise an exception if you provide an id that doesn\\\\\\\\\\\\\\'t exist.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # Update metadata and documents for specific ids\\\\\\\\n            ids_to_update = [\\\\\\\\\\\\\\'id1\\\\\\\\\\\\\\', \\\\\\\\\\\\\\'id2\\\\\\\\\\\\\\']\\\\\\\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\\\\\\\n            document_updates = [\"new document 1\", \"new document 2\"]\\\\\\\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    if not metadatas and not documents:\\\\\\\\n        raise ValueError(\"You must provide either metadatas or documents.\")\\\\\\\\n    if not metadatas and documents:\\\\\\\\n        if len(ids) != len(documents):\\\\\\\\n            raise ValueError(\"The length of ids and documents must match.\")\\\\\\\\n    if metadatas and not documents:\\\\\\\\n        if len(ids) != len(metadatas):\\\\\\\\n            raise ValueError(\"The length of ids and metadatas must match.\")\\\\\\\\n    if metadatas and documents:\\\\\\\\n        if len(ids) != len(metadatas) != len(documents):\\\\\\\\n            raise ValueError(\\\\\\\\n                \"The length of ids, metadatas, and documents must match.\"\\\\\\\\n            )\\\\\\\\n    for index, id in enumerate(ids):\\\\\\\\n        if not self.collection.get(id):\\\\\\\\n            logging.error(\\\\\\\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\\\\\n            )\\\\\\\\n            ids.pop(index)\\\\\\\\n            if metadatas:\\\\\\\\n                popped_metadata = metadatas.pop(index)\\\\\\\\n                if popped_metadata:\\\\\\\\n                    logging.warning(\\\\\\\\n                        f\"Removing metadata at index {index} from update.\"\\\\\\\\n                    )\\\\\\\\n            if documents:\\\\\\\\n                popped_document = documents.pop(index)\\\\\\\\n                if popped_document:\\\\\\\\n                    logging.warning(\\\\\\\\n                        f\"Removing document at index {index} from update.\"\\\\\\\\n                    )\\\\\\\\n\\\\\\\\n    if not ids:\\\\\\\\n        logging.warning(\"All updates failed.\")\\\\\\\\n        return None\\\\\\\\n    else:\\\\\\\\n        logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\\\\\\\n        self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef upsert_documents(\\\\\\\\n    self,\\\\\\\\n    ids: list[str],\\\\\\\\n    documents: list[str],\\\\\\\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\\\\\\\n    # embeddings: list[chroma_types.Embedding],\\\\\\\\n) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Inserts or updates documents in the collection, based on the provided ids.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\\\\\\\n            - documents (list[str]): List of documents corresponding to the ids.\\\\\\\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\\\\\\\\\\\\\'t match.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # Upsert documents in the collection\\\\\\\\n            ids = [\\\\\\\\\\\\\\'id1\\\\\\\\\\\\\\', \\\\\\\\\\\\\\'id2\\\\\\\\\\\\\\']\\\\\\\\n            documents = [\\\\\\\\\\\\\\'doc1\\\\\\\\\\\\\\', \\\\\\\\\\\\\\'doc2\\\\\\\\\\\\\\']\\\\\\\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\\\\\\\n\\\\\\\\n            # Upsert documents in the collection\\\\\\\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    if len(ids) != len(documents) != len(metadatas):\\\\\\\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\\\\\n\\\\\\\\n    logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\\\\\\\n    self.collection.upsert(\\\\\\\\n        ids=ids,\\\\\\\\n        # embeddings=embeddings,\\\\\\\\n        metadatas=metadatas,\\\\\\\\n        documents=documents,\\\\\\\\n    )\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef delete_embeddings(self, ids: list[str]) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Deletes embeddings from the collection based on the provided ids.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            # Delete specific embeddings by ids\\\\\\\\n            ids_to_delete = [\\\\\\\\\\\\\\'id1\\\\\\\\\\\\\\', \\\\\\\\\\\\\\'id2\\\\\\\\\\\\\\']\\\\\\\\n            collection_manager.delete_embeddings(ids_to_delete)\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    ids_to_delete: list[str] = ids.copy()\\\\\\\\n    for index, id in enumerate(ids_to_delete):\\\\\\\\n        if not self.collection.get(id):\\\\\\\\n            logging.error(\\\\\\\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\\\\\n            )\\\\\\\\n            ids_to_delete.pop(index)\\\\\\\\n\\\\\\\\n    if not ids_to_delete:\\\\\\\\n        logging.warning(\"No IDs given were in the database.\")\\\\\\\\n        return None\\\\\\\\n\\\\\\\\n    logging.info(\\\\\\\\n        f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\\\\\\\n    )\\\\\\\\n    self.collection.delete(ids_to_delete)\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport logging\\\\nfrom typing import Any, Mapping\\\\nfrom typing import Any, Mapping\\\\nimport postcode.types.chroma as chroma_types\\\\nimport postcode.types.chroma as chroma_types\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nfrom typing import Any, Mapping\\nimport postcode.types.chroma as chroma_types\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
    "children": [
        {
            "class_name": "ChromaDBCollectionManager",
            "decorators": null,
            "bases": null,
            "docstring": "Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\nand querying embeddings, and their associated metadata.\n\nThis class serves as an interface to interact with a specific collection in ChromaDB.\n\nAttributes:\n    - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\n        which this manager is responsible for.\n\nMethods:\n    - `collection_embedding_count`: Gets the total number of embeddings in the collection.\n    - `add_embeddings`: Adds embeddings to the collection.\n    - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\n    - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\n\nExamples:\n    ```Python\n    from postcode.databases.chroma import ChromaDBClientBuilder\n    import postcode.types.chromadb.types as chroma_types\n\n    # Create a persistent ChromaDB client\n    client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n    # Instantiate the ChromaDBCollectionManager with a specific collection\n    collection_manager: ChromaDBCollectionManager = (\n        ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\n    )\n\n    # Example usage of the collection manager\n    embedding_count: int = collection_manager.collection_embedding_count()\n    print(f\"Total embeddings: {embedding_count}\")\n    ```",
            "keywords": null,
            "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
            "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE",
            "block_type": "CLASS",
            "start_line_num": 5,
            "end_line_num": 431,
            "code_content": "\n\nclass ChromaDBCollectionManager:\n    \"\"\"\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\n    and querying embeddings, and their associated metadata.\n\n    This class serves as an interface to interact with a specific collection in ChromaDB.\n\n    Attributes:\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\n            which this manager is responsible for.\n\n    Methods:\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\n        - `add_embeddings`: Adds embeddings to the collection.\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder\n        import postcode.types.chromadb.types as chroma_types\n\n        # Create a persistent ChromaDB client\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Instantiate the ChromaDBCollectionManager with a specific collection\n        collection_manager: ChromaDBCollectionManager = (\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\n        )\n\n        # Example usage of the collection manager\n        embedding_count: int = collection_manager.collection_embedding_count()\n        print(f\"Total embeddings: {embedding_count}\")\n        ```\n    \"\"\"\n\n    def __init__(self, collection: chroma_types.Collection) -> None:\n        self.collection: chroma_types.Collection = collection\n\n    def collection_embedding_count(self) -> int:\n        \"\"\"\n        Gets the total number of embeddings in the collection.\n\n        Returns:\n            - embedding_count (int): The total number of embeddings in the collection.\n\n        Examples:\n            ```Python\n            embedding_count: int = collection_manager.get_collection_embedding_count()\n            ```\n        \"\"\"\n\n        embedding_count: int = self.collection.count()\n        logging.info(\n            f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\n        )\n\n        return embedding_count\n\n    def add_embeddings(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n    ) -> None:\n        \"\"\"\n        Adds embeddings to the collection.\n\n        Args:\n            - ids (list[str]): A list of ids to add to the collection.\n            - documents (list[str]): A list of documents to add to the collection.\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\n        Raises:\n            - ValueError - If you don't provide either embeddings or documents.\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError - If you provide an id that already exists.\n\n        Examples:\n            ```Python\n            # define the ids, metadatas, and documents to add to the collection\n            id: list[str] = [\"my_id\", \"my_id2\"]\n            metadatas: list[dict[str, Any]] = [\n                {\"my_metadata\": \"my_metadata_value\"},\n                {\"my_metadata2\": \"my_metadata_value2\"},\n            ]\n            documents: list[str] = [\"my_document\", \"my_document2\"]\n\n            # add the embeddings to the collection\n            collection_manager.add_embeddings(id, metadatas, documents)\n            ```\n        \"\"\"\n\n        if not len(ids) == len(documents) == len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        try:\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\n        except Exception as exception:\n            raise exception\n\n    def get_embeddings(\n        self,\n        ids: list[str] | None,\n        *,\n        where_filter: chroma_types.Where | None = None,\n        limit: int | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.GetResult | None:\n        \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n            return self.collection.get(\n                ids,\n                where=where_filter,\n                limit=limit,\n                where_document=where_document_filter,\n                include=include_in_result,\n            )\n        except Exception as exception:\n            raise exception\n\n    def query_collection(\n        self,\n        queries: list[str],\n        n_results: int = 10,\n        where_filter: chroma_types.Where | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.QueryResult | None:\n        \"\"\"\n        Queries and returns the `n` nearest neighbors from the collection.\n\n        Args:\n            - queries (list[str]): A list of queries to search the collection for.\n            - n_results (int): The number of results to return.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                - e.g. `{$contains: \"binary search\"}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n                `include_in_result` parameter:\n                - ids: list[str] # The ids are always returned.\n                - embeddings: List[list[Embedding]] | None\n                - documents: list[list[str]]] | None\n                - uris: list[list[URI]]] | None\n                - data: list[Loadable] | None\n                - metadatas: list[list[Metadata]] | None\n                - distances: list[list[float]] | None\n\n        Raises:\n            - ValueError: If you don't provide query_texts.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma\n\n            # define the queries and filters used to search the collection\n            queries: list[str] = [\"binary search\", \"linear search\"]\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n            # query the collection and return the results from the collection\n            results: chroma_types.QueryResult = collection_manager.query_collection(\n                queries,\n                where_filter=where_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Querying collection {self.collection.name}\")\n\n            if results := self.collection.query(\n                query_texts=queries,\n                n_results=n_results,\n                where=where_filter,\n                where_document=where_document_filter,\n                include=include_in_result,\n            ):\n                logging.info(\n                    f\"Got {len(results)} results from collection {self.collection.name}.\"\n                )\n                return results\n            else:\n                logging.warning(\n                    f\"No results found from collection {self.collection.name}.\"\n                )\n\n        except Exception as exception:\n            raise exception\n\n    def modify_collection_name(self, name: str) -> None:\n        \"\"\"\n        Modifies the name of the collection managed by this class.\n\n        Args:\n            - name (str): The new name to assign to the collection.\n\n        Examples:\n            ```Python\n            # Rename the collection to 'new_collection_name'\n            collection_manager.modify_collection_name('new_collection_name')\n            ```\n        \"\"\"\n\n        self.collection.modify(name=name)\n\n    def modify_collection_metadata(\n        self, metadata: dict[str, Any] | None = None\n    ) -> None:\n        \"\"\"\n        Modifies the metadata of the collection managed by this class.\n\n        Args:\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\n        Examples:\n            ```Python\n            # Update metadata of the collection\n            new_metadata = {\"description\": \"Updated collection metadata\"}\n            collection_manager.modify_collection_metadata(new_metadata)\n            ```\n        \"\"\"\n\n        self.collection.modify(metadata=metadata)\n\n    def update_metadata_or_documents_by_ids(\n        self,\n        ids: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\n        documents: list[str] | None = None,\n    ) -> None:\n        \"\"\"\n        Updates the metadata or documents of specific entries in the collection by their ids.\n\n        Args:\n            - ids (list[str]): List of ids of the entries to be updated.\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n            - documents (list[str] | None): List of document updates corresponding to the ids.\n\n        Raises:\n            - ValueError: If neither metadatas nor documents are provided.\n            - ValueError: If the length of ids and documents don't match.\n            - ValueError: If the length of ids and metadatas don't match.\n            - ValueError: If the length of ids, metadatas, and documents don't match.\n\n        Notes:\n            - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            # Update metadata and documents for specific ids\n            ids_to_update = ['id1', 'id2']\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n            document_updates = [\"new document 1\", \"new document 2\"]\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n            ```\n        \"\"\"\n\n        if not metadatas and not documents:\n            raise ValueError(\"You must provide either metadatas or documents.\")\n        if not metadatas and documents:\n            if len(ids) != len(documents):\n                raise ValueError(\"The length of ids and documents must match.\")\n        if metadatas and not documents:\n            if len(ids) != len(metadatas):\n                raise ValueError(\"The length of ids and metadatas must match.\")\n        if metadatas and documents:\n            if len(ids) != len(metadatas) != len(documents):\n                raise ValueError(\n                    \"The length of ids, metadatas, and documents must match.\"\n                )\n        for index, id in enumerate(ids):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids.pop(index)\n                if metadatas:\n                    popped_metadata = metadatas.pop(index)\n                    if popped_metadata:\n                        logging.warning(\n                            f\"Removing metadata at index {index} from update.\"\n                        )\n                if documents:\n                    popped_document = documents.pop(index)\n                    if popped_document:\n                        logging.warning(\n                            f\"Removing document at index {index} from update.\"\n                        )\n\n        if not ids:\n            logging.warning(\"All updates failed.\")\n            return None\n        else:\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\n\n    def upsert_documents(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n        # embeddings: list[chroma_types.Embedding],\n    ) -> None:\n        \"\"\"\n        Inserts or updates documents in the collection, based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\n            - documents (list[str]): List of documents corresponding to the ids.\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\n        Raises:\n            - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\n        Examples:\n            ```Python\n            # Upsert documents in the collection\n            ids = ['id1', 'id2']\n            documents = ['doc1', 'doc2']\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n            # Upsert documents in the collection\n            collection_manager.upsert_documents(ids, documents, metadatas)\n            ```\n        \"\"\"\n\n        if len(ids) != len(documents) != len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\n        self.collection.upsert(\n            ids=ids,\n            # embeddings=embeddings,\n            metadatas=metadatas,\n            documents=documents,\n        )\n\n    def delete_embeddings(self, ids: list[str]) -> None:\n        \"\"\"\n        Deletes embeddings from the collection based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\n        Examples:\n            ```Python\n            # Delete specific embeddings by ids\n            ids_to_delete = ['id1', 'id2']\n            collection_manager.delete_embeddings(ids_to_delete)\n            ```\n        \"\"\"\n\n        ids_to_delete: list[str] = ids.copy()\n        for index, id in enumerate(ids_to_delete):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids_to_delete.pop(index)\n\n        if not ids_to_delete:\n            logging.warning(\"No IDs given were in the database.\")\n            return None\n\n        logging.info(\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\n        )\n        self.collection.delete(ids_to_delete)\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "logging",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Any",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Mapping",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "typing",
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Any",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Mapping",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "typing",
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "postcode.types.chroma",
                            "as_name": "chroma_types",
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "LOCAL",
                    "local_module_id": "postcode:types:chroma.py__*__MODULE"
                },
                {
                    "import_names": [
                        {
                            "name": "postcode.types.chroma",
                            "as_name": "chroma_types",
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "LOCAL",
                    "local_module_id": "postcode:types:chroma.py__*__MODULE"
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\nclass ChromaDBCollectionManager:\\n    \"\"\"\\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\\n    and querying embeddings, and their associated metadata.\\n\\n    This class serves as an interface to interact with a specific collection in ChromaDB.\\n\\n    Attributes:\\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\\n            which this manager is responsible for.\\n\\n    Methods:\\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\\n        - `add_embeddings`: Adds embeddings to the collection.\\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\\n\\n    Examples:\\n        ```Python\\n        from postcode.databases.chroma import ChromaDBClientBuilder\\n        import postcode.types.chromadb.types as chroma_types\\n\\n        # Create a persistent ChromaDB client\\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\n\\n        # Instantiate the ChromaDBCollectionManager with a specific collection\\n        collection_manager: ChromaDBCollectionManager = (\\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\\n        )\\n\\n        # Example usage of the collection manager\\n        embedding_count: int = collection_manager.collection_embedding_count()\\n        print(f\"Total embeddings: {embedding_count}\")\\n        ```\\n    \"\"\"\\n\\n    def __init__(self, collection: chroma_types.Collection) -> None:\\n        self.collection: chroma_types.Collection = collection\\n\\n    def collection_embedding_count(self) -> int:\\n        \"\"\"\\n        Gets the total number of embeddings in the collection.\\n\\n        Returns:\\n            - embedding_count (int): The total number of embeddings in the collection.\\n\\n        Examples:\\n            ```Python\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\n            ```\\n        \"\"\"\\n\\n        embedding_count: int = self.collection.count()\\n        logging.info(\\n            f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\n        )\\n\\n        return embedding_count\\n\\n    def add_embeddings(\\n        self,\\n        ids: list[str],\\n        documents: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\n    ) -> None:\\n        \"\"\"\\n        Adds embeddings to the collection.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to add to the collection.\\n            - documents (list[str]): A list of documents to add to the collection.\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\n\\n        Raises:\\n            - ValueError - If you don\\'t provide either embeddings or documents.\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError - If you provide an id that already exists.\\n\\n        Examples:\\n            ```Python\\n            # define the ids, metadatas, and documents to add to the collection\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\n            metadatas: list[dict[str, Any]] = [\\n                {\"my_metadata\": \"my_metadata_value\"},\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\n            ]\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\n\\n            # add the embeddings to the collection\\n            collection_manager.add_embeddings(id, metadatas, documents)\\n            ```\\n        \"\"\"\\n\\n        if not len(ids) == len(documents) == len(metadatas):\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n        try:\\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\\n        except Exception as exception:\\n            raise exception\\n\\n    def get_embeddings(\\n        self,\\n        ids: list[str] | None,\\n        *,\\n        where_filter: chroma_types.Where | None = None,\\n        limit: int | None = None,\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n    ) -> chroma_types.GetResult | None:\\n        \"\"\"\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to get from the collection.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n            - limit (int | None): The maximum number of results to return.\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\n                - ids: list[str]\\n                - embeddings: list[Embedding] | None\\n                - documents: list[str] | None\\n                - uris: chroma_types.URIs | None\\n                - data: chroma_types.Loadable | None\\n                - metadatas: list[chroma_types.Metadata]]\\n\\n        Raises:\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError: If you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            # define the ids, filters to use to get embeddings from the collection\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\n\\n            # get the embeddings from the collection\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\n                ids,\\n                where_filter=where_filter,\\n                where_document_filter=where_document_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n        try:\\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\n            return self.collection.get(\\n                ids,\\n                where=where_filter,\\n                limit=limit,\\n                where_document=where_document_filter,\\n                include=include_in_result,\\n            )\\n        except Exception as exception:\\n            raise exception\\n\\n    def query_collection(\\n        self,\\n        queries: list[str],\\n        n_results: int = 10,\\n        where_filter: chroma_types.Where | None = None,\\n        where_document_filter: chroma_types.WhereDocument | None = None,\\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n    ) -> chroma_types.QueryResult | None:\\n        \"\"\"\\n        Queries and returns the `n` nearest neighbors from the collection.\\n\\n        Args:\\n            - queries (list[str]): A list of queries to search the collection for.\\n            - n_results (int): The number of results to return.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                - e.g. `{$contains: \"binary search\"}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\n                `include_in_result` parameter:\\n                - ids: list[str] # The ids are always returned.\\n                - embeddings: List[list[Embedding]] | None\\n                - documents: list[list[str]]] | None\\n                - uris: list[list[URI]]] | None\\n                - data: list[Loadable] | None\\n                - metadatas: list[list[Metadata]] | None\\n                - distances: list[list[float]] | None\\n\\n        Raises:\\n            - ValueError: If you don\\'t provide query_texts.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma\\n\\n            # define the queries and filters used to search the collection\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\n\\n            # query the collection and return the results from the collection\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\n                queries,\\n                where_filter=where_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n        try:\\n            logging.info(f\"Querying collection {self.collection.name}\")\\n\\n            if results := self.collection.query(\\n                query_texts=queries,\\n                n_results=n_results,\\n                where=where_filter,\\n                where_document=where_document_filter,\\n                include=include_in_result,\\n            ):\\n                logging.info(\\n                    f\"Got {len(results)} results from collection {self.collection.name}.\"\\n                )\\n                return results\\n            else:\\n                logging.warning(\\n                    f\"No results found from collection {self.collection.name}.\"\\n                )\\n\\n        except Exception as exception:\\n            raise exception\\n\\n    def modify_collection_name(self, name: str) -> None:\\n        \"\"\"\\n        Modifies the name of the collection managed by this class.\\n\\n        Args:\\n            - name (str): The new name to assign to the collection.\\n\\n        Examples:\\n            ```Python\\n            # Rename the collection to \\'new_collection_name\\'\\n            collection_manager.modify_collection_name(\\'new_collection_name\\')\\n            ```\\n        \"\"\"\\n\\n        self.collection.modify(name=name)\\n\\n    def modify_collection_metadata(\\n        self, metadata: dict[str, Any] | None = None\\n    ) -> None:\\n        \"\"\"\\n        Modifies the metadata of the collection managed by this class.\\n\\n        Args:\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata of the collection\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\n            collection_manager.modify_collection_metadata(new_metadata)\\n            ```\\n        \"\"\"\\n\\n        self.collection.modify(metadata=metadata)\\n\\n    def update_metadata_or_documents_by_ids(\\n        self,\\n        ids: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\n        documents: list[str] | None = None,\\n    ) -> None:\\n        \"\"\"\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids of the entries to be updated.\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If neither metadatas nor documents are provided.\\n            - ValueError: If the length of ids and documents don\\'t match.\\n            - ValueError: If the length of ids and metadatas don\\'t match.\\n            - ValueError: If the length of ids, metadatas, and documents don\\'t match.\\n\\n        Notes:\\n            - As of now, ChromaDB doesn\\'t raise an exception if you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata and documents for specific ids\\n            ids_to_update = [\\'id1\\', \\'id2\\']\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\n            document_updates = [\"new document 1\", \"new document 2\"]\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\n            ```\\n        \"\"\"\\n\\n        if not metadatas and not documents:\\n            raise ValueError(\"You must provide either metadatas or documents.\")\\n        if not metadatas and documents:\\n            if len(ids) != len(documents):\\n                raise ValueError(\"The length of ids and documents must match.\")\\n        if metadatas and not documents:\\n            if len(ids) != len(metadatas):\\n                raise ValueError(\"The length of ids and metadatas must match.\")\\n        if metadatas and documents:\\n            if len(ids) != len(metadatas) != len(documents):\\n                raise ValueError(\\n                    \"The length of ids, metadatas, and documents must match.\"\\n                )\\n        for index, id in enumerate(ids):\\n            if not self.collection.get(id):\\n                logging.error(\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\n                )\\n                ids.pop(index)\\n                if metadatas:\\n                    popped_metadata = metadatas.pop(index)\\n                    if popped_metadata:\\n                        logging.warning(\\n                            f\"Removing metadata at index {index} from update.\"\\n                        )\\n                if documents:\\n                    popped_document = documents.pop(index)\\n                    if popped_document:\\n                        logging.warning(\\n                            f\"Removing document at index {index} from update.\"\\n                        )\\n\\n        if not ids:\\n            logging.warning(\"All updates failed.\")\\n            return None\\n        else:\\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\n\\n    def upsert_documents(\\n        self,\\n        ids: list[str],\\n        documents: list[str],\\n        metadatas: list[Mapping[str, str | int | float | bool]],\\n        # embeddings: list[chroma_types.Embedding],\\n    ) -> None:\\n        \"\"\"\\n        Inserts or updates documents in the collection, based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\n            - documents (list[str]): List of documents corresponding to the ids.\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\'t match.\\n\\n        Examples:\\n            ```Python\\n            # Upsert documents in the collection\\n            ids = [\\'id1\\', \\'id2\\']\\n            documents = [\\'doc1\\', \\'doc2\\']\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\n\\n            # Upsert documents in the collection\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\n            ```\\n        \"\"\"\\n\\n        if len(ids) != len(documents) != len(metadatas):\\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\n        self.collection.upsert(\\n            ids=ids,\\n            # embeddings=embeddings,\\n            metadatas=metadatas,\\n            documents=documents,\\n        )\\n\\n    def delete_embeddings(self, ids: list[str]) -> None:\\n        \"\"\"\\n        Deletes embeddings from the collection based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\n\\n        Examples:\\n            ```Python\\n            # Delete specific embeddings by ids\\n            ids_to_delete = [\\'id1\\', \\'id2\\']\\n            collection_manager.delete_embeddings(ids_to_delete)\\n            ```\\n        \"\"\"\\n\\n        ids_to_delete: list[str] = ids.copy()\\n        for index, id in enumerate(ids_to_delete):\\n            if not self.collection.get(id):\\n                logging.error(\\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\\n                )\\n                ids_to_delete.pop(index)\\n\\n        if not ids_to_delete:\\n            logging.warning(\"No IDs given were in the database.\")\\n            return None\\n\\n        logging.info(\\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\n        )\\n        self.collection.delete(ids_to_delete)\\n\\n```\\n\\nCHILDREN_SUMMARIES:\\n\\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef __init__(self, collection: chroma_types.Collection) -> None:\\\\n    self.collection: chroma_types.Collection = collection\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef collection_embedding_count(self) -> int:\\\\n    \"\"\"\\\\n        Gets the total number of embeddings in the collection.\\\\n\\\\n        Returns:\\\\n            - embedding_count (int): The total number of embeddings in the collection.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    embedding_count: int = self.collection.count()\\\\n    logging.info(\\\\n        f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\\\n    )\\\\n\\\\n    return embedding_count\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef add_embeddings(\\\\n    self,\\\\n    ids: list[str],\\\\n    documents: list[str],\\\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\\\n) -> None:\\\\n    \"\"\"\\\\n        Adds embeddings to the collection.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): A list of ids to add to the collection.\\\\n            - documents (list[str]): A list of documents to add to the collection.\\\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\\\n\\\\n        Raises:\\\\n            - ValueError - If you don\\\\\\'t provide either embeddings or documents.\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\'t match.\\\\n            - ValueError - If you provide an id that already exists.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # define the ids, metadatas, and documents to add to the collection\\\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\\\n            metadatas: list[dict[str, Any]] = [\\\\n                {\"my_metadata\": \"my_metadata_value\"},\\\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\\\n            ]\\\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\\\n\\\\n            # add the embeddings to the collection\\\\n            collection_manager.add_embeddings(id, metadatas, documents)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    if not len(ids) == len(documents) == len(metadatas):\\\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\n\\\\n    try:\\\\n        logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\\\n        self.collection.add(ids, documents=documents, metadatas=metadatas)\\\\n    except Exception as exception:\\\\n        raise exception\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef get_embeddings(\\\\n    self,\\\\n    ids: list[str] | None,\\\\n    *,\\\\n    where_filter: chroma_types.Where | None = None,\\\\n    limit: int | None = None,\\\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\n) -> chroma_types.GetResult | None:\\\\n    \"\"\"\\\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): A list of ids to get from the collection.\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\n            - limit (int | None): The maximum number of results to return.\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\n\\\\n        Returns:\\\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\\\n                - ids: list[str]\\\\n                - embeddings: list[Embedding] | None\\\\n                - documents: list[str] | None\\\\n                - uris: chroma_types.URIs | None\\\\n                - data: chroma_types.Loadable | None\\\\n                - metadatas: list[chroma_types.Metadata]]\\\\n\\\\n        Raises:\\\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\\\\\'t match.\\\\n            - ValueError: If you provide an id that doesn\\\\\\'t exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            import postcode.types.chromadb.types as chroma_types\\\\n\\\\n            # define the ids, filters to use to get embeddings from the collection\\\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\\\n\\\\n            # define the data to return from the collection\\\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\\\n\\\\n            # get the embeddings from the collection\\\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\\\n                ids,\\\\n                where_filter=where_filter,\\\\n                where_document_filter=where_document_filter,\\\\n                include_in_result=include_in_result\\\\n                )\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    try:\\\\n        logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\\\n        return self.collection.get(\\\\n            ids,\\\\n            where=where_filter,\\\\n            limit=limit,\\\\n            where_document=where_document_filter,\\\\n            include=include_in_result,\\\\n        )\\\\n    except Exception as exception:\\\\n        raise exception\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef query_collection(\\\\n    self,\\\\n    queries: list[str],\\\\n    n_results: int = 10,\\\\n    where_filter: chroma_types.Where | None = None,\\\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\\\n) -> chroma_types.QueryResult | None:\\\\n    \"\"\"\\\\n        Queries and returns the `n` nearest neighbors from the collection.\\\\n\\\\n        Args:\\\\n            - queries (list[str]): A list of queries to search the collection for.\\\\n            - n_results (int): The number of results to return.\\\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\\\n                - e.g. `{$contains: \"binary search\"}`\\\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\\\n\\\\n        Returns:\\\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\\\n                `include_in_result` parameter:\\\\n                - ids: list[str] # The ids are always returned.\\\\n                - embeddings: List[list[Embedding]] | None\\\\n                - documents: list[list[str]]] | None\\\\n                - uris: list[list[URI]]] | None\\\\n                - data: list[Loadable] | None\\\\n                - metadatas: list[list[Metadata]] | None\\\\n                - distances: list[list[float]] | None\\\\n\\\\n        Raises:\\\\n            - ValueError: If you don\\\\\\'t provide query_texts.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            import postcode.types.chromadb.types as chroma\\\\n\\\\n            # define the queries and filters used to search the collection\\\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\\\n\\\\n            # define the data to return from the collection\\\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\\\n\\\\n            # query the collection and return the results from the collection\\\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\\\n                queries,\\\\n                where_filter=where_filter,\\\\n                include_in_result=include_in_result\\\\n                )\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    try:\\\\n        logging.info(f\"Querying collection {self.collection.name}\")\\\\n\\\\n        if results := self.collection.query(\\\\n            query_texts=queries,\\\\n            n_results=n_results,\\\\n            where=where_filter,\\\\n            where_document=where_document_filter,\\\\n            include=include_in_result,\\\\n        ):\\\\n            logging.info(\\\\n                f\"Got {len(results)} results from collection {self.collection.name}.\"\\\\n            )\\\\n            return results\\\\n        else:\\\\n            logging.warning(\\\\n                f\"No results found from collection {self.collection.name}.\"\\\\n            )\\\\n\\\\n    except Exception as exception:\\\\n        raise exception\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef modify_collection_name(self, name: str) -> None:\\\\n    \"\"\"\\\\n        Modifies the name of the collection managed by this class.\\\\n\\\\n        Args:\\\\n            - name (str): The new name to assign to the collection.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Rename the collection to \\\\\\'new_collection_name\\\\\\'\\\\n            collection_manager.modify_collection_name(\\\\\\'new_collection_name\\\\\\')\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    self.collection.modify(name=name)\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef modify_collection_metadata(\\\\n    self, metadata: dict[str, Any] | None = None\\\\n) -> None:\\\\n    \"\"\"\\\\n        Modifies the metadata of the collection managed by this class.\\\\n\\\\n        Args:\\\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Update metadata of the collection\\\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\\\n            collection_manager.modify_collection_metadata(new_metadata)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    self.collection.modify(metadata=metadata)\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef update_metadata_or_documents_by_ids(\\\\n    self,\\\\n    ids: list[str],\\\\n    metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\\\n    documents: list[str] | None = None,\\\\n) -> None:\\\\n    \"\"\"\\\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids of the entries to be updated.\\\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\\\n\\\\n        Raises:\\\\n            - ValueError: If neither metadatas nor documents are provided.\\\\n            - ValueError: If the length of ids and documents don\\\\\\'t match.\\\\n            - ValueError: If the length of ids and metadatas don\\\\\\'t match.\\\\n            - ValueError: If the length of ids, metadatas, and documents don\\\\\\'t match.\\\\n\\\\n        Notes:\\\\n            - As of now, ChromaDB doesn\\\\\\'t raise an exception if you provide an id that doesn\\\\\\'t exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Update metadata and documents for specific ids\\\\n            ids_to_update = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\\\n            document_updates = [\"new document 1\", \"new document 2\"]\\\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    if not metadatas and not documents:\\\\n        raise ValueError(\"You must provide either metadatas or documents.\")\\\\n    if not metadatas and documents:\\\\n        if len(ids) != len(documents):\\\\n            raise ValueError(\"The length of ids and documents must match.\")\\\\n    if metadatas and not documents:\\\\n        if len(ids) != len(metadatas):\\\\n            raise ValueError(\"The length of ids and metadatas must match.\")\\\\n    if metadatas and documents:\\\\n        if len(ids) != len(metadatas) != len(documents):\\\\n            raise ValueError(\\\\n                \"The length of ids, metadatas, and documents must match.\"\\\\n            )\\\\n    for index, id in enumerate(ids):\\\\n        if not self.collection.get(id):\\\\n            logging.error(\\\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\n            )\\\\n            ids.pop(index)\\\\n            if metadatas:\\\\n                popped_metadata = metadatas.pop(index)\\\\n                if popped_metadata:\\\\n                    logging.warning(\\\\n                        f\"Removing metadata at index {index} from update.\"\\\\n                    )\\\\n            if documents:\\\\n                popped_document = documents.pop(index)\\\\n                if popped_document:\\\\n                    logging.warning(\\\\n                        f\"Removing document at index {index} from update.\"\\\\n                    )\\\\n\\\\n    if not ids:\\\\n        logging.warning(\"All updates failed.\")\\\\n        return None\\\\n    else:\\\\n        logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\\\n        self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef upsert_documents(\\\\n    self,\\\\n    ids: list[str],\\\\n    documents: list[str],\\\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\\\n    # embeddings: list[chroma_types.Embedding],\\\\n) -> None:\\\\n    \"\"\"\\\\n        Inserts or updates documents in the collection, based on the provided ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\\\n            - documents (list[str]): List of documents corresponding to the ids.\\\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\\\n\\\\n        Raises:\\\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\\\\\'t match.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Upsert documents in the collection\\\\n            ids = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            documents = [\\\\\\'doc1\\\\\\', \\\\\\'doc2\\\\\\']\\\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\\\n\\\\n            # Upsert documents in the collection\\\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    if len(ids) != len(documents) != len(metadatas):\\\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\\\n\\\\n    logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\\\n    self.collection.upsert(\\\\n        ids=ids,\\\\n        # embeddings=embeddings,\\\\n        metadatas=metadatas,\\\\n        documents=documents,\\\\n    )\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef delete_embeddings(self, ids: list[str]) -> None:\\\\n    \"\"\"\\\\n        Deletes embeddings from the collection based on the provided ids.\\\\n\\\\n        Args:\\\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            # Delete specific embeddings by ids\\\\n            ids_to_delete = [\\\\\\'id1\\\\\\', \\\\\\'id2\\\\\\']\\\\n            collection_manager.delete_embeddings(ids_to_delete)\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    ids_to_delete: list[str] = ids.copy()\\\\n    for index, id in enumerate(ids_to_delete):\\\\n        if not self.collection.get(id):\\\\n            logging.error(\\\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\\\n            )\\\\n            ids_to_delete.pop(index)\\\\n\\\\n    if not ids_to_delete:\\\\n        logging.warning(\"No IDs given were in the database.\")\\\\n        return None\\\\n\\\\n    logging.info(\\\\n        f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\\\n    )\\\\n    self.collection.delete(ids_to_delete)\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nfrom typing import Any, Mapping\\nfrom typing import Any, Mapping\\nimport postcode.types.chroma as chroma_types\\nimport postcode.types.chroma as chroma_types\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": [
                {
                    "function_name": "__init__",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-__init__",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 42,
                    "end_line_num": 45,
                    "code_content": "\ndef __init__(self, collection: chroma_types.Collection) -> None:\n    self.collection: chroma_types.Collection = collection\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef __init__(self, collection: chroma_types.Collection) -> None:\\n    self.collection: chroma_types.Collection = collection\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "collection_embedding_count",
                    "docstring": "Gets the total number of embeddings in the collection.\n\nReturns:\n    - embedding_count (int): The total number of embeddings in the collection.\n\nExamples:\n    ```Python\n    embedding_count: int = collection_manager.get_collection_embedding_count()\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "int",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-collection_embedding_count",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 45,
                    "end_line_num": 65,
                    "code_content": "\ndef collection_embedding_count(self) -> int:\n    \"\"\"\n        Gets the total number of embeddings in the collection.\n\n        Returns:\n            - embedding_count (int): The total number of embeddings in the collection.\n\n        Examples:\n            ```Python\n            embedding_count: int = collection_manager.get_collection_embedding_count()\n            ```\n        \"\"\"\n\n    embedding_count: int = self.collection.count()\n    logging.info(\n        f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\n    )\n\n    return embedding_count\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef collection_embedding_count(self) -> int:\\n    \"\"\"\\n        Gets the total number of embeddings in the collection.\\n\\n        Returns:\\n            - embedding_count (int): The total number of embeddings in the collection.\\n\\n        Examples:\\n            ```Python\\n            embedding_count: int = collection_manager.get_collection_embedding_count()\\n            ```\\n        \"\"\"\\n\\n    embedding_count: int = self.collection.count()\\n    logging.info(\\n        f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\\n    )\\n\\n    return embedding_count\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "add_embeddings",
                    "docstring": "Adds embeddings to the collection.\n\nArgs:\n    - ids (list[str]): A list of ids to add to the collection.\n    - documents (list[str]): A list of documents to add to the collection.\n    - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\nRaises:\n    - ValueError - If you don't provide either embeddings or documents.\n    - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n    - ValueError - If you provide an id that already exists.\n\nExamples:\n    ```Python\n    # define the ids, metadatas, and documents to add to the collection\n    id: list[str] = [\"my_id\", \"my_id2\"]\n    metadatas: list[dict[str, Any]] = [\n        {\"my_metadata\": \"my_metadata_value\"},\n        {\"my_metadata2\": \"my_metadata_value2\"},\n    ]\n    documents: list[str] = [\"my_document\", \"my_document2\"]\n\n    # add the embeddings to the collection\n    collection_manager.add_embeddings(id, metadatas, documents)\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-add_embeddings",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 65,
                    "end_line_num": 108,
                    "code_content": "\ndef add_embeddings(\n    self,\n    ids: list[str],\n    documents: list[str],\n    metadatas: list[Mapping[str, str | int | float | bool]],\n) -> None:\n    \"\"\"\n        Adds embeddings to the collection.\n\n        Args:\n            - ids (list[str]): A list of ids to add to the collection.\n            - documents (list[str]): A list of documents to add to the collection.\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\n        Raises:\n            - ValueError - If you don't provide either embeddings or documents.\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError - If you provide an id that already exists.\n\n        Examples:\n            ```Python\n            # define the ids, metadatas, and documents to add to the collection\n            id: list[str] = [\"my_id\", \"my_id2\"]\n            metadatas: list[dict[str, Any]] = [\n                {\"my_metadata\": \"my_metadata_value\"},\n                {\"my_metadata2\": \"my_metadata_value2\"},\n            ]\n            documents: list[str] = [\"my_document\", \"my_document2\"]\n\n            # add the embeddings to the collection\n            collection_manager.add_embeddings(id, metadatas, documents)\n            ```\n        \"\"\"\n\n    if not len(ids) == len(documents) == len(metadatas):\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n    try:\n        logging.info(f\"Adding embeddings to collection {self.collection.name}\")\n        self.collection.add(ids, documents=documents, metadatas=metadatas)\n    except Exception as exception:\n        raise exception\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef add_embeddings(\\n    self,\\n    ids: list[str],\\n    documents: list[str],\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\n) -> None:\\n    \"\"\"\\n        Adds embeddings to the collection.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to add to the collection.\\n            - documents (list[str]): A list of documents to add to the collection.\\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\\n\\n        Raises:\\n            - ValueError - If you don\\'t provide either embeddings or documents.\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError - If you provide an id that already exists.\\n\\n        Examples:\\n            ```Python\\n            # define the ids, metadatas, and documents to add to the collection\\n            id: list[str] = [\"my_id\", \"my_id2\"]\\n            metadatas: list[dict[str, Any]] = [\\n                {\"my_metadata\": \"my_metadata_value\"},\\n                {\"my_metadata2\": \"my_metadata_value2\"},\\n            ]\\n            documents: list[str] = [\"my_document\", \"my_document2\"]\\n\\n            # add the embeddings to the collection\\n            collection_manager.add_embeddings(id, metadatas, documents)\\n            ```\\n        \"\"\"\\n\\n    if not len(ids) == len(documents) == len(metadatas):\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n    try:\\n        logging.info(f\"Adding embeddings to collection {self.collection.name}\")\\n        self.collection.add(ids, documents=documents, metadatas=metadatas)\\n    except Exception as exception:\\n        raise exception\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "get_embeddings",
                    "docstring": "Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\nArgs:\n    - ids (list[str]): A list of ids to get from the collection.\n    - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n    - limit (int | None): The maximum number of results to return.\n    - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n        e.g. `{$contains: {\"text\": \"hello\"}}`\n    - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\nReturns:\n    - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n        - ids: list[str]\n        - embeddings: list[Embedding] | None\n        - documents: list[str] | None\n        - uris: chroma_types.URIs | None\n        - data: chroma_types.Loadable | None\n        - metadatas: list[chroma_types.Metadata]]\n\nRaises:\n    - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n    - ValueError: If you provide an id that doesn't exist.\n\nExamples:\n    ```Python\n    import postcode.types.chromadb.types as chroma_types\n\n    # define the ids, filters to use to get embeddings from the collection\n    ids: list[str] = [\"my_id\", \"my_id2\"]\n    where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n    where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n    # define the data to return from the collection\n    include_in_result: chroma_types.Include = [\"metadatas\"]\n\n    # get the embeddings from the collection\n    embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n        ids,\n        where_filter=where_filter,\n        where_document_filter=where_document_filter,\n        include_in_result=include_in_result\n        )\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": " | None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-get_embeddings",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 108,
                    "end_line_num": 175,
                    "code_content": "\ndef get_embeddings(\n    self,\n    ids: list[str] | None,\n    *,\n    where_filter: chroma_types.Where | None = None,\n    limit: int | None = None,\n    where_document_filter: chroma_types.WhereDocument | None = None,\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n) -> chroma_types.GetResult | None:\n    \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n    try:\n        logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n        return self.collection.get(\n            ids,\n            where=where_filter,\n            limit=limit,\n            where_document=where_document_filter,\n            include=include_in_result,\n        )\n    except Exception as exception:\n        raise exception\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef get_embeddings(\\n    self,\\n    ids: list[str] | None,\\n    *,\\n    where_filter: chroma_types.Where | None = None,\\n    limit: int | None = None,\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n) -> chroma_types.GetResult | None:\\n    \"\"\"\\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\\n\\n        Args:\\n            - ids (list[str]): A list of ids to get from the collection.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n            - limit (int | None): The maximum number of results to return.\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                e.g. `{$contains: {\"text\": \"hello\"}}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\\n                - ids: list[str]\\n                - embeddings: list[Embedding] | None\\n                - documents: list[str] | None\\n                - uris: chroma_types.URIs | None\\n                - data: chroma_types.Loadable | None\\n                - metadatas: list[chroma_types.Metadata]]\\n\\n        Raises:\\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don\\'t match.\\n            - ValueError: If you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            # define the ids, filters to use to get embeddings from the collection\\n            ids: list[str] = [\"my_id\", \"my_id2\"]\\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\"]\\n\\n            # get the embeddings from the collection\\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\\n                ids,\\n                where_filter=where_filter,\\n                where_document_filter=where_document_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n    try:\\n        logging.info(f\"Getting embeddings from collection {self.collection.name}\")\\n        return self.collection.get(\\n            ids,\\n            where=where_filter,\\n            limit=limit,\\n            where_document=where_document_filter,\\n            include=include_in_result,\\n        )\\n    except Exception as exception:\\n        raise exception\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "query_collection",
                    "docstring": "Queries and returns the `n` nearest neighbors from the collection.\n\nArgs:\n    - queries (list[str]): A list of queries to search the collection for.\n    - n_results (int): The number of results to return.\n    - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n        - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n    - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n        - e.g. `{$contains: \"binary search\"}`\n    - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\nReturns:\n    - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n        `include_in_result` parameter:\n        - ids: list[str] # The ids are always returned.\n        - embeddings: List[list[Embedding]] | None\n        - documents: list[list[str]]] | None\n        - uris: list[list[URI]]] | None\n        - data: list[Loadable] | None\n        - metadatas: list[list[Metadata]] | None\n        - distances: list[list[float]] | None\n\nRaises:\n    - ValueError: If you don't provide query_texts.\n\nExamples:\n    ```Python\n    import postcode.types.chromadb.types as chroma\n\n    # define the queries and filters used to search the collection\n    queries: list[str] = [\"binary search\", \"linear search\"]\n    where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n    # define the data to return from the collection\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n    # query the collection and return the results from the collection\n    results: chroma_types.QueryResult = collection_manager.query_collection(\n        queries,\n        where_filter=where_filter,\n        include_in_result=include_in_result\n        )\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": " | None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-query_collection",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 175,
                    "end_line_num": 251,
                    "code_content": "\ndef query_collection(\n    self,\n    queries: list[str],\n    n_results: int = 10,\n    where_filter: chroma_types.Where | None = None,\n    where_document_filter: chroma_types.WhereDocument | None = None,\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n) -> chroma_types.QueryResult | None:\n    \"\"\"\n        Queries and returns the `n` nearest neighbors from the collection.\n\n        Args:\n            - queries (list[str]): A list of queries to search the collection for.\n            - n_results (int): The number of results to return.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                - e.g. `{$contains: \"binary search\"}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n                `include_in_result` parameter:\n                - ids: list[str] # The ids are always returned.\n                - embeddings: List[list[Embedding]] | None\n                - documents: list[list[str]]] | None\n                - uris: list[list[URI]]] | None\n                - data: list[Loadable] | None\n                - metadatas: list[list[Metadata]] | None\n                - distances: list[list[float]] | None\n\n        Raises:\n            - ValueError: If you don't provide query_texts.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma\n\n            # define the queries and filters used to search the collection\n            queries: list[str] = [\"binary search\", \"linear search\"]\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n            # query the collection and return the results from the collection\n            results: chroma_types.QueryResult = collection_manager.query_collection(\n                queries,\n                where_filter=where_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n    try:\n        logging.info(f\"Querying collection {self.collection.name}\")\n\n        if results := self.collection.query(\n            query_texts=queries,\n            n_results=n_results,\n            where=where_filter,\n            where_document=where_document_filter,\n            include=include_in_result,\n        ):\n            logging.info(\n                f\"Got {len(results)} results from collection {self.collection.name}.\"\n            )\n            return results\n        else:\n            logging.warning(\n                f\"No results found from collection {self.collection.name}.\"\n            )\n\n    except Exception as exception:\n        raise exception\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef query_collection(\\n    self,\\n    queries: list[str],\\n    n_results: int = 10,\\n    where_filter: chroma_types.Where | None = None,\\n    where_document_filter: chroma_types.WhereDocument | None = None,\\n    include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\\n) -> chroma_types.QueryResult | None:\\n    \"\"\"\\n        Queries and returns the `n` nearest neighbors from the collection.\\n\\n        Args:\\n            - queries (list[str]): A list of queries to search the collection for.\\n            - n_results (int): The number of results to return.\\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\\n                - e.g. `{$contains: \"binary search\"}`\\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\\n\\n        Returns:\\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\\n                `include_in_result` parameter:\\n                - ids: list[str] # The ids are always returned.\\n                - embeddings: List[list[Embedding]] | None\\n                - documents: list[list[str]]] | None\\n                - uris: list[list[URI]]] | None\\n                - data: list[Loadable] | None\\n                - metadatas: list[list[Metadata]] | None\\n                - distances: list[list[float]] | None\\n\\n        Raises:\\n            - ValueError: If you don\\'t provide query_texts.\\n\\n        Examples:\\n            ```Python\\n            import postcode.types.chromadb.types as chroma\\n\\n            # define the queries and filters used to search the collection\\n            queries: list[str] = [\"binary search\", \"linear search\"]\\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\\n\\n            # define the data to return from the collection\\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\\n\\n            # query the collection and return the results from the collection\\n            results: chroma_types.QueryResult = collection_manager.query_collection(\\n                queries,\\n                where_filter=where_filter,\\n                include_in_result=include_in_result\\n                )\\n            ```\\n        \"\"\"\\n\\n    try:\\n        logging.info(f\"Querying collection {self.collection.name}\")\\n\\n        if results := self.collection.query(\\n            query_texts=queries,\\n            n_results=n_results,\\n            where=where_filter,\\n            where_document=where_document_filter,\\n            include=include_in_result,\\n        ):\\n            logging.info(\\n                f\"Got {len(results)} results from collection {self.collection.name}.\"\\n            )\\n            return results\\n        else:\\n            logging.warning(\\n                f\"No results found from collection {self.collection.name}.\"\\n            )\\n\\n    except Exception as exception:\\n        raise exception\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "modify_collection_name",
                    "docstring": "Modifies the name of the collection managed by this class.\n\nArgs:\n    - name (str): The new name to assign to the collection.\n\nExamples:\n    ```Python\n    # Rename the collection to 'new_collection_name'\n    collection_manager.modify_collection_name('new_collection_name')\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-modify_collection_name",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 251,
                    "end_line_num": 267,
                    "code_content": "\ndef modify_collection_name(self, name: str) -> None:\n    \"\"\"\n        Modifies the name of the collection managed by this class.\n\n        Args:\n            - name (str): The new name to assign to the collection.\n\n        Examples:\n            ```Python\n            # Rename the collection to 'new_collection_name'\n            collection_manager.modify_collection_name('new_collection_name')\n            ```\n        \"\"\"\n\n    self.collection.modify(name=name)\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef modify_collection_name(self, name: str) -> None:\\n    \"\"\"\\n        Modifies the name of the collection managed by this class.\\n\\n        Args:\\n            - name (str): The new name to assign to the collection.\\n\\n        Examples:\\n            ```Python\\n            # Rename the collection to \\'new_collection_name\\'\\n            collection_manager.modify_collection_name(\\'new_collection_name\\')\\n            ```\\n        \"\"\"\\n\\n    self.collection.modify(name=name)\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "modify_collection_metadata",
                    "docstring": "Modifies the metadata of the collection managed by this class.\n\nArgs:\n    - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\nExamples:\n    ```Python\n    # Update metadata of the collection\n    new_metadata = {\"description\": \"Updated collection metadata\"}\n    collection_manager.modify_collection_metadata(new_metadata)\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-modify_collection_metadata",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 267,
                    "end_line_num": 286,
                    "code_content": "\ndef modify_collection_metadata(\n    self, metadata: dict[str, Any] | None = None\n) -> None:\n    \"\"\"\n        Modifies the metadata of the collection managed by this class.\n\n        Args:\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\n        Examples:\n            ```Python\n            # Update metadata of the collection\n            new_metadata = {\"description\": \"Updated collection metadata\"}\n            collection_manager.modify_collection_metadata(new_metadata)\n            ```\n        \"\"\"\n\n    self.collection.modify(metadata=metadata)\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef modify_collection_metadata(\\n    self, metadata: dict[str, Any] | None = None\\n) -> None:\\n    \"\"\"\\n        Modifies the metadata of the collection managed by this class.\\n\\n        Args:\\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata of the collection\\n            new_metadata = {\"description\": \"Updated collection metadata\"}\\n            collection_manager.modify_collection_metadata(new_metadata)\\n            ```\\n        \"\"\"\\n\\n    self.collection.modify(metadata=metadata)\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "update_metadata_or_documents_by_ids",
                    "docstring": "Updates the metadata or documents of specific entries in the collection by their ids.\n\nArgs:\n    - ids (list[str]): List of ids of the entries to be updated.\n    - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n    - documents (list[str] | None): List of document updates corresponding to the ids.\n\nRaises:\n    - ValueError: If neither metadatas nor documents are provided.\n    - ValueError: If the length of ids and documents don't match.\n    - ValueError: If the length of ids and metadatas don't match.\n    - ValueError: If the length of ids, metadatas, and documents don't match.\n\nNotes:\n    - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\nExamples:\n    ```Python\n    # Update metadata and documents for specific ids\n    ids_to_update = ['id1', 'id2']\n    metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n    document_updates = [\"new document 1\", \"new document 2\"]\n    collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-update_metadata_or_documents_by_ids",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 286,
                    "end_line_num": 358,
                    "code_content": "\ndef update_metadata_or_documents_by_ids(\n    self,\n    ids: list[str],\n    metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\n    documents: list[str] | None = None,\n) -> None:\n    \"\"\"\n        Updates the metadata or documents of specific entries in the collection by their ids.\n\n        Args:\n            - ids (list[str]): List of ids of the entries to be updated.\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n            - documents (list[str] | None): List of document updates corresponding to the ids.\n\n        Raises:\n            - ValueError: If neither metadatas nor documents are provided.\n            - ValueError: If the length of ids and documents don't match.\n            - ValueError: If the length of ids and metadatas don't match.\n            - ValueError: If the length of ids, metadatas, and documents don't match.\n\n        Notes:\n            - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            # Update metadata and documents for specific ids\n            ids_to_update = ['id1', 'id2']\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n            document_updates = [\"new document 1\", \"new document 2\"]\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n            ```\n        \"\"\"\n\n    if not metadatas and not documents:\n        raise ValueError(\"You must provide either metadatas or documents.\")\n    if not metadatas and documents:\n        if len(ids) != len(documents):\n            raise ValueError(\"The length of ids and documents must match.\")\n    if metadatas and not documents:\n        if len(ids) != len(metadatas):\n            raise ValueError(\"The length of ids and metadatas must match.\")\n    if metadatas and documents:\n        if len(ids) != len(metadatas) != len(documents):\n            raise ValueError(\n                \"The length of ids, metadatas, and documents must match.\"\n            )\n    for index, id in enumerate(ids):\n        if not self.collection.get(id):\n            logging.error(\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\n            )\n            ids.pop(index)\n            if metadatas:\n                popped_metadata = metadatas.pop(index)\n                if popped_metadata:\n                    logging.warning(\n                        f\"Removing metadata at index {index} from update.\"\n                    )\n            if documents:\n                popped_document = documents.pop(index)\n                if popped_document:\n                    logging.warning(\n                        f\"Removing document at index {index} from update.\"\n                    )\n\n    if not ids:\n        logging.warning(\"All updates failed.\")\n        return None\n    else:\n        logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\n        self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef update_metadata_or_documents_by_ids(\\n    self,\\n    ids: list[str],\\n    metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\\n    documents: list[str] | None = None,\\n) -> None:\\n    \"\"\"\\n        Updates the metadata or documents of specific entries in the collection by their ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids of the entries to be updated.\\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\\n            - documents (list[str] | None): List of document updates corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If neither metadatas nor documents are provided.\\n            - ValueError: If the length of ids and documents don\\'t match.\\n            - ValueError: If the length of ids and metadatas don\\'t match.\\n            - ValueError: If the length of ids, metadatas, and documents don\\'t match.\\n\\n        Notes:\\n            - As of now, ChromaDB doesn\\'t raise an exception if you provide an id that doesn\\'t exist.\\n\\n        Examples:\\n            ```Python\\n            # Update metadata and documents for specific ids\\n            ids_to_update = [\\'id1\\', \\'id2\\']\\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\\n            document_updates = [\"new document 1\", \"new document 2\"]\\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\\n            ```\\n        \"\"\"\\n\\n    if not metadatas and not documents:\\n        raise ValueError(\"You must provide either metadatas or documents.\")\\n    if not metadatas and documents:\\n        if len(ids) != len(documents):\\n            raise ValueError(\"The length of ids and documents must match.\")\\n    if metadatas and not documents:\\n        if len(ids) != len(metadatas):\\n            raise ValueError(\"The length of ids and metadatas must match.\")\\n    if metadatas and documents:\\n        if len(ids) != len(metadatas) != len(documents):\\n            raise ValueError(\\n                \"The length of ids, metadatas, and documents must match.\"\\n            )\\n    for index, id in enumerate(ids):\\n        if not self.collection.get(id):\\n            logging.error(\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\n            )\\n            ids.pop(index)\\n            if metadatas:\\n                popped_metadata = metadatas.pop(index)\\n                if popped_metadata:\\n                    logging.warning(\\n                        f\"Removing metadata at index {index} from update.\"\\n                    )\\n            if documents:\\n                popped_document = documents.pop(index)\\n                if popped_document:\\n                    logging.warning(\\n                        f\"Removing document at index {index} from update.\"\\n                    )\\n\\n    if not ids:\\n        logging.warning(\"All updates failed.\")\\n        return None\\n    else:\\n        logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\\n        self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "upsert_documents",
                    "docstring": "Inserts or updates documents in the collection, based on the provided ids.\n\nArgs:\n    - ids (list[str]): List of ids for the documents to be inserted or updated.\n    - documents (list[str]): List of documents corresponding to the ids.\n    - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\nRaises:\n    - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\nExamples:\n    ```Python\n    # Upsert documents in the collection\n    ids = ['id1', 'id2']\n    documents = ['doc1', 'doc2']\n    metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n    # Upsert documents in the collection\n    collection_manager.upsert_documents(ids, documents, metadatas)\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-upsert_documents",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 358,
                    "end_line_num": 399,
                    "code_content": "\ndef upsert_documents(\n    self,\n    ids: list[str],\n    documents: list[str],\n    metadatas: list[Mapping[str, str | int | float | bool]],\n    # embeddings: list[chroma_types.Embedding],\n) -> None:\n    \"\"\"\n        Inserts or updates documents in the collection, based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\n            - documents (list[str]): List of documents corresponding to the ids.\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\n        Raises:\n            - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\n        Examples:\n            ```Python\n            # Upsert documents in the collection\n            ids = ['id1', 'id2']\n            documents = ['doc1', 'doc2']\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n            # Upsert documents in the collection\n            collection_manager.upsert_documents(ids, documents, metadatas)\n            ```\n        \"\"\"\n\n    if len(ids) != len(documents) != len(metadatas):\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n    logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\n    self.collection.upsert(\n        ids=ids,\n        # embeddings=embeddings,\n        metadatas=metadatas,\n        documents=documents,\n    )\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef upsert_documents(\\n    self,\\n    ids: list[str],\\n    documents: list[str],\\n    metadatas: list[Mapping[str, str | int | float | bool]],\\n    # embeddings: list[chroma_types.Embedding],\\n) -> None:\\n    \"\"\"\\n        Inserts or updates documents in the collection, based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\\n            - documents (list[str]): List of documents corresponding to the ids.\\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\\n\\n        Raises:\\n            - ValueError: If the lengths of ids, documents, and metadatas don\\'t match.\\n\\n        Examples:\\n            ```Python\\n            # Upsert documents in the collection\\n            ids = [\\'id1\\', \\'id2\\']\\n            documents = [\\'doc1\\', \\'doc2\\']\\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\\n\\n            # Upsert documents in the collection\\n            collection_manager.upsert_documents(ids, documents, metadatas)\\n            ```\\n        \"\"\"\\n\\n    if len(ids) != len(documents) != len(metadatas):\\n        raise ValueError(\"The length of ids, documents, and metadatas must match.\")\\n\\n    logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\\n    self.collection.upsert(\\n        ids=ids,\\n        # embeddings=embeddings,\\n        metadatas=metadatas,\\n        documents=documents,\\n    )\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "delete_embeddings",
                    "docstring": "Deletes embeddings from the collection based on the provided ids.\n\nArgs:\n    - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\nExamples:\n    ```Python\n    # Delete specific embeddings by ids\n    ids_to_delete = ['id1', 'id2']\n    collection_manager.delete_embeddings(ids_to_delete)\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager__*__FUNCTION-delete_embeddings",
                    "parent_id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaDBCollectionManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 399,
                    "end_line_num": 431,
                    "code_content": "\ndef delete_embeddings(self, ids: list[str]) -> None:\n    \"\"\"\n        Deletes embeddings from the collection based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\n        Examples:\n            ```Python\n            # Delete specific embeddings by ids\n            ids_to_delete = ['id1', 'id2']\n            collection_manager.delete_embeddings(ids_to_delete)\n            ```\n        \"\"\"\n\n    ids_to_delete: list[str] = ids.copy()\n    for index, id in enumerate(ids_to_delete):\n        if not self.collection.get(id):\n            logging.error(\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\n            )\n            ids_to_delete.pop(index)\n\n    if not ids_to_delete:\n        logging.warning(\"No IDs given were in the database.\")\n        return None\n\n    logging.info(\n        f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\n    )\n    self.collection.delete(ids_to_delete)\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef delete_embeddings(self, ids: list[str]) -> None:\\n    \"\"\"\\n        Deletes embeddings from the collection based on the provided ids.\\n\\n        Args:\\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\\n\\n        Examples:\\n            ```Python\\n            # Delete specific embeddings by ids\\n            ids_to_delete = [\\'id1\\', \\'id2\\']\\n            collection_manager.delete_embeddings(ids_to_delete)\\n            ```\\n        \"\"\"\\n\\n    ids_to_delete: list[str] = ids.copy()\\n    for index, id in enumerate(ids_to_delete):\\n        if not self.collection.get(id):\\n            logging.error(\\n                f\"Id {id} does not exist in collection {self.collection.name}.\"\\n            )\\n            ids_to_delete.pop(index)\\n\\n    if not ids_to_delete:\\n        logging.warning(\"No IDs given were in the database.\")\\n        return None\\n\\n    logging.info(\\n        f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\\n    )\\n    self.collection.delete(ids_to_delete)\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                }
            ]
        }
    ]
}