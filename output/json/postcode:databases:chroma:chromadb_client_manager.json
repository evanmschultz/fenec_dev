{
    "file_path": "postcode/databases/chroma/chromadb_client_manager.py",
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Any",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "chromadb.utils.embedding_functions",
                    "as_name": "ef",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "postcode.types.chroma",
                    "as_name": "chroma_types",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:types:chroma.py__*__MODULE"
        }
    ],
    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE",
    "parent_id": null,
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 185,
    "code_content": "import logging\nfrom typing import Any, Sequence\n\nimport postcode.types.chroma as chroma_types\nimport chromadb.utils.embedding_functions as ef\n\n\nclass ChromaDBClientManager:\n    \"\"\"\n    Class for managing a ChromaDB client.\n\n    Provides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\n    This class is part of the postcode library, offering default values and extended functionality.\n\n    Attributes:\n        client (chroma.ClientAPI): The ChromaDB client being managed.\n\n    Methods:\n        - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\n        - `delete_collection`: Deletes a ChromaDB collection with the given name.\n        - `list_collections`: Lists all ChromaDB collections.\n        - `get_client_settings`: Gets the settings of the ChromaDB client.\n        - `reset_client`: Resets the ChromaDB client to its initial state.\n\n    Notes:\n        Import defined in postcode.databases.chroma `__init__.py`. Import using:\n            `from postcode.databases.chroma import ChromaDBClientManager`\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n\n        # Create a persistent ChromaDB client\n        client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Create a ChromaDB client manager instance\n        client_manager = ChromaDBClientManager(client)\n        ```\n    \"\"\"\n\n    def __init__(self, client: chroma_types.ClientAPI) -> None:\n        self.client: chroma_types.ClientAPI = client\n\n    def get_or_create_collection(\n        self,\n        name: str,\n        metadata: dict[str, Any] | None = None,\n        embedding_function: chroma_types.EmbeddingFunction[list[str]]\n        | None = ef.DefaultEmbeddingFunction(),\n    ) -> chroma_types.Collection:\n        \"\"\"\n        Gets or creates a ChromaDB collection with the given name.\n\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\n\n        Args:\n            - name (str): The name of the collection to get or create.\n            - metadata (dict[str, Any]): The metadata for the collection.\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\n\n        Returns:\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\n                with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Notes:\n            - This is done this way for logging purposes as opposed simply using chromadb's `get_or_create_collection` method\n                directly.\n\n        Examples:\n            ```Python\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n            import postcode.types.chromadb.types as chroma_types\n\n            from example_module_with_manager_defined import client_manager\n\n            # Create or get a collection using the client_manager instance\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n        logging.info(f\"Getting or creating collection: {name}\")\n        return self.client.get_or_create_collection(\n            name,\n            metadata=metadata,\n            embedding_function=embedding_function,\n        )\n\n    def delete_collection(self, name: str) -> None:\n        \"\"\"\n        Deletes a ChromaDB collection with the given name.\n\n        Args:\n            - name (str): The name of the collection to delete.\n\n        Raises:\n            - ValueError: If the collection does not exist.\n\n        Examples:\n            ```Python\n            client_manager.delete_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n        if self.client.get_collection(name):\n            logging.info(f\"Deleting collection {name}\")\n            self.client.delete_collection(name)\n        else:\n            raise ValueError(f\"Collection {name} does not exist.\")\n\n    def list_collections(self) -> Sequence[chroma_types.Collection]:\n        \"\"\"\n        Lists all ChromaDB collections.\n\n        Returns:\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\n                Model with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Examples:\n            ```Python\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\n            ```\n        \"\"\"\n\n        return self.client.list_collections()\n\n    def get_client_settings(self) -> chroma_types.Settings:\n        \"\"\"\n        Gets the setting used to instantiate the ChromaDB client.\n\n        Returns:\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\n\n        Examples:\n            ```Python\n            settings: chroma_types.Settings = client_manager.get_client_settings()\n            ```\n        \"\"\"\n\n        return self.client.get_settings()\n\n    def reset_client(self) -> None:\n        \"\"\"\n        Resets the ChromaDB client to its initial state.\n\n        This method resets the client settings and clears any cached or temporary data.\n        It iterates over the collections, logging their names, and then resets the client.\n        If the reset operation is unsuccessful, it raises a ValueError.\n\n        Raises:\n            ValueError: If the client reset operation is unsuccessful.\n\n        Notes:\n            This method loops through the collections_list as opposed to immediately calling ChromaDB's\n                `reset` method for logging purposes.\n\n        Examples:\n            ```Python\n            client_manager.reset_client()  # Resets the client and logs the collections\n            ```\n        \"\"\"\n        reset_successful: bool = self.client.reset()\n        if reset_successful:\n            print(\"Resetting client with:\")\n\n            if collections := self.list_collections():\n                for collection in collections:\n                    print(f\"\\tCollection: {collection.name}\")\n            else:\n                print(\"No collections.\")\n\n            self.client.reset()\n            logging.info(\"Client reset successful.\")\n        else:\n            raise ValueError(\"Client reset unsuccessful.\")\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\nimport logging\\nfrom typing import Any, Sequence\\n\\nimport postcode.types.chroma as chroma_types\\nimport chromadb.utils.embedding_functions as ef\\n\\n\\nclass ChromaDBClientManager:\\n    \"\"\"\\n    Class for managing a ChromaDB client.\\n\\n    Provides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\\n    This class is part of the postcode library, offering default values and extended functionality.\\n\\n    Attributes:\\n        client (chroma.ClientAPI): The ChromaDB client being managed.\\n\\n    Methods:\\n        - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\\n        - `delete_collection`: Deletes a ChromaDB collection with the given name.\\n        - `list_collections`: Lists all ChromaDB collections.\\n        - `get_client_settings`: Gets the settings of the ChromaDB client.\\n        - `reset_client`: Resets the ChromaDB client to its initial state.\\n\\n    Notes:\\n        Import defined in postcode.databases.chroma `__init__.py`. Import using:\\n            `from postcode.databases.chroma import ChromaDBClientManager`\\n\\n    Examples:\\n        ```Python\\n        from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\n\\n        # Create a persistent ChromaDB client\\n        client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\n\\n        # Create a ChromaDB client manager instance\\n        client_manager = ChromaDBClientManager(client)\\n        ```\\n    \"\"\"\\n\\n    def __init__(self, client: chroma_types.ClientAPI) -> None:\\n        self.client: chroma_types.ClientAPI = client\\n\\n    def get_or_create_collection(\\n        self,\\n        name: str,\\n        metadata: dict[str, Any] | None = None,\\n        embedding_function: chroma_types.EmbeddingFunction[list[str]]\\n        | None = ef.DefaultEmbeddingFunction(),\\n    ) -> chroma_types.Collection:\\n        \"\"\"\\n        Gets or creates a ChromaDB collection with the given name.\\n\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\n\\n        Args:\\n            - name (str): The name of the collection to get or create.\\n            - metadata (dict[str, Any]): The metadata for the collection.\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\n\\n        Returns:\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\n                with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Notes:\\n            - This is done this way for logging purposes as opposed simply using chromadb\\'s `get_or_create_collection` method\\n                directly.\\n\\n        Examples:\\n            ```Python\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            from example_module_with_manager_defined import client_manager\\n\\n            # Create or get a collection using the client_manager instance\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n        logging.info(f\"Getting or creating collection: {name}\")\\n        return self.client.get_or_create_collection(\\n            name,\\n            metadata=metadata,\\n            embedding_function=embedding_function,\\n        )\\n\\n    def delete_collection(self, name: str) -> None:\\n        \"\"\"\\n        Deletes a ChromaDB collection with the given name.\\n\\n        Args:\\n            - name (str): The name of the collection to delete.\\n\\n        Raises:\\n            - ValueError: If the collection does not exist.\\n\\n        Examples:\\n            ```Python\\n            client_manager.delete_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n        if self.client.get_collection(name):\\n            logging.info(f\"Deleting collection {name}\")\\n            self.client.delete_collection(name)\\n        else:\\n            raise ValueError(f\"Collection {name} does not exist.\")\\n\\n    def list_collections(self) -> Sequence[chroma_types.Collection]:\\n        \"\"\"\\n        Lists all ChromaDB collections.\\n\\n        Returns:\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\n                Model with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Examples:\\n            ```Python\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\n            ```\\n        \"\"\"\\n\\n        return self.client.list_collections()\\n\\n    def get_client_settings(self) -> chroma_types.Settings:\\n        \"\"\"\\n        Gets the setting used to instantiate the ChromaDB client.\\n\\n        Returns:\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\n\\n        Examples:\\n            ```Python\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\n            ```\\n        \"\"\"\\n\\n        return self.client.get_settings()\\n\\n    def reset_client(self) -> None:\\n        \"\"\"\\n        Resets the ChromaDB client to its initial state.\\n\\n        This method resets the client settings and clears any cached or temporary data.\\n        It iterates over the collections, logging their names, and then resets the client.\\n        If the reset operation is unsuccessful, it raises a ValueError.\\n\\n        Raises:\\n            ValueError: If the client reset operation is unsuccessful.\\n\\n        Notes:\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\'s\\n                `reset` method for logging purposes.\\n\\n        Examples:\\n            ```Python\\n            client_manager.reset_client()  # Resets the client and logs the collections\\n            ```\\n        \"\"\"\\n        reset_successful: bool = self.client.reset()\\n        if reset_successful:\\n            print(\"Resetting client with:\")\\n\\n            if collections := self.list_collections():\\n                for collection in collections:\\n                    print(f\"\\\\tCollection: {collection.name}\")\\n            else:\\n                print(\"No collections.\")\\n\\n            self.client.reset()\\n            logging.info(\"Client reset successful.\")\\n        else:\\n            raise ValueError(\"Client reset unsuccessful.\")\\n\\n```\\n\\nCHILDREN_SUMMARIES:\\n\\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\\\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\\\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\nclass ChromaDBClientManager:\\\\n    \"\"\"\\\\n    Class for managing a ChromaDB client.\\\\n\\\\n    Provides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\\\\n    This class is part of the postcode library, offering default values and extended functionality.\\\\n\\\\n    Attributes:\\\\n        client (chroma.ClientAPI): The ChromaDB client being managed.\\\\n\\\\n    Methods:\\\\n        - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\\\\n        - `delete_collection`: Deletes a ChromaDB collection with the given name.\\\\n        - `list_collections`: Lists all ChromaDB collections.\\\\n        - `get_client_settings`: Gets the settings of the ChromaDB client.\\\\n        - `reset_client`: Resets the ChromaDB client to its initial state.\\\\n\\\\n    Notes:\\\\n        Import defined in postcode.databases.chroma `__init__.py`. Import using:\\\\n            `from postcode.databases.chroma import ChromaDBClientManager`\\\\n\\\\n    Examples:\\\\n        ```Python\\\\n        from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\\\n\\\\n        # Create a persistent ChromaDB client\\\\n        client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\\\n\\\\n        # Create a ChromaDB client manager instance\\\\n        client_manager = ChromaDBClientManager(client)\\\\n        ```\\\\n    \"\"\"\\\\n\\\\n    def __init__(self, client: chroma_types.ClientAPI) -> None:\\\\n        self.client: chroma_types.ClientAPI = client\\\\n\\\\n    def get_or_create_collection(\\\\n        self,\\\\n        name: str,\\\\n        metadata: dict[str, Any] | None = None,\\\\n        embedding_function: chroma_types.EmbeddingFunction[list[str]]\\\\n        | None = ef.DefaultEmbeddingFunction(),\\\\n    ) -> chroma_types.Collection:\\\\n        \"\"\"\\\\n        Gets or creates a ChromaDB collection with the given name.\\\\n\\\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\\\n\\\\n        Args:\\\\n            - name (str): The name of the collection to get or create.\\\\n            - metadata (dict[str, Any]): The metadata for the collection.\\\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\\\n\\\\n        Returns:\\\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\\\n                with the following attributes:\\\\n                    - name: str\\\\n                    - id: UUID\\\\n                    - metadata: CollectionMetadata | None\\\\n                    - tenant: str | None\\\\n                    - database: str | None\\\\n\\\\n        Notes:\\\\n            - This is done this way for logging purposes as opposed simply using chromadb\\\\\\'s `get_or_create_collection` method\\\\n                directly.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\\\n            import postcode.types.chromadb.types as chroma_types\\\\n\\\\n            from example_module_with_manager_defined import client_manager\\\\n\\\\n            # Create or get a collection using the client_manager instance\\\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        logging.info(f\"Getting or creating collection: {name}\")\\\\n        return self.client.get_or_create_collection(\\\\n            name,\\\\n            metadata=metadata,\\\\n            embedding_function=embedding_function,\\\\n        )\\\\n\\\\n    def delete_collection(self, name: str) -> None:\\\\n        \"\"\"\\\\n        Deletes a ChromaDB collection with the given name.\\\\n\\\\n        Args:\\\\n            - name (str): The name of the collection to delete.\\\\n\\\\n        Raises:\\\\n            - ValueError: If the collection does not exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            client_manager.delete_collection(\"my_collection\")\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        if self.client.get_collection(name):\\\\n            logging.info(f\"Deleting collection {name}\")\\\\n            self.client.delete_collection(name)\\\\n        else:\\\\n            raise ValueError(f\"Collection {name} does not exist.\")\\\\n\\\\n    def list_collections(self) -> Sequence[chroma_types.Collection]:\\\\n        \"\"\"\\\\n        Lists all ChromaDB collections.\\\\n\\\\n        Returns:\\\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\\\n                Model with the following attributes:\\\\n                    - name: str\\\\n                    - id: UUID\\\\n                    - metadata: CollectionMetadata | None\\\\n                    - tenant: str | None\\\\n                    - database: str | None\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        return self.client.list_collections()\\\\n\\\\n    def get_client_settings(self) -> chroma_types.Settings:\\\\n        \"\"\"\\\\n        Gets the setting used to instantiate the ChromaDB client.\\\\n\\\\n        Returns:\\\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n        return self.client.get_settings()\\\\n\\\\n    def reset_client(self) -> None:\\\\n        \"\"\"\\\\n        Resets the ChromaDB client to its initial state.\\\\n\\\\n        This method resets the client settings and clears any cached or temporary data.\\\\n        It iterates over the collections, logging their names, and then resets the client.\\\\n        If the reset operation is unsuccessful, it raises a ValueError.\\\\n\\\\n        Raises:\\\\n            ValueError: If the client reset operation is unsuccessful.\\\\n\\\\n        Notes:\\\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\\\\\'s\\\\n                `reset` method for logging purposes.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            client_manager.reset_client()  # Resets the client and logs the collections\\\\n            ```\\\\n        \"\"\"\\\\n        reset_successful: bool = self.client.reset()\\\\n        if reset_successful:\\\\n            print(\"Resetting client with:\")\\\\n\\\\n            if collections := self.list_collections():\\\\n                for collection in collections:\\\\n                    print(f\"\\\\\\\\tCollection: {collection.name}\")\\\\n            else:\\\\n                print(\"No collections.\")\\\\n\\\\n            self.client.reset()\\\\n            logging.info(\"Client reset successful.\")\\\\n        else:\\\\n            raise ValueError(\"Client reset unsuccessful.\")\\\\n\\\\n```\\\\n\\\\nCHILDREN_SUMMARIES:\\\\n\\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef __init__(self, client: chroma_types.ClientAPI) -> None:\\\\\\\\n    self.client: chroma_types.ClientAPI = client\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef get_or_create_collection(\\\\\\\\n    self,\\\\\\\\n    name: str,\\\\\\\\n    metadata: dict[str, Any] | None = None,\\\\\\\\n    embedding_function: chroma_types.EmbeddingFunction[list[str]]\\\\\\\\n    | None = ef.DefaultEmbeddingFunction(),\\\\\\\\n) -> chroma_types.Collection:\\\\\\\\n    \"\"\"\\\\\\\\n        Gets or creates a ChromaDB collection with the given name.\\\\\\\\n\\\\\\\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - name (str): The name of the collection to get or create.\\\\\\\\n            - metadata (dict[str, Any]): The metadata for the collection.\\\\\\\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\\\\\\\n                with the following attributes:\\\\\\\\n                    - name: str\\\\\\\\n                    - id: UUID\\\\\\\\n                    - metadata: CollectionMetadata | None\\\\\\\\n                    - tenant: str | None\\\\\\\\n                    - database: str | None\\\\\\\\n\\\\\\\\n        Notes:\\\\\\\\n            - This is done this way for logging purposes as opposed simply using chromadb\\\\\\\\\\\\\\'s `get_or_create_collection` method\\\\\\\\n                directly.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\\\\\\\n            import postcode.types.chromadb.types as chroma_types\\\\\\\\n\\\\\\\\n            from example_module_with_manager_defined import client_manager\\\\\\\\n\\\\\\\\n            # Create or get a collection using the client_manager instance\\\\\\\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    logging.info(f\"Getting or creating collection: {name}\")\\\\\\\\n    return self.client.get_or_create_collection(\\\\\\\\n        name,\\\\\\\\n        metadata=metadata,\\\\\\\\n        embedding_function=embedding_function,\\\\\\\\n    )\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef delete_collection(self, name: str) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Deletes a ChromaDB collection with the given name.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            - name (str): The name of the collection to delete.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            - ValueError: If the collection does not exist.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            client_manager.delete_collection(\"my_collection\")\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    if self.client.get_collection(name):\\\\\\\\n        logging.info(f\"Deleting collection {name}\")\\\\\\\\n        self.client.delete_collection(name)\\\\\\\\n    else:\\\\\\\\n        raise ValueError(f\"Collection {name} does not exist.\")\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef list_collections(self) -> Sequence[chroma_types.Collection]:\\\\\\\\n    \"\"\"\\\\\\\\n        Lists all ChromaDB collections.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\\\\\\\n                Model with the following attributes:\\\\\\\\n                    - name: str\\\\\\\\n                    - id: UUID\\\\\\\\n                    - metadata: CollectionMetadata | None\\\\\\\\n                    - tenant: str | None\\\\\\\\n                    - database: str | None\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    return self.client.list_collections()\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef get_client_settings(self) -> chroma_types.Settings:\\\\\\\\n    \"\"\"\\\\\\\\n        Gets the setting used to instantiate the ChromaDB client.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n\\\\\\\\n    return self.client.get_settings()\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\nSummary:\\\\n\\\\n        [{\\\\\\'content\\\\\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main\\\\\\\\nfeatures, and key components.\\\\\\\\n\", \\\\\\'role\\\\\\': \\\\\\'system\\\\\\'}, {\\\\\\'content\\\\\\': \\\\\\'Prompt: \"Summarize the code provided.\"\\\\\\\\n\\\\\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\\\\\n\\\\\\\\nChain of Density Steps:\\\\\\\\n\\\\\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\\\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\\\\\n\\\\\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\\\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\\\\\n\\\\\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\\\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\\\\\n\\\\\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\\\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\\\\\nlonger.\\\\\\\\n\\\\\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\\\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\\\\\\\\\'s purpose. It should provide a clear and concise overview of \\\\\\\\nthe code\\\\\\\\\\\\\\'s content and purpose.\\\\\\\\n\\\\\\\\nGuidelines:\\\\\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\\\\\\\\\'s functionality and purpose.\\\\\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\\\\\\\\\'s purpose, main features, and key components.\\\\\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\\\\\\\\\'s main functionality.\\\\\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\\\\\n\\\\\\\\nCODE:\\\\\\\\n```Python\\\\\\\\n\\\\\\\\ndef reset_client(self) -> None:\\\\\\\\n    \"\"\"\\\\\\\\n        Resets the ChromaDB client to its initial state.\\\\\\\\n\\\\\\\\n        This method resets the client settings and clears any cached or temporary data.\\\\\\\\n        It iterates over the collections, logging their names, and then resets the client.\\\\\\\\n        If the reset operation is unsuccessful, it raises a ValueError.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If the client reset operation is unsuccessful.\\\\\\\\n\\\\\\\\n        Notes:\\\\\\\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\\\\\\\\\\\\\'s\\\\\\\\n                `reset` method for logging purposes.\\\\\\\\n\\\\\\\\n        Examples:\\\\\\\\n            ```Python\\\\\\\\n            client_manager.reset_client()  # Resets the client and logs the collections\\\\\\\\n            ```\\\\\\\\n        \"\"\"\\\\\\\\n    reset_successful: bool = self.client.reset()\\\\\\\\n    if reset_successful:\\\\\\\\n        print(\"Resetting client with:\")\\\\\\\\n\\\\\\\\n        if collections := self.list_collections():\\\\\\\\n            for collection in collections:\\\\\\\\n                print(f\"\\\\\\\\\\\\\\\\tCollection: {collection.name}\")\\\\\\\\n        else:\\\\\\\\n            print(\"No collections.\")\\\\\\\\n\\\\\\\\n        self.client.reset()\\\\\\\\n        logging.info(\"Client reset successful.\")\\\\\\\\n    else:\\\\\\\\n        raise ValueError(\"Client reset unsuccessful.\")\\\\\\\\n\\\\\\\\n```\\\\\\\\n\\\\\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\\\\\n\\\\\\', \\\\\\'role\\\\\\': \\\\\\'user\\\\\\'}]\\\\n \\\\n        \\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport logging\\\\nfrom typing import Any, Sequence\\\\nfrom typing import Any, Sequence\\\\nimport postcode.types.chroma as chroma_types\\\\nimport postcode.types.chroma as chroma_types\\\\nimport chromadb.utils.embedding_functions as ef\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nfrom typing import Any, Sequence\\nimport chromadb.utils.embedding_functions as ef\\nimport postcode.types.chroma as chroma_types\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
    "children": [
        {
            "class_name": "ChromaDBClientManager",
            "decorators": null,
            "bases": null,
            "docstring": "Class for managing a ChromaDB client.\n\nProvides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\nThis class is part of the postcode library, offering default values and extended functionality.\n\nAttributes:\n    client (chroma.ClientAPI): The ChromaDB client being managed.\n\nMethods:\n    - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\n    - `delete_collection`: Deletes a ChromaDB collection with the given name.\n    - `list_collections`: Lists all ChromaDB collections.\n    - `get_client_settings`: Gets the settings of the ChromaDB client.\n    - `reset_client`: Resets the ChromaDB client to its initial state.\n\nNotes:\n    Import defined in postcode.databases.chroma `__init__.py`. Import using:\n        `from postcode.databases.chroma import ChromaDBClientManager`\n\nExamples:\n    ```Python\n    from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n\n    # Create a persistent ChromaDB client\n    client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n    # Create a ChromaDB client manager instance\n    client_manager = ChromaDBClientManager(client)\n    ```",
            "keywords": null,
            "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
            "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE",
            "block_type": "CLASS",
            "start_line_num": 6,
            "end_line_num": 185,
            "code_content": "\n\nclass ChromaDBClientManager:\n    \"\"\"\n    Class for managing a ChromaDB client.\n\n    Provides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\n    This class is part of the postcode library, offering default values and extended functionality.\n\n    Attributes:\n        client (chroma.ClientAPI): The ChromaDB client being managed.\n\n    Methods:\n        - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\n        - `delete_collection`: Deletes a ChromaDB collection with the given name.\n        - `list_collections`: Lists all ChromaDB collections.\n        - `get_client_settings`: Gets the settings of the ChromaDB client.\n        - `reset_client`: Resets the ChromaDB client to its initial state.\n\n    Notes:\n        Import defined in postcode.databases.chroma `__init__.py`. Import using:\n            `from postcode.databases.chroma import ChromaDBClientManager`\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n\n        # Create a persistent ChromaDB client\n        client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Create a ChromaDB client manager instance\n        client_manager = ChromaDBClientManager(client)\n        ```\n    \"\"\"\n\n    def __init__(self, client: chroma_types.ClientAPI) -> None:\n        self.client: chroma_types.ClientAPI = client\n\n    def get_or_create_collection(\n        self,\n        name: str,\n        metadata: dict[str, Any] | None = None,\n        embedding_function: chroma_types.EmbeddingFunction[list[str]]\n        | None = ef.DefaultEmbeddingFunction(),\n    ) -> chroma_types.Collection:\n        \"\"\"\n        Gets or creates a ChromaDB collection with the given name.\n\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\n\n        Args:\n            - name (str): The name of the collection to get or create.\n            - metadata (dict[str, Any]): The metadata for the collection.\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\n\n        Returns:\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\n                with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Notes:\n            - This is done this way for logging purposes as opposed simply using chromadb's `get_or_create_collection` method\n                directly.\n\n        Examples:\n            ```Python\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n            import postcode.types.chromadb.types as chroma_types\n\n            from example_module_with_manager_defined import client_manager\n\n            # Create or get a collection using the client_manager instance\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n        logging.info(f\"Getting or creating collection: {name}\")\n        return self.client.get_or_create_collection(\n            name,\n            metadata=metadata,\n            embedding_function=embedding_function,\n        )\n\n    def delete_collection(self, name: str) -> None:\n        \"\"\"\n        Deletes a ChromaDB collection with the given name.\n\n        Args:\n            - name (str): The name of the collection to delete.\n\n        Raises:\n            - ValueError: If the collection does not exist.\n\n        Examples:\n            ```Python\n            client_manager.delete_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n        if self.client.get_collection(name):\n            logging.info(f\"Deleting collection {name}\")\n            self.client.delete_collection(name)\n        else:\n            raise ValueError(f\"Collection {name} does not exist.\")\n\n    def list_collections(self) -> Sequence[chroma_types.Collection]:\n        \"\"\"\n        Lists all ChromaDB collections.\n\n        Returns:\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\n                Model with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Examples:\n            ```Python\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\n            ```\n        \"\"\"\n\n        return self.client.list_collections()\n\n    def get_client_settings(self) -> chroma_types.Settings:\n        \"\"\"\n        Gets the setting used to instantiate the ChromaDB client.\n\n        Returns:\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\n\n        Examples:\n            ```Python\n            settings: chroma_types.Settings = client_manager.get_client_settings()\n            ```\n        \"\"\"\n\n        return self.client.get_settings()\n\n    def reset_client(self) -> None:\n        \"\"\"\n        Resets the ChromaDB client to its initial state.\n\n        This method resets the client settings and clears any cached or temporary data.\n        It iterates over the collections, logging their names, and then resets the client.\n        If the reset operation is unsuccessful, it raises a ValueError.\n\n        Raises:\n            ValueError: If the client reset operation is unsuccessful.\n\n        Notes:\n            This method loops through the collections_list as opposed to immediately calling ChromaDB's\n                `reset` method for logging purposes.\n\n        Examples:\n            ```Python\n            client_manager.reset_client()  # Resets the client and logs the collections\n            ```\n        \"\"\"\n        reset_successful: bool = self.client.reset()\n        if reset_successful:\n            print(\"Resetting client with:\")\n\n            if collections := self.list_collections():\n                for collection in collections:\n                    print(f\"\\tCollection: {collection.name}\")\n            else:\n                print(\"No collections.\")\n\n            self.client.reset()\n            logging.info(\"Client reset successful.\")\n        else:\n            raise ValueError(\"Client reset unsuccessful.\")\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "logging",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Any",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Sequence",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "typing",
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Any",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Sequence",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "typing",
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "postcode.types.chroma",
                            "as_name": "chroma_types",
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "LOCAL",
                    "local_module_id": "postcode:types:chroma.py__*__MODULE"
                },
                {
                    "import_names": [
                        {
                            "name": "postcode.types.chroma",
                            "as_name": "chroma_types",
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "LOCAL",
                    "local_module_id": "postcode:types:chroma.py__*__MODULE"
                },
                {
                    "import_names": [
                        {
                            "name": "chromadb.utils.embedding_functions",
                            "as_name": "ef",
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\nclass ChromaDBClientManager:\\n    \"\"\"\\n    Class for managing a ChromaDB client.\\n\\n    Provides functionality for managing a ChromaDB client, including creating, deleting, and listing collections.\\n    This class is part of the postcode library, offering default values and extended functionality.\\n\\n    Attributes:\\n        client (chroma.ClientAPI): The ChromaDB client being managed.\\n\\n    Methods:\\n        - `get_or_create_collection`: Gets or creates a ChromaDB collection with the given name.\\n        - `delete_collection`: Deletes a ChromaDB collection with the given name.\\n        - `list_collections`: Lists all ChromaDB collections.\\n        - `get_client_settings`: Gets the settings of the ChromaDB client.\\n        - `reset_client`: Resets the ChromaDB client to its initial state.\\n\\n    Notes:\\n        Import defined in postcode.databases.chroma `__init__.py`. Import using:\\n            `from postcode.databases.chroma import ChromaDBClientManager`\\n\\n    Examples:\\n        ```Python\\n        from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\n\\n        # Create a persistent ChromaDB client\\n        client: chroma.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\\n\\n        # Create a ChromaDB client manager instance\\n        client_manager = ChromaDBClientManager(client)\\n        ```\\n    \"\"\"\\n\\n    def __init__(self, client: chroma_types.ClientAPI) -> None:\\n        self.client: chroma_types.ClientAPI = client\\n\\n    def get_or_create_collection(\\n        self,\\n        name: str,\\n        metadata: dict[str, Any] | None = None,\\n        embedding_function: chroma_types.EmbeddingFunction[list[str]]\\n        | None = ef.DefaultEmbeddingFunction(),\\n    ) -> chroma_types.Collection:\\n        \"\"\"\\n        Gets or creates a ChromaDB collection with the given name.\\n\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\n\\n        Args:\\n            - name (str): The name of the collection to get or create.\\n            - metadata (dict[str, Any]): The metadata for the collection.\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\n\\n        Returns:\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\n                with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Notes:\\n            - This is done this way for logging purposes as opposed simply using chromadb\\'s `get_or_create_collection` method\\n                directly.\\n\\n        Examples:\\n            ```Python\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            from example_module_with_manager_defined import client_manager\\n\\n            # Create or get a collection using the client_manager instance\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n        logging.info(f\"Getting or creating collection: {name}\")\\n        return self.client.get_or_create_collection(\\n            name,\\n            metadata=metadata,\\n            embedding_function=embedding_function,\\n        )\\n\\n    def delete_collection(self, name: str) -> None:\\n        \"\"\"\\n        Deletes a ChromaDB collection with the given name.\\n\\n        Args:\\n            - name (str): The name of the collection to delete.\\n\\n        Raises:\\n            - ValueError: If the collection does not exist.\\n\\n        Examples:\\n            ```Python\\n            client_manager.delete_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n        if self.client.get_collection(name):\\n            logging.info(f\"Deleting collection {name}\")\\n            self.client.delete_collection(name)\\n        else:\\n            raise ValueError(f\"Collection {name} does not exist.\")\\n\\n    def list_collections(self) -> Sequence[chroma_types.Collection]:\\n        \"\"\"\\n        Lists all ChromaDB collections.\\n\\n        Returns:\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\n                Model with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Examples:\\n            ```Python\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\n            ```\\n        \"\"\"\\n\\n        return self.client.list_collections()\\n\\n    def get_client_settings(self) -> chroma_types.Settings:\\n        \"\"\"\\n        Gets the setting used to instantiate the ChromaDB client.\\n\\n        Returns:\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\n\\n        Examples:\\n            ```Python\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\n            ```\\n        \"\"\"\\n\\n        return self.client.get_settings()\\n\\n    def reset_client(self) -> None:\\n        \"\"\"\\n        Resets the ChromaDB client to its initial state.\\n\\n        This method resets the client settings and clears any cached or temporary data.\\n        It iterates over the collections, logging their names, and then resets the client.\\n        If the reset operation is unsuccessful, it raises a ValueError.\\n\\n        Raises:\\n            ValueError: If the client reset operation is unsuccessful.\\n\\n        Notes:\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\'s\\n                `reset` method for logging purposes.\\n\\n        Examples:\\n            ```Python\\n            client_manager.reset_client()  # Resets the client and logs the collections\\n            ```\\n        \"\"\"\\n        reset_successful: bool = self.client.reset()\\n        if reset_successful:\\n            print(\"Resetting client with:\")\\n\\n            if collections := self.list_collections():\\n                for collection in collections:\\n                    print(f\"\\\\tCollection: {collection.name}\")\\n            else:\\n                print(\"No collections.\")\\n\\n            self.client.reset()\\n            logging.info(\"Client reset successful.\")\\n        else:\\n            raise ValueError(\"Client reset unsuccessful.\")\\n\\n```\\n\\nCHILDREN_SUMMARIES:\\n\\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef __init__(self, client: chroma_types.ClientAPI) -> None:\\\\n    self.client: chroma_types.ClientAPI = client\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef get_or_create_collection(\\\\n    self,\\\\n    name: str,\\\\n    metadata: dict[str, Any] | None = None,\\\\n    embedding_function: chroma_types.EmbeddingFunction[list[str]]\\\\n    | None = ef.DefaultEmbeddingFunction(),\\\\n) -> chroma_types.Collection:\\\\n    \"\"\"\\\\n        Gets or creates a ChromaDB collection with the given name.\\\\n\\\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\\\n\\\\n        Args:\\\\n            - name (str): The name of the collection to get or create.\\\\n            - metadata (dict[str, Any]): The metadata for the collection.\\\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\\\n\\\\n        Returns:\\\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\\\n                with the following attributes:\\\\n                    - name: str\\\\n                    - id: UUID\\\\n                    - metadata: CollectionMetadata | None\\\\n                    - tenant: str | None\\\\n                    - database: str | None\\\\n\\\\n        Notes:\\\\n            - This is done this way for logging purposes as opposed simply using chromadb\\\\\\'s `get_or_create_collection` method\\\\n                directly.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\\\n            import postcode.types.chromadb.types as chroma_types\\\\n\\\\n            from example_module_with_manager_defined import client_manager\\\\n\\\\n            # Create or get a collection using the client_manager instance\\\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    logging.info(f\"Getting or creating collection: {name}\")\\\\n    return self.client.get_or_create_collection(\\\\n        name,\\\\n        metadata=metadata,\\\\n        embedding_function=embedding_function,\\\\n    )\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef delete_collection(self, name: str) -> None:\\\\n    \"\"\"\\\\n        Deletes a ChromaDB collection with the given name.\\\\n\\\\n        Args:\\\\n            - name (str): The name of the collection to delete.\\\\n\\\\n        Raises:\\\\n            - ValueError: If the collection does not exist.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            client_manager.delete_collection(\"my_collection\")\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    if self.client.get_collection(name):\\\\n        logging.info(f\"Deleting collection {name}\")\\\\n        self.client.delete_collection(name)\\\\n    else:\\\\n        raise ValueError(f\"Collection {name} does not exist.\")\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef list_collections(self) -> Sequence[chroma_types.Collection]:\\\\n    \"\"\"\\\\n        Lists all ChromaDB collections.\\\\n\\\\n        Returns:\\\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\\\n                Model with the following attributes:\\\\n                    - name: str\\\\n                    - id: UUID\\\\n                    - metadata: CollectionMetadata | None\\\\n                    - tenant: str | None\\\\n                    - database: str | None\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    return self.client.list_collections()\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef get_client_settings(self) -> chroma_types.Settings:\\\\n    \"\"\"\\\\n        Gets the setting used to instantiate the ChromaDB client.\\\\n\\\\n        Returns:\\\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\\\n            ```\\\\n        \"\"\"\\\\n\\\\n    return self.client.get_settings()\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\ndef reset_client(self) -> None:\\\\n    \"\"\"\\\\n        Resets the ChromaDB client to its initial state.\\\\n\\\\n        This method resets the client settings and clears any cached or temporary data.\\\\n        It iterates over the collections, logging their names, and then resets the client.\\\\n        If the reset operation is unsuccessful, it raises a ValueError.\\\\n\\\\n        Raises:\\\\n            ValueError: If the client reset operation is unsuccessful.\\\\n\\\\n        Notes:\\\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\\\\\'s\\\\n                `reset` method for logging purposes.\\\\n\\\\n        Examples:\\\\n            ```Python\\\\n            client_manager.reset_client()  # Resets the client and logs the collections\\\\n            ```\\\\n        \"\"\"\\\\n    reset_successful: bool = self.client.reset()\\\\n    if reset_successful:\\\\n        print(\"Resetting client with:\")\\\\n\\\\n        if collections := self.list_collections():\\\\n            for collection in collections:\\\\n                print(f\"\\\\\\\\tCollection: {collection.name}\")\\\\n        else:\\\\n            print(\"No collections.\")\\\\n\\\\n        self.client.reset()\\\\n        logging.info(\"Client reset successful.\")\\\\n    else:\\\\n        raise ValueError(\"Client reset unsuccessful.\")\\\\n\\\\n```\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nfrom typing import Any, Sequence\\nfrom typing import Any, Sequence\\nimport postcode.types.chroma as chroma_types\\nimport postcode.types.chroma as chroma_types\\nimport chromadb.utils.embedding_functions as ef\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": [
                {
                    "function_name": "__init__",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-__init__",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 40,
                    "end_line_num": 43,
                    "code_content": "\ndef __init__(self, client: chroma_types.ClientAPI) -> None:\n    self.client: chroma_types.ClientAPI = client\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef __init__(self, client: chroma_types.ClientAPI) -> None:\\n    self.client: chroma_types.ClientAPI = client\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "get_or_create_collection",
                    "docstring": "Gets or creates a ChromaDB collection with the given name.\n\nChecks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\n\nArgs:\n    - name (str): The name of the collection to get or create.\n    - metadata (dict[str, Any]): The metadata for the collection.\n    - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\n\nReturns:\n    - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\n        with the following attributes:\n            - name: str\n            - id: UUID\n            - metadata: CollectionMetadata | None\n            - tenant: str | None\n            - database: str | None\n\nNotes:\n    - This is done this way for logging purposes as opposed simply using chromadb's `get_or_create_collection` method\n        directly.\n\nExamples:\n    ```Python\n    from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n    import postcode.types.chromadb.types as chroma_types\n\n    from example_module_with_manager_defined import client_manager\n\n    # Create or get a collection using the client_manager instance\n    collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "No return annotation",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-get_or_create_collection",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 43,
                    "end_line_num": 92,
                    "code_content": "\ndef get_or_create_collection(\n    self,\n    name: str,\n    metadata: dict[str, Any] | None = None,\n    embedding_function: chroma_types.EmbeddingFunction[list[str]]\n    | None = ef.DefaultEmbeddingFunction(),\n) -> chroma_types.Collection:\n    \"\"\"\n        Gets or creates a ChromaDB collection with the given name.\n\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\n\n        Args:\n            - name (str): The name of the collection to get or create.\n            - metadata (dict[str, Any]): The metadata for the collection.\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\n\n        Returns:\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\n                with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Notes:\n            - This is done this way for logging purposes as opposed simply using chromadb's `get_or_create_collection` method\n                directly.\n\n        Examples:\n            ```Python\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\n            import postcode.types.chromadb.types as chroma_types\n\n            from example_module_with_manager_defined import client_manager\n\n            # Create or get a collection using the client_manager instance\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n    logging.info(f\"Getting or creating collection: {name}\")\n    return self.client.get_or_create_collection(\n        name,\n        metadata=metadata,\n        embedding_function=embedding_function,\n    )\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef get_or_create_collection(\\n    self,\\n    name: str,\\n    metadata: dict[str, Any] | None = None,\\n    embedding_function: chroma_types.EmbeddingFunction[list[str]]\\n    | None = ef.DefaultEmbeddingFunction(),\\n) -> chroma_types.Collection:\\n    \"\"\"\\n        Gets or creates a ChromaDB collection with the given name.\\n\\n        Checks if the collection exists and returns it if it does. Otherwise, creates the collection and returns it.\\n\\n        Args:\\n            - name (str): The name of the collection to get or create.\\n            - metadata (dict[str, Any]): The metadata for the collection.\\n            - embedding_function (chroma_types.EmbeddingFunction): The embedding function for the collection.\\n\\n        Returns:\\n            - collection (chroma.Collection): The collection object with the given name. The collection object is a Pydantic Model\\n                with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Notes:\\n            - This is done this way for logging purposes as opposed simply using chromadb\\'s `get_or_create_collection` method\\n                directly.\\n\\n        Examples:\\n            ```Python\\n            from postcode.databases.chroma import ChromaDBClientBuilder, ChromaDBClientManager\\n            import postcode.types.chromadb.types as chroma_types\\n\\n            from example_module_with_manager_defined import client_manager\\n\\n            # Create or get a collection using the client_manager instance\\n            collection: chroma_types.Collection = client_manager.get_or_create_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n    logging.info(f\"Getting or creating collection: {name}\")\\n    return self.client.get_or_create_collection(\\n        name,\\n        metadata=metadata,\\n        embedding_function=embedding_function,\\n    )\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "delete_collection",
                    "docstring": "Deletes a ChromaDB collection with the given name.\n\nArgs:\n    - name (str): The name of the collection to delete.\n\nRaises:\n    - ValueError: If the collection does not exist.\n\nExamples:\n    ```Python\n    client_manager.delete_collection(\"my_collection\")\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-delete_collection",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 92,
                    "end_line_num": 114,
                    "code_content": "\ndef delete_collection(self, name: str) -> None:\n    \"\"\"\n        Deletes a ChromaDB collection with the given name.\n\n        Args:\n            - name (str): The name of the collection to delete.\n\n        Raises:\n            - ValueError: If the collection does not exist.\n\n        Examples:\n            ```Python\n            client_manager.delete_collection(\"my_collection\")\n            ```\n        \"\"\"\n\n    if self.client.get_collection(name):\n        logging.info(f\"Deleting collection {name}\")\n        self.client.delete_collection(name)\n    else:\n        raise ValueError(f\"Collection {name} does not exist.\")\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef delete_collection(self, name: str) -> None:\\n    \"\"\"\\n        Deletes a ChromaDB collection with the given name.\\n\\n        Args:\\n            - name (str): The name of the collection to delete.\\n\\n        Raises:\\n            - ValueError: If the collection does not exist.\\n\\n        Examples:\\n            ```Python\\n            client_manager.delete_collection(\"my_collection\")\\n            ```\\n        \"\"\"\\n\\n    if self.client.get_collection(name):\\n        logging.info(f\"Deleting collection {name}\")\\n        self.client.delete_collection(name)\\n    else:\\n        raise ValueError(f\"Collection {name} does not exist.\")\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "list_collections",
                    "docstring": "Lists all ChromaDB collections.\n\nReturns:\n    - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\n        Model with the following attributes:\n            - name: str\n            - id: UUID\n            - metadata: CollectionMetadata | None\n            - tenant: str | None\n            - database: str | None\n\nExamples:\n    ```Python\n    collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "Sequence[]",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-list_collections",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 114,
                    "end_line_num": 135,
                    "code_content": "\ndef list_collections(self) -> Sequence[chroma_types.Collection]:\n    \"\"\"\n        Lists all ChromaDB collections.\n\n        Returns:\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\n                Model with the following attributes:\n                    - name: str\n                    - id: UUID\n                    - metadata: CollectionMetadata | None\n                    - tenant: str | None\n                    - database: str | None\n\n        Examples:\n            ```Python\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\n            ```\n        \"\"\"\n\n    return self.client.list_collections()\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef list_collections(self) -> Sequence[chroma_types.Collection]:\\n    \"\"\"\\n        Lists all ChromaDB collections.\\n\\n        Returns:\\n            - client_list (Sequence[chroma.Collection]): A list of all ChromaDB collections A collection object is a Pydantic\\n                Model with the following attributes:\\n                    - name: str\\n                    - id: UUID\\n                    - metadata: CollectionMetadata | None\\n                    - tenant: str | None\\n                    - database: str | None\\n\\n        Examples:\\n            ```Python\\n            collections_list: Sequence[chroma_types.Collection] = client_manager.list_collections()\\n            ```\\n        \"\"\"\\n\\n    return self.client.list_collections()\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "get_client_settings",
                    "docstring": "Gets the setting used to instantiate the ChromaDB client.\n\nReturns:\n    - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\n\nExamples:\n    ```Python\n    settings: chroma_types.Settings = client_manager.get_client_settings()\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "No return annotation",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-get_client_settings",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 135,
                    "end_line_num": 150,
                    "code_content": "\ndef get_client_settings(self) -> chroma_types.Settings:\n    \"\"\"\n        Gets the setting used to instantiate the ChromaDB client.\n\n        Returns:\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\n\n        Examples:\n            ```Python\n            settings: chroma_types.Settings = client_manager.get_client_settings()\n            ```\n        \"\"\"\n\n    return self.client.get_settings()\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef get_client_settings(self) -> chroma_types.Settings:\\n    \"\"\"\\n        Gets the setting used to instantiate the ChromaDB client.\\n\\n        Returns:\\n            - settings (chroma_types.Settings): The client settings as a settings object defined by ChromaDB.\\n\\n        Examples:\\n            ```Python\\n            settings: chroma_types.Settings = client_manager.get_client_settings()\\n            ```\\n        \"\"\"\\n\\n    return self.client.get_settings()\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                },
                {
                    "function_name": "reset_client",
                    "docstring": "Resets the ChromaDB client to its initial state.\n\nThis method resets the client settings and clears any cached or temporary data.\nIt iterates over the collections, logging their names, and then resets the client.\nIf the reset operation is unsuccessful, it raises a ValueError.\n\nRaises:\n    ValueError: If the client reset operation is unsuccessful.\n\nNotes:\n    This method loops through the collections_list as opposed to immediately calling ChromaDB's\n        `reset` method for logging purposes.\n\nExamples:\n    ```Python\n    client_manager.reset_client()  # Resets the client and logs the collections\n    ```",
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager__*__FUNCTION-reset_client",
                    "parent_id": "postcode:databases:chroma:chromadb_client_manager.py__*__MODULE__*__CLASS-ChromaDBClientManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 150,
                    "end_line_num": 185,
                    "code_content": "\ndef reset_client(self) -> None:\n    \"\"\"\n        Resets the ChromaDB client to its initial state.\n\n        This method resets the client settings and clears any cached or temporary data.\n        It iterates over the collections, logging their names, and then resets the client.\n        If the reset operation is unsuccessful, it raises a ValueError.\n\n        Raises:\n            ValueError: If the client reset operation is unsuccessful.\n\n        Notes:\n            This method loops through the collections_list as opposed to immediately calling ChromaDB's\n                `reset` method for logging purposes.\n\n        Examples:\n            ```Python\n            client_manager.reset_client()  # Resets the client and logs the collections\n            ```\n        \"\"\"\n    reset_successful: bool = self.client.reset()\n    if reset_successful:\n        print(\"Resetting client with:\")\n\n        if collections := self.list_collections():\n            for collection in collections:\n                print(f\"\\tCollection: {collection.name}\")\n        else:\n            print(\"No collections.\")\n\n        self.client.reset()\n        logging.info(\"Client reset successful.\")\n    else:\n        raise ValueError(\"Client reset unsuccessful.\")\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\ndef reset_client(self) -> None:\\n    \"\"\"\\n        Resets the ChromaDB client to its initial state.\\n\\n        This method resets the client settings and clears any cached or temporary data.\\n        It iterates over the collections, logging their names, and then resets the client.\\n        If the reset operation is unsuccessful, it raises a ValueError.\\n\\n        Raises:\\n            ValueError: If the client reset operation is unsuccessful.\\n\\n        Notes:\\n            This method loops through the collections_list as opposed to immediately calling ChromaDB\\'s\\n                `reset` method for logging purposes.\\n\\n        Examples:\\n            ```Python\\n            client_manager.reset_client()  # Resets the client and logs the collections\\n            ```\\n        \"\"\"\\n    reset_successful: bool = self.client.reset()\\n    if reset_successful:\\n        print(\"Resetting client with:\")\\n\\n        if collections := self.list_collections():\\n            for collection in collections:\\n                print(f\"\\\\tCollection: {collection.name}\")\\n        else:\\n            print(\"No collections.\")\\n\\n        self.client.reset()\\n        logging.info(\"Client reset successful.\")\\n    else:\\n        raise ValueError(\"Client reset unsuccessful.\")\\n\\n```\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
                    "children": null
                }
            ]
        }
    ]
}