{
    "file_path": "./arango_db/arango_db_manager_old.py",
    "docstring": null,
    "header": [
        "# import os",
        "# import json",
        "# from typing import Literal",
        "# from arango import ArangoError",
        "# from arango.client import ArangoClient",
        "# from arango.database import StandardDatabase",
        "# from arango.cursor import Cursor",
        "# from arango.job import AsyncJob, BatchJob",
        "# from arango.result import Result",
        "# from arango.typings import Json, Jsons",
        "# class ArangoDBManager:",
        "#     def __init__(",
        "#         self,",
        "#         url: str = \"http://localhost:8529\",",
        "#         username: str = \"root\",",
        "#         password: str = \"openSesame\",",
        "#         db_name: str = \"post_code\",",
        "#     ) -> None:",
        "#         self.client = ArangoClient(hosts=url)",
        "#         self.username: str = username",
        "#         self.password: str = password",
        "#         self.db_name: str = db_name",
        "#         self.db: StandardDatabase = self._ensure_database()",
        "#     def _ensure_database(self) -> StandardDatabase:",
        "#         sys_db: StandardDatabase = self.client.db(",
        "#             \"_system\", username=self.username, password=self.password",
        "#         )",
        "#         if not sys_db.has_database(self.db_name):",
        "#             sys_db.create_database(self.db_name)",
        "#         return self.client.db(",
        "#             self.db_name, username=self.username, password=self.password",
        "#         )",
        "#     def _ensure_vertex_collections(self, vertex_collections: list[str]) -> None:",
        "#         for collection in vertex_collections:",
        "#             if not self.db.has_collection(collection):",
        "#                 self.db.create_collection(collection)",
        "#     def _ensure_edge_collections(self, edge_collections: list[str]) -> None:",
        "#         for collection in edge_collections:",
        "#             if not self.db.has_collection(collection):",
        "#                 self.db.create_collection(collection, edge=True)",
        "#     def process_graph_data(self, folder_path: str) -> None:",
        "#         vertex_collections: list[str] = [",
        "#             \"module\",",
        "#             \"class\",",
        "#             \"function\",",
        "#             \"standalone_code_block\",",
        "#         ]",
        "#         self._ensure_vertex_collections(vertex_collections)",
        "#         self._ensure_edge_collections([\"contains\"])",
        "#         for filename in os.listdir(folder_path):",
        "#             if filename.endswith(\".json\"):",
        "#                 file_path: str = os.path.join(folder_path, filename)",
        "#                 with open(file_path, \"r\") as file:",
        "#                     data = json.load(file)",
        "#                     self.process_document(data, None, vertex_collections, file_path)",
        "#     def process_document(self, data, parent_id, vertex_collections, file_path) -> None:",
        "#         block_type = data.get(\"block_type\", \"\").lower()",
        "#         print(f\"Block_type in `process_document`: {block_type}\")",
        "#         if block_type not in vertex_collections:",
        "#             return None",
        "#         collection_name: str = block_type",
        "#         try:",
        "#             data[\"_key\"] = data[\"id\"]  # Set _key to the id from JSON",
        "#             if block_type != \"module\":",
        "#                 if parent_id:",
        "#                     parent_collection_name = self.get_collection_name_from_id(parent_id)",
        "#                     if parent_collection_name is None:",
        "#                         print(",
        "#                             f\"Could not determine the parent collection for: {parent_id}\"",
        "#                         )",
        "#                         return",
        "#                     edge_data = {",
        "#                         \"_from\": f\"{parent_collection_name}/{parent_id}\",",
        "#                         \"_to\": f\"{collection_name}/{data['_key']}\",",
        "#                     }",
        "#                     self.db.collection(\"contains\").insert(edge_data)",
        "#             vertex_result: Result[bool | Json] = self.db.collection(",
        "#                 collection_name",
        "#             ).insert(data)",
        "#             if isinstance(vertex_result, dict) and \"_key\" in vertex_result:",
        "#                 children = data.get(\"children\")",
        "#                 if children is not None:",
        "#                     for child in children:",
        "#                         self.process_document(",
        "#                             child, data[\"id\"], vertex_collections, file_path",
        "#                         )",
        "#         except ArangoError as e:",
        "#             print(f\"Failed to insert document from file {file_path}: {e}\")",
        "#             print(f\"Failed to insert document from file {file_path}: {e}\")",
        "#     def get_collection_name_from_id(self, block_id):",
        "#         parts = block_id.split(\"__*__\")",
        "#         if len(parts) < 3:",
        "#             return None  # Invalid ID format",
        "#         # Extracting block type from the last part of the ID",
        "#         block_type_part = parts[-1]",
        "#         if block_type_part.startswith(\"MODULE\"):",
        "#             return \"module\"",
        "#         elif block_type_part.startswith(\"CLASS\"):",
        "#             # Determine if the class is a child of another class or a module",
        "#             parent_block_type = parts[-2].split(\"-\")[0]",
        "#             if parent_block_type == \"CLASS\":",
        "#                 return \"class\"",
        "#             elif parent_block_type == \"MODULE\":",
        "#                 return \"module\"",
        "#             elif parent_block_type == \"FUNCTION\":",
        "#                 return \"function\"",
        "#         elif block_type_part.startswith(\"FUNCTION\"):",
        "#             # Determine if the function is a child of a class, another function, or a module",
        "#             parent_block_type = parts[-2].split(\"-\")[0]",
        "#             if parent_block_type == \"CLASS\":",
        "#                 return \"class\"",
        "#             elif parent_block_type == \"MODULE\":",
        "#                 return \"module\"",
        "#             elif parent_block_type == \"FUNCTION\":",
        "#                 return \"function\"",
        "#         elif block_type_part.startswith(\"STANDALONE_CODE_BLOCK\"):",
        "#             return \"standalone_code_block\"",
        "#         else:",
        "#             return None",
        "#     def check_collection(self, collection_name) -> None:",
        "#         try:",
        "#             documents: Result[Cursor] = self.db.collection(collection_name).all()",
        "#             if isinstance(documents, Cursor):",
        "#                 docs: list[Cursor] = [doc for doc in documents]",
        "#                 print(f\"Total documents in {collection_name}: {len(docs)}\")",
        "#             elif isinstance(documents, (AsyncJob, BatchJob)):",
        "#                 print(",
        "#                     f\"Received an AsyncJob or BatchJob for collection {collection_name}\"",
        "#                 )",
        "#             else:",
        "#                 print(f\"No documents in {collection_name}\")",
        "#         except ArangoError as e:",
        "#             print(f\"An error occurred: {e}\")",
        "#     def check_edges(self) -> None:",
        "#         try:",
        "#             edges: Result[Cursor] = self.db.collection(\"contains\").all()",
        "#             if isinstance(edges, Cursor):",
        "#                 edges_list: list[Cursor] = [edge for edge in edges]",
        "#                 print(f\"Total edges: {len(edges_list)}\")",
        "#             elif isinstance(edges, (AsyncJob, BatchJob)):",
        "#                 print(f\"Received an AsyncJob or BatchJob for edges\")",
        "#             else:",
        "#                 print(f\"No edges in contains\")",
        "#         except ArangoError as e:",
        "#             print(f\"An error occurred: {e}\")",
        "#     def delete_all_collections(self) -> None:",
        "#         collections: Result[Jsons] = self.db.collections()",
        "#         for collection in collections:  # type: ignore # FIXME: Fix type error",
        "#             if not collection[\"name\"].startswith(\"_\"):  # Skip system collections",
        "#                 self.db.delete_collection(collection[\"name\"])",
        "#                 print(f\"Deleted collection: {collection['name']}\")",
        "#     def process_dependencies_and_imports(self) -> None:",
        "#         collections_to_check: list[str] = [\"module\", \"class\", \"function\"]",
        "#         for collection_name in collections_to_check:",
        "#             documents_result: Result[Cursor] = self.db.collection(collection_name).all()",
        "#             if isinstance(documents_result, (AsyncJob, BatchJob)):",
        "#                 print(",
        "#                     f\"Received an AsyncJob or BatchJob for collection {collection_name}\"",
        "#                 )",
        "#                 continue",
        "#             documents: Cursor | None = (",
        "#                 documents_result  # Assuming it's a Cursor or None",
        "#             )",
        "#             if documents is None:",
        "#                 print(f\"No documents found in collection {collection_name}\")",
        "#                 continue",
        "#             for doc in documents:",
        "#                 if not doc:",
        "#                     continue",
        "#                 current_block_id = doc[\"_key\"]",
        "#                 print(",
        "#                     f\"Processing document: {current_block_id} in collection: {collection_name}\"",
        "#                 )",
        "#                 imports = doc.get(\"imports\", [])",
        "#                 if not imports:",
        "#                     print(f\"No imports found for document: {current_block_id}\")",
        "#                 else:",
        "#                     for import_entry in imports:",
        "#                         self.process_import_or_dependency(",
        "#                             import_entry, collection_name, current_block_id, \"imports\"",
        "#                         )",
        "#                 dependencies = doc.get(\"dependencies\", [])",
        "#                 if not dependencies:",
        "#                     print(f\"No dependencies found for document: {current_block_id}\")",
        "#                 else:",
        "#                     for dependency in dependencies:",
        "#                         self.process_import_or_dependency(",
        "#                             dependency,",
        "#                             collection_name,",
        "#                             current_block_id,",
        "#                             \"dependencies\",",
        "#                         )",
        "#     def process_import_or_dependency(",
        "#         self, entry, collection_name, current_block_id, entry_type",
        "#     ):",
        "#         import_module_type: str = entry.get(\"import_module_type\")",
        "#         if import_module_type == \"LOCAL\":",
        "#             print(f\"\\nFound local {entry_type} for {current_block_id}\")",
        "#             # Handling imports",
        "#             if entry_type == \"imports\":",
        "#                 import_names: list[dict[str, str]] = entry.get(\"import_names\", [])",
        "#                 if not import_names:",
        "#                     print(f\"No import names found for {current_block_id}\")",
        "#                     return",
        "#                 for import_name in import_names:",
        "#                     target_block_id: str | None = import_name.get(\"local_block_id\")",
        "#                     if not target_block_id:",
        "#                         print(f\"Skipped import with no target block id\")",
        "#                         continue",
        "#                     self.create_edge(",
        "#                         collection_name, current_block_id, target_block_id, entry_type",
        "#                     )",
        "#             # Handling dependencies",
        "#             elif entry_type == \"dependencies\":",
        "#                 target_block_id = entry.get(\"code_block_id\")",
        "#                 if not target_block_id:",
        "#                     print(f\"Skipped dependency with no target block id\")",
        "#                     return",
        "#                 self.create_edge(",
        "#                     collection_name, current_block_id, target_block_id, entry_type",
        "#                 )",
        "#     def create_edge(",
        "#         self, collection_name, current_block_id, target_block_id, entry_type",
        "#     ) -> None:",
        "#         # Determine the correct collection based on the type in the target_block_id",
        "#         target_collection: Literal[",
        "#             \"module\", \"class\", \"function\", \"standalone_code_block\"",
        "#         ] | None = self.determine_collection(target_block_id)",
        "#         if not target_collection:",
        "#             print(f\"Could not determine the target collection for: {target_block_id}\")",
        "#             return",
        "#         # Adjust the target_block_id to use only the unique identifier part",
        "#         target_block_key = target_block_id.split(\"__*__\")[-1]",
        "#         # Check if the target collection exists and if the target block exists in the collection",
        "#         if not self.db.has_collection(target_collection) or not self.db.collection(",
        "#             target_collection",
        "#         ).has(target_block_key):",
        "#             print(",
        "#                 f\"Target block not found: {target_block_id} in collection: {target_collection}\"",
        "#             )",
        "#             return",
        "#         print(",
        "#             f\"Found target for {entry_type}: {target_block_id} in collection: {target_collection}\"",
        "#         )",
        "#         try:",
        "#             self.db.collection(\"contains\").insert(",
        "#                 {",
        "#                     \"_from\": f\"{collection_name}/{current_block_id}\",",
        "#                     \"_to\": f\"{target_collection}/{target_block_key}\",",
        "#                 }",
        "#             )",
        "#             print(",
        "#                 f\"Inserted edge from {current_block_id} to {target_block_key} for {entry_type}\"",
        "#             )",
        "#         except ArangoError as e:",
        "#             print(f\"Error inserting edge for {entry_type}: {e}\")",
        "#     def determine_collection(self, block_id):",
        "#         parts = block_id.split(\"__*__\")",
        "#         if len(parts) < 3:",
        "#             return None  # Invalid ID format",
        "#         if parts[-1] == \"MODULE\":",
        "#             return \"module\"",
        "#         block_type: str = parts[-1].split(\"-\")[0]",
        "#         print(f\"Block type: {block_type}\")",
        "#         if block_type == \"CLASS\":",
        "#             return \"class\"",
        "#         elif block_type == \"FUNCTION\":",
        "#             return \"function\"",
        "#         elif block_type == \"STANDALONE_CODE_BLOCK\":",
        "#             return \"standalone_code_block\"",
        "#         else:",
        "#             return None",
        "# # Usage example",
        "# db_manager = ArangoDBManager()",
        "# db_manager.delete_all_collections()",
        "# db_manager.process_graph_data(",
        "#     \"/Users/evanschultz/Documents/Code/post-code/output/json/\"",
        "# )",
        "# db_manager.process_dependencies_and_imports()"
    ],
    "footer": [
        "# # Usage example",
        "# db_manager = ArangoDBManager()",
        "# db_manager.delete_all_collections()",
        "# db_manager.process_graph_data(",
        "#     \"/Users/evanschultz/Documents/Code/post-code/output/json/\"",
        "# )",
        "# db_manager.process_dependencies_and_imports()"
    ],
    "imports": [
        {
            "import_names": [
                {
                    "name": "os",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "json",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Literal",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ArangoClient",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.client",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "StandardDatabase",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.database",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Cursor",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.cursor",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "AsyncJob",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "BatchJob",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.job",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Result",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.result",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Json",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Jsons",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango.typings",
            "import_module_type": "LOCAL",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "ArangoError",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "arango",
            "import_module_type": "LOCAL",
            "local_module_id": ".:arango_db:arango_db_manager.py__*__MODULE"
        }
    ],
    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE",
    "parent_id": null,
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 383,
    "code_content": "# import os\n# import json\n# from typing import Literal\n\n# from arango import ArangoError\n# from arango.client import ArangoClient\n# from arango.database import StandardDatabase\n# from arango.cursor import Cursor\n# from arango.job import AsyncJob, BatchJob\n# from arango.result import Result\n# from arango.typings import Json, Jsons\n\n\n# class ArangoDBManager:\n#     def __init__(\n#         self,\n#         url: str = \"http://localhost:8529\",\n#         username: str = \"root\",\n#         password: str = \"openSesame\",\n#         db_name: str = \"post_code\",\n#     ) -> None:\n#         self.client = ArangoClient(hosts=url)\n#         self.username: str = username\n#         self.password: str = password\n#         self.db_name: str = db_name\n#         self.db: StandardDatabase = self._ensure_database()\n\n#     def _ensure_database(self) -> StandardDatabase:\n#         sys_db: StandardDatabase = self.client.db(\n#             \"_system\", username=self.username, password=self.password\n#         )\n#         if not sys_db.has_database(self.db_name):\n#             sys_db.create_database(self.db_name)\n#         return self.client.db(\n#             self.db_name, username=self.username, password=self.password\n#         )\n\n#     def _ensure_vertex_collections(self, vertex_collections: list[str]) -> None:\n#         for collection in vertex_collections:\n#             if not self.db.has_collection(collection):\n#                 self.db.create_collection(collection)\n\n#     def _ensure_edge_collections(self, edge_collections: list[str]) -> None:\n#         for collection in edge_collections:\n#             if not self.db.has_collection(collection):\n#                 self.db.create_collection(collection, edge=True)\n\n#     def process_graph_data(self, folder_path: str) -> None:\n#         vertex_collections: list[str] = [\n#             \"module\",\n#             \"class\",\n#             \"function\",\n#             \"standalone_code_block\",\n#         ]\n#         self._ensure_vertex_collections(vertex_collections)\n#         self._ensure_edge_collections([\"contains\"])\n\n#         for filename in os.listdir(folder_path):\n#             if filename.endswith(\".json\"):\n#                 file_path: str = os.path.join(folder_path, filename)\n#                 with open(file_path, \"r\") as file:\n#                     data = json.load(file)\n#                     self.process_document(data, None, vertex_collections, file_path)\n\n#     def process_document(self, data, parent_id, vertex_collections, file_path) -> None:\n#         block_type = data.get(\"block_type\", \"\").lower()\n#         print(f\"Block_type in `process_document`: {block_type}\")\n\n#         if block_type not in vertex_collections:\n#             return None\n\n#         collection_name: str = block_type\n#         try:\n#             data[\"_key\"] = data[\"id\"]  # Set _key to the id from JSON\n#             if block_type != \"module\":\n#                 if parent_id:\n#                     parent_collection_name = self.get_collection_name_from_id(parent_id)\n#                     if parent_collection_name is None:\n#                         print(\n#                             f\"Could not determine the parent collection for: {parent_id}\"\n#                         )\n#                         return\n#                     edge_data = {\n#                         \"_from\": f\"{parent_collection_name}/{parent_id}\",\n#                         \"_to\": f\"{collection_name}/{data['_key']}\",\n#                     }\n#                     self.db.collection(\"contains\").insert(edge_data)\n\n#             vertex_result: Result[bool | Json] = self.db.collection(\n#                 collection_name\n#             ).insert(data)\n#             if isinstance(vertex_result, dict) and \"_key\" in vertex_result:\n#                 children = data.get(\"children\")\n#                 if children is not None:\n#                     for child in children:\n#                         self.process_document(\n#                             child, data[\"id\"], vertex_collections, file_path\n#                         )\n#         except ArangoError as e:\n#             print(f\"Failed to insert document from file {file_path}: {e}\")\n\n#             print(f\"Failed to insert document from file {file_path}: {e}\")\n\n#     def get_collection_name_from_id(self, block_id):\n#         parts = block_id.split(\"__*__\")\n#         if len(parts) < 3:\n#             return None  # Invalid ID format\n\n#         # Extracting block type from the last part of the ID\n#         block_type_part = parts[-1]\n#         if block_type_part.startswith(\"MODULE\"):\n#             return \"module\"\n#         elif block_type_part.startswith(\"CLASS\"):\n#             # Determine if the class is a child of another class or a module\n#             parent_block_type = parts[-2].split(\"-\")[0]\n#             if parent_block_type == \"CLASS\":\n#                 return \"class\"\n#             elif parent_block_type == \"MODULE\":\n#                 return \"module\"\n#             elif parent_block_type == \"FUNCTION\":\n#                 return \"function\"\n#         elif block_type_part.startswith(\"FUNCTION\"):\n#             # Determine if the function is a child of a class, another function, or a module\n#             parent_block_type = parts[-2].split(\"-\")[0]\n#             if parent_block_type == \"CLASS\":\n#                 return \"class\"\n#             elif parent_block_type == \"MODULE\":\n#                 return \"module\"\n#             elif parent_block_type == \"FUNCTION\":\n#                 return \"function\"\n#         elif block_type_part.startswith(\"STANDALONE_CODE_BLOCK\"):\n#             return \"standalone_code_block\"\n#         else:\n#             return None\n\n#     def check_collection(self, collection_name) -> None:\n#         try:\n#             documents: Result[Cursor] = self.db.collection(collection_name).all()\n#             if isinstance(documents, Cursor):\n#                 docs: list[Cursor] = [doc for doc in documents]\n#                 print(f\"Total documents in {collection_name}: {len(docs)}\")\n#             elif isinstance(documents, (AsyncJob, BatchJob)):\n#                 print(\n#                     f\"Received an AsyncJob or BatchJob for collection {collection_name}\"\n#                 )\n#             else:\n#                 print(f\"No documents in {collection_name}\")\n#         except ArangoError as e:\n#             print(f\"An error occurred: {e}\")\n\n#     def check_edges(self) -> None:\n#         try:\n#             edges: Result[Cursor] = self.db.collection(\"contains\").all()\n#             if isinstance(edges, Cursor):\n#                 edges_list: list[Cursor] = [edge for edge in edges]\n#                 print(f\"Total edges: {len(edges_list)}\")\n#             elif isinstance(edges, (AsyncJob, BatchJob)):\n#                 print(f\"Received an AsyncJob or BatchJob for edges\")\n#             else:\n#                 print(f\"No edges in contains\")\n#         except ArangoError as e:\n#             print(f\"An error occurred: {e}\")\n\n#     def delete_all_collections(self) -> None:\n#         collections: Result[Jsons] = self.db.collections()\n\n#         for collection in collections:  # type: ignore # FIXME: Fix type error\n#             if not collection[\"name\"].startswith(\"_\"):  # Skip system collections\n#                 self.db.delete_collection(collection[\"name\"])\n#                 print(f\"Deleted collection: {collection['name']}\")\n\n#     def process_dependencies_and_imports(self) -> None:\n#         collections_to_check: list[str] = [\"module\", \"class\", \"function\"]\n\n#         for collection_name in collections_to_check:\n#             documents_result: Result[Cursor] = self.db.collection(collection_name).all()\n#             if isinstance(documents_result, (AsyncJob, BatchJob)):\n#                 print(\n#                     f\"Received an AsyncJob or BatchJob for collection {collection_name}\"\n#                 )\n#                 continue\n\n#             documents: Cursor | None = (\n#                 documents_result  # Assuming it's a Cursor or None\n#             )\n#             if documents is None:\n#                 print(f\"No documents found in collection {collection_name}\")\n#                 continue\n\n#             for doc in documents:\n#                 if not doc:\n#                     continue\n\n#                 current_block_id = doc[\"_key\"]\n#                 print(\n#                     f\"Processing document: {current_block_id} in collection: {collection_name}\"\n#                 )\n\n#                 imports = doc.get(\"imports\", [])\n#                 if not imports:\n#                     print(f\"No imports found for document: {current_block_id}\")\n#                 else:\n#                     for import_entry in imports:\n#                         self.process_import_or_dependency(\n#                             import_entry, collection_name, current_block_id, \"imports\"\n#                         )\n\n#                 dependencies = doc.get(\"dependencies\", [])\n#                 if not dependencies:\n#                     print(f\"No dependencies found for document: {current_block_id}\")\n#                 else:\n#                     for dependency in dependencies:\n#                         self.process_import_or_dependency(\n#                             dependency,\n#                             collection_name,\n#                             current_block_id,\n#                             \"dependencies\",\n#                         )\n\n#     def process_import_or_dependency(\n#         self, entry, collection_name, current_block_id, entry_type\n#     ):\n#         import_module_type: str = entry.get(\"import_module_type\")\n#         if import_module_type == \"LOCAL\":\n#             print(f\"\\nFound local {entry_type} for {current_block_id}\")\n\n#             # Handling imports\n#             if entry_type == \"imports\":\n#                 import_names: list[dict[str, str]] = entry.get(\"import_names\", [])\n#                 if not import_names:\n#                     print(f\"No import names found for {current_block_id}\")\n#                     return\n\n#                 for import_name in import_names:\n#                     target_block_id: str | None = import_name.get(\"local_block_id\")\n#                     if not target_block_id:\n#                         print(f\"Skipped import with no target block id\")\n#                         continue\n#                     self.create_edge(\n#                         collection_name, current_block_id, target_block_id, entry_type\n#                     )\n\n#             # Handling dependencies\n#             elif entry_type == \"dependencies\":\n#                 target_block_id = entry.get(\"code_block_id\")\n#                 if not target_block_id:\n#                     print(f\"Skipped dependency with no target block id\")\n#                     return\n#                 self.create_edge(\n#                     collection_name, current_block_id, target_block_id, entry_type\n#                 )\n\n#     def create_edge(\n#         self, collection_name, current_block_id, target_block_id, entry_type\n#     ) -> None:\n#         # Determine the correct collection based on the type in the target_block_id\n#         target_collection: Literal[\n#             \"module\", \"class\", \"function\", \"standalone_code_block\"\n#         ] | None = self.determine_collection(target_block_id)\n\n#         if not target_collection:\n#             print(f\"Could not determine the target collection for: {target_block_id}\")\n#             return\n\n#         # Adjust the target_block_id to use only the unique identifier part\n#         target_block_key = target_block_id.split(\"__*__\")[-1]\n\n#         # Check if the target collection exists and if the target block exists in the collection\n#         if not self.db.has_collection(target_collection) or not self.db.collection(\n#             target_collection\n#         ).has(target_block_key):\n#             print(\n#                 f\"Target block not found: {target_block_id} in collection: {target_collection}\"\n#             )\n#             return\n\n#         print(\n#             f\"Found target for {entry_type}: {target_block_id} in collection: {target_collection}\"\n#         )\n#         try:\n#             self.db.collection(\"contains\").insert(\n#                 {\n#                     \"_from\": f\"{collection_name}/{current_block_id}\",\n#                     \"_to\": f\"{target_collection}/{target_block_key}\",\n#                 }\n#             )\n#             print(\n#                 f\"Inserted edge from {current_block_id} to {target_block_key} for {entry_type}\"\n#             )\n#         except ArangoError as e:\n#             print(f\"Error inserting edge for {entry_type}: {e}\")\n\n#     def determine_collection(self, block_id):\n#         parts = block_id.split(\"__*__\")\n#         if len(parts) < 3:\n#             return None  # Invalid ID format\n\n#         if parts[-1] == \"MODULE\":\n#             return \"module\"\n\n#         block_type: str = parts[-1].split(\"-\")[0]\n#         print(f\"Block type: {block_type}\")\n#         if block_type == \"CLASS\":\n#             return \"class\"\n#         elif block_type == \"FUNCTION\":\n#             return \"function\"\n#         elif block_type == \"STANDALONE_CODE_BLOCK\":\n#             return \"standalone_code_block\"\n#         else:\n#             return None\n\n\n# # Usage example\n# db_manager = ArangoDBManager()\n# db_manager.delete_all_collections()\n# db_manager.process_graph_data(\n#     \"/Users/evanschultz/Documents/Code/post-code/output/json/\"\n# )\n# db_manager.process_dependencies_and_imports()\nimport os\nimport json\nfrom typing import Literal\n\nfrom arango import ArangoError\nfrom arango.client import ArangoClient\nfrom arango.database import StandardDatabase\nfrom arango.cursor import Cursor\nfrom arango.job import AsyncJob, BatchJob\nfrom arango.result import Result\nfrom arango.typings import Json, Jsons\n\n\nclass ArangoDBManager:\n    def __init__(\n        self,\n        url: str = \"http://localhost:8529\",\n        username: str = \"root\",\n        password: str = \"openSesame\",\n        db_name: str = \"post_code\",\n    ) -> None:\n        self.client = ArangoClient(hosts=url)\n        self.username: str = username\n        self.password: str = password\n        self.db_name: str = db_name\n        self.db: StandardDatabase = self._ensure_database()\n\n    def _ensure_database(self) -> StandardDatabase:\n        sys_db: StandardDatabase = self.client.db(\n            \"_system\", username=self.username, password=self.password\n        )\n        if not sys_db.has_database(self.db_name):\n            sys_db.create_database(self.db_name)\n        return self.client.db(\n            self.db_name, username=self.username, password=self.password\n        )\n\n    def _ensure_vertex_collections(self, vertex_collections: list[str]) -> None:\n        for collection in vertex_collections:\n            if not self.db.has_collection(collection):\n                self.db.create_collection(collection)\n\n    def ensure_collection(self, collection_name: str) -> None:\n        if not self.db.has_collection(collection_name):\n            self.db.create_collection(collection_name)\n            print(f\"Created collection: {collection_name}\")\n\n    def delete_all_collections(self) -> None:\n        collections: Result[Jsons] = self.db.collections()\n\n        for collection in collections:  # type: ignore # FIXME: Fix type error\n            if not collection[\"name\"].startswith(\"_\"):  # Skip system collections\n                self.db.delete_collection(collection[\"name\"])\n                print(f\"Deleted collection: {collection['name']}\")\n\n\n# # Usage example\n# db_manager = ArangoDBManager()\n# db_manager.delete_all_collections()\n# db_manager.process_graph_data(\n#     \"/Users/evanschultz/Documents/Code/post-code/output/json/\"\n# )\n# db_manager.process_dependencies_and_imports()\n",
    "important_comments": [
        {
            "content": "#         for collection in collections:  # type: ignore # FIXME: Fix type error",
            "comment_types": [
                "FIXME"
            ]
        },
        {
            "content": "#         # Adjust the target_block_id to use only the unique identifier part",
            "comment_types": [
                "Q"
            ]
        }
    ],
    "dependencies": null,
    "summary": null,
    "children": [
        {
            "class_name": "ArangoDBManager",
            "decorators": null,
            "bases": null,
            "docstring": null,
            "attributes": null,
            "keywords": null,
            "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
            "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE",
            "block_type": "CLASS",
            "start_line_num": 331,
            "end_line_num": 374,
            "code_content": "\n\nclass ArangoDBManager:\n    def __init__(\n        self,\n        url: str = \"http://localhost:8529\",\n        username: str = \"root\",\n        password: str = \"openSesame\",\n        db_name: str = \"post_code\",\n    ) -> None:\n        self.client = ArangoClient(hosts=url)\n        self.username: str = username\n        self.password: str = password\n        self.db_name: str = db_name\n        self.db: StandardDatabase = self._ensure_database()\n\n    def _ensure_database(self) -> StandardDatabase:\n        sys_db: StandardDatabase = self.client.db(\n            \"_system\", username=self.username, password=self.password\n        )\n        if not sys_db.has_database(self.db_name):\n            sys_db.create_database(self.db_name)\n        return self.client.db(\n            self.db_name, username=self.username, password=self.password\n        )\n\n    def _ensure_vertex_collections(self, vertex_collections: list[str]) -> None:\n        for collection in vertex_collections:\n            if not self.db.has_collection(collection):\n                self.db.create_collection(collection)\n\n    def ensure_collection(self, collection_name: str) -> None:\n        if not self.db.has_collection(collection_name):\n            self.db.create_collection(collection_name)\n            print(f\"Created collection: {collection_name}\")\n\n    def delete_all_collections(self) -> None:\n        collections: Result[Jsons] = self.db.collections()\n\n        for collection in collections:  # type: ignore # FIXME: Fix type error\n            if not collection[\"name\"].startswith(\"_\"):  # Skip system collections\n                self.db.delete_collection(collection[\"name\"])\n                print(f\"Deleted collection: {collection['name']}\")\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "os",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "ArangoClient",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "arango.client",
                    "import_module_type": "LOCAL",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "StandardDatabase",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "arango.database",
                    "import_module_type": "LOCAL",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Result",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "arango.result",
                    "import_module_type": "LOCAL",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Json",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Jsons",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "arango.typings",
                    "import_module_type": "LOCAL",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "Json",
                            "as_name": null,
                            "local_block_id": null
                        },
                        {
                            "name": "Jsons",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "arango.typings",
                    "import_module_type": "LOCAL",
                    "local_module_id": null
                }
            ],
            "summary": null,
            "children": [
                {
                    "function_name": "__init__",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager__*__FUNCTION-__init__",
                    "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 334,
                    "end_line_num": 346,
                    "code_content": "def __init__(\n    self,\n    url: str = \"http://localhost:8529\",\n    username: str = \"root\",\n    password: str = \"openSesame\",\n    db_name: str = \"post_code\",\n) -> None:\n    self.client = ArangoClient(hosts=url)\n    self.username: str = username\n    self.password: str = password\n    self.db_name: str = db_name\n    self.db: StandardDatabase = self._ensure_database()\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": null,
                    "children": null
                },
                {
                    "function_name": "_ensure_database",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "StandardDatabase",
                    "is_method": true,
                    "is_async": false,
                    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager__*__FUNCTION-_ensure_database",
                    "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 346,
                    "end_line_num": 356,
                    "code_content": "\ndef _ensure_database(self) -> StandardDatabase:\n    sys_db: StandardDatabase = self.client.db(\n        \"_system\", username=self.username, password=self.password\n    )\n    if not sys_db.has_database(self.db_name):\n        sys_db.create_database(self.db_name)\n    return self.client.db(\n        self.db_name, username=self.username, password=self.password\n    )\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": null,
                    "children": null
                },
                {
                    "function_name": "_ensure_vertex_collections",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager__*__FUNCTION-_ensure_vertex_collections",
                    "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 356,
                    "end_line_num": 361,
                    "code_content": "\ndef _ensure_vertex_collections(self, vertex_collections: list[str]) -> None:\n    for collection in vertex_collections:\n        if not self.db.has_collection(collection):\n            self.db.create_collection(collection)\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": null,
                    "children": null
                },
                {
                    "function_name": "ensure_collection",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager__*__FUNCTION-ensure_collection",
                    "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 361,
                    "end_line_num": 366,
                    "code_content": "\ndef ensure_collection(self, collection_name: str) -> None:\n    if not self.db.has_collection(collection_name):\n        self.db.create_collection(collection_name)\n        print(f\"Created collection: {collection_name}\")\n",
                    "important_comments": null,
                    "dependencies": null,
                    "summary": null,
                    "children": null
                },
                {
                    "function_name": "delete_all_collections",
                    "docstring": null,
                    "decorators": null,
                    "parameters": null,
                    "returns": "None",
                    "is_method": true,
                    "is_async": false,
                    "id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager__*__FUNCTION-delete_all_collections",
                    "parent_id": ".:arango_db:arango_db_manager_old.py__*__MODULE__*__CLASS-ArangoDBManager",
                    "block_type": "FUNCTION",
                    "start_line_num": 366,
                    "end_line_num": 374,
                    "code_content": "\ndef delete_all_collections(self) -> None:\n    collections: Result[Jsons] = self.db.collections()\n\n    for collection in collections:  # type: ignore # FIXME: Fix type error\n        if not collection[\"name\"].startswith(\"_\"):  # Skip system collections\n            self.db.delete_collection(collection[\"name\"])\n            print(f\"Deleted collection: {collection['name']}\")\n",
                    "important_comments": [
                        {
                            "content": "# type: ignore # FIXME: Fix type error",
                            "comment_types": [
                                "FIXME"
                            ]
                        }
                    ],
                    "dependencies": null,
                    "summary": null,
                    "children": null
                }
            ]
        }
    ]
}