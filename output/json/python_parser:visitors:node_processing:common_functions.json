{
    "file_path": "python_parser/visitors/node_processing/common_functions.py",
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "CommentModel",
                    "as_name": null,
                    "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-CommentModel"
                },
                {
                    "name": "DecoratorModel",
                    "as_name": null,
                    "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                }
            ],
            "imported_from": "python_parser.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "python_parser:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "CommentType",
                    "as_name": null,
                    "local_block_id": "python_parser:models:enums.py__*__MODULE__*__CLASS-CommentType"
                }
            ],
            "imported_from": "python_parser.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "python_parser:models:enums.py__*__MODULE"
        }
    ],
    "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
    "parent_id": null,
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 245,
    "code_content": "import logging\nfrom typing import Sequence\nimport libcst\n\n\nfrom python_parser.models.models import CommentModel, DecoratorModel\nfrom python_parser.models.enums import CommentType\n\n\ndef extract_code_content(\n    node: libcst.CSTNode,\n) -> str:\n    \"\"\"\n    Extracts the code content from a given CST node.\n\n    This function converts a CST node to its string representation, maintaining the original code format.\n\n    Args:\n        node (libcst.CSTNode): The CST node to extract code from.\n\n    Returns:\n        str: The string representation of the code for the given CST node.\n\n    Example:\n        >>> extract_code_content(some_cst_node)\n        # Returns the code content as a string.\n    \"\"\"\n\n    return libcst.Module([]).code_for_node(node)\n\n\ndef extract_stripped_code_content(\n    node: libcst.CSTNode,\n) -> str:\n    \"\"\"\n    Extracts the stripped code content from a given CST node.\n\n    Similar to extract_code_content, but also strips leading and trailing whitespace from the code string.\n\n    Args:\n        node (libcst.CSTNode): The CST node to extract code from.\n\n    Returns:\n        str: The stripped string representation of the code for the CST node.\n\n    Example:\n        >>> extract_stripped_code_content(some_cst_node)\n        # Returns the stripped code content as a string.\n    \"\"\"\n\n    return extract_code_content(node).strip()\n\n\ndef extract_important_comment(\n    comment_or_empty_line_node: libcst.CSTNode,\n) -> CommentModel | None:\n    \"\"\"\n    Extracts an important comment from a given CST node.\n\n    Processes a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\n\n    Args:\n        comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\n\n    Returns:\n        CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\n\n    Example:\n        >>> extract_important_comment(some_comment_node)\n        # Returns a CommentModel for the comment, or None if not important.\n    \"\"\"\n\n    comment_text: str | None = None\n\n    if isinstance(comment_or_empty_line_node, libcst.EmptyLine):\n        if comment_or_empty_line_node.comment:\n            comment_text = comment_or_empty_line_node.comment.value\n    elif isinstance(comment_or_empty_line_node, libcst.Comment):\n        comment_text = comment_or_empty_line_node.value\n\n    if not comment_text:\n        return None\n\n    comment_types: list[CommentType] = [\n        comment_type\n        for comment_type in CommentType\n        if comment_type.value in comment_text.upper()\n    ]\n\n    if comment_types:\n        return CommentModel(\n            content=comment_text,\n            comment_types=comment_types,\n        )\n\n\ndef extract_decorators(\n    decorators: Sequence[libcst.Decorator],\n) -> list[DecoratorModel] | None:\n    \"\"\"\n    Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\n\n    Processes each decorator node to form a model representing the decorator's name and its arguments, if any.\n\n    Args:\n        decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\n\n    Returns:\n        list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\n\n    Example:\n        >>> extract_decorators(function_node.decorators)\n        # Returns a list of DecoratorModel objects representing each decorator in the function.\n    \"\"\"\n\n    decorators_list: list[DecoratorModel] = []\n    for decorator in decorators:\n        decorator_model: DecoratorModel | None = extract_decorator(decorator)\n        if isinstance(decorator_model, DecoratorModel):\n            decorators_list.append(extract_decorator(decorator))  # type: ignore\n    return decorators_list if decorators_list else None\n\n\ndef extract_decorator(\n    decorator: libcst.Decorator,\n) -> DecoratorModel | None:\n    \"\"\"\n    Extracts the decorator from a libcst.Decorator node.\n\n    Processes a single decorator node to create a model representing the decorator's name and arguments.\n\n    Args:\n        decorator (libcst.Decorator): A libcst.Decorator node.\n\n    Returns:\n        DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\n\n    Example:\n        >>> extract_decorator(some_decorator_node)\n        # Returns a DecoratorModel object for the decorator.\n    \"\"\"\n\n    decorator_name: str = \"\"\n    arg_list: list[str] | None = None\n    if isinstance(decorator.decorator, libcst.Name):\n        decorator_name: str = decorator.decorator.value\n    if isinstance(decorator.decorator, libcst.Call):\n        func = decorator.decorator.func\n        if isinstance(func, libcst.Name) or isinstance(func, libcst.Attribute):\n            if decorator.decorator.args:\n                arg_list = [\n                    extract_stripped_code_content(arg)\n                    for arg in decorator.decorator.args\n                ]\n        if isinstance(func, libcst.Name):\n            decorator_name = func.value\n        elif isinstance(func, libcst.Attribute):\n            decorator_name = func.attr.value\n        else:\n            logging.warning(\"Decorator func is not a Name or Attribute node\")\n\n    return (\n        DecoratorModel(\n            content=extract_stripped_code_content(decorator),\n            decorator_name=decorator_name,\n            decorator_args=arg_list,\n        )\n        if decorator_name\n        else None\n    )\n\n\ndef extract_type_annotation(node: libcst.CSTNode) -> str | None:\n    \"\"\"\n    Extracts the type annotation from a node.\n\n    Processes a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\n\n    Args:\n        node (libcst.CSTNode): The node to extract the type annotation from.\n\n    Returns:\n        str | None: The extracted type annotation as a string, or None if no type annotation is found.\n    \"\"\"\n\n    annotation: libcst.Annotation | None = _get_node_annotation(node)\n    if annotation and isinstance(annotation, libcst.Annotation):\n        return _process_type_annotation_expression(annotation.annotation)\n    return None\n\n\ndef _get_node_annotation(node: libcst.CSTNode) -> libcst.Annotation | None:\n    \"\"\"Retrieves the annotation of a given CSTNode.\"\"\"\n\n    if isinstance(node, libcst.Param) or isinstance(node, libcst.AnnAssign):\n        return node.annotation\n    elif isinstance(node, libcst.Annotation):\n        return node\n    return None\n\n\ndef _process_type_annotation_expression(expression: libcst.BaseExpression) -> str:\n    \"\"\"Process the type annotation expression and return a string representation recursively.\"\"\"\n\n    if isinstance(expression, libcst.Subscript):\n        return _extract_generic_types_from_subscript(expression)\n    elif isinstance(expression, libcst.BinaryOperation):\n        left: str = _process_type_annotation_expression(expression.left)\n        right: str = _process_type_annotation_expression(expression.right)\n        return f\"{left} | {right}\"\n    elif isinstance(expression, libcst.Name):\n        return expression.value\n    return \"\"\n\n\ndef _extract_generic_types_from_subscript(\n    node: libcst.Subscript | libcst.BaseExpression,\n) -> str:\n    \"\"\"Recursively extracts generic types from a Subscript node or a BaseExpression node.\"\"\"\n\n    if isinstance(node, libcst.Subscript):\n        generics: list[str] = []\n        for element in node.slice:\n            if isinstance(element.slice, libcst.Index):\n                if isinstance(element.slice.value, libcst.BinaryOperation):\n                    union_type: str = _process_type_annotation_expression(\n                        element.slice.value\n                    )\n                    generics.append(union_type)\n                else:\n                    generic_type: str = _extract_generic_types_from_subscript(\n                        element.slice.value\n                    )\n                    generics.append(generic_type)\n\n        if isinstance(node.value, libcst.Name):\n            generics_str = \", \".join(generics)\n            return f\"{node.value.value}[{generics_str}]\"\n        else:\n            return \"\"\n\n    elif isinstance(node, libcst.Name):\n        return node.value\n    return \"\"\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nNOTE: Below the code are summaries, `CHILDREN_SUMMARIES`. The `CHILDREN_SUMMARIES of summaries of all \\nof the code blocks defined in the `CODE`. Use these summaries to help you write your summary of the \\n`CODE`, directly referencing the immediate children and the imports the `CODE` depends on. \\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\nimport logging\\nfrom typing import Sequence\\nimport libcst\\n\\n\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\nfrom python_parser.models.enums import CommentType\\n\\n\\ndef extract_code_content(\\n    node: libcst.CSTNode,\\n) -> str:\\n    \"\"\"\\n    Extracts the code content from a given CST node.\\n\\n    This function converts a CST node to its string representation, maintaining the original code format.\\n\\n    Args:\\n        node (libcst.CSTNode): The CST node to extract code from.\\n\\n    Returns:\\n        str: The string representation of the code for the given CST node.\\n\\n    Example:\\n        >>> extract_code_content(some_cst_node)\\n        # Returns the code content as a string.\\n    \"\"\"\\n\\n    return libcst.Module([]).code_for_node(node)\\n\\n\\ndef extract_stripped_code_content(\\n    node: libcst.CSTNode,\\n) -> str:\\n    \"\"\"\\n    Extracts the stripped code content from a given CST node.\\n\\n    Similar to extract_code_content, but also strips leading and trailing whitespace from the code string.\\n\\n    Args:\\n        node (libcst.CSTNode): The CST node to extract code from.\\n\\n    Returns:\\n        str: The stripped string representation of the code for the CST node.\\n\\n    Example:\\n        >>> extract_stripped_code_content(some_cst_node)\\n        # Returns the stripped code content as a string.\\n    \"\"\"\\n\\n    return extract_code_content(node).strip()\\n\\n\\ndef extract_important_comment(\\n    comment_or_empty_line_node: libcst.CSTNode,\\n) -> CommentModel | None:\\n    \"\"\"\\n    Extracts an important comment from a given CST node.\\n\\n    Processes a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\\n\\n    Args:\\n        comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\\n\\n    Returns:\\n        CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\\n\\n    Example:\\n        >>> extract_important_comment(some_comment_node)\\n        # Returns a CommentModel for the comment, or None if not important.\\n    \"\"\"\\n\\n    comment_text: str | None = None\\n\\n    if isinstance(comment_or_empty_line_node, libcst.EmptyLine):\\n        if comment_or_empty_line_node.comment:\\n            comment_text = comment_or_empty_line_node.comment.value\\n    elif isinstance(comment_or_empty_line_node, libcst.Comment):\\n        comment_text = comment_or_empty_line_node.value\\n\\n    if not comment_text:\\n        return None\\n\\n    comment_types: list[CommentType] = [\\n        comment_type\\n        for comment_type in CommentType\\n        if comment_type.value in comment_text.upper()\\n    ]\\n\\n    if comment_types:\\n        return CommentModel(\\n            content=comment_text,\\n            comment_types=comment_types,\\n        )\\n\\n\\ndef extract_decorators(\\n    decorators: Sequence[libcst.Decorator],\\n) -> list[DecoratorModel] | None:\\n    \"\"\"\\n    Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\\n\\n    Processes each decorator node to form a model representing the decorator\\'s name and its arguments, if any.\\n\\n    Args:\\n        decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\\n\\n    Returns:\\n        list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\\n\\n    Example:\\n        >>> extract_decorators(function_node.decorators)\\n        # Returns a list of DecoratorModel objects representing each decorator in the function.\\n    \"\"\"\\n\\n    decorators_list: list[DecoratorModel] = []\\n    for decorator in decorators:\\n        decorator_model: DecoratorModel | None = extract_decorator(decorator)\\n        if isinstance(decorator_model, DecoratorModel):\\n            decorators_list.append(extract_decorator(decorator))  # type: ignore\\n    return decorators_list if decorators_list else None\\n\\n\\ndef extract_decorator(\\n    decorator: libcst.Decorator,\\n) -> DecoratorModel | None:\\n    \"\"\"\\n    Extracts the decorator from a libcst.Decorator node.\\n\\n    Processes a single decorator node to create a model representing the decorator\\'s name and arguments.\\n\\n    Args:\\n        decorator (libcst.Decorator): A libcst.Decorator node.\\n\\n    Returns:\\n        DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\\n\\n    Example:\\n        >>> extract_decorator(some_decorator_node)\\n        # Returns a DecoratorModel object for the decorator.\\n    \"\"\"\\n\\n    decorator_name: str = \"\"\\n    arg_list: list[str] | None = None\\n    if isinstance(decorator.decorator, libcst.Name):\\n        decorator_name: str = decorator.decorator.value\\n    if isinstance(decorator.decorator, libcst.Call):\\n        func = decorator.decorator.func\\n        if isinstance(func, libcst.Name) or isinstance(func, libcst.Attribute):\\n            if decorator.decorator.args:\\n                arg_list = [\\n                    extract_stripped_code_content(arg)\\n                    for arg in decorator.decorator.args\\n                ]\\n        if isinstance(func, libcst.Name):\\n            decorator_name = func.value\\n        elif isinstance(func, libcst.Attribute):\\n            decorator_name = func.attr.value\\n        else:\\n            logging.warning(\"Decorator func is not a Name or Attribute node\")\\n\\n    return (\\n        DecoratorModel(\\n            content=extract_stripped_code_content(decorator),\\n            decorator_name=decorator_name,\\n            decorator_args=arg_list,\\n        )\\n        if decorator_name\\n        else None\\n    )\\n\\n\\ndef extract_type_annotation(node: libcst.CSTNode) -> str | None:\\n    \"\"\"\\n    Extracts the type annotation from a node.\\n\\n    Processes a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\\n\\n    Args:\\n        node (libcst.CSTNode): The node to extract the type annotation from.\\n\\n    Returns:\\n        str | None: The extracted type annotation as a string, or None if no type annotation is found.\\n    \"\"\"\\n\\n    annotation: libcst.Annotation | None = _get_node_annotation(node)\\n    if annotation and isinstance(annotation, libcst.Annotation):\\n        return _process_type_annotation_expression(annotation.annotation)\\n    return None\\n\\n\\ndef _get_node_annotation(node: libcst.CSTNode) -> libcst.Annotation | None:\\n    \"\"\"Retrieves the annotation of a given CSTNode.\"\"\"\\n\\n    if isinstance(node, libcst.Param) or isinstance(node, libcst.AnnAssign):\\n        return node.annotation\\n    elif isinstance(node, libcst.Annotation):\\n        return node\\n    return None\\n\\n\\ndef _process_type_annotation_expression(expression: libcst.BaseExpression) -> str:\\n    \"\"\"Process the type annotation expression and return a string representation recursively.\"\"\"\\n\\n    if isinstance(expression, libcst.Subscript):\\n        return _extract_generic_types_from_subscript(expression)\\n    elif isinstance(expression, libcst.BinaryOperation):\\n        left: str = _process_type_annotation_expression(expression.left)\\n        right: str = _process_type_annotation_expression(expression.right)\\n        return f\"{left} | {right}\"\\n    elif isinstance(expression, libcst.Name):\\n        return expression.value\\n    return \"\"\\n\\n\\ndef _extract_generic_types_from_subscript(\\n    node: libcst.Subscript | libcst.BaseExpression,\\n) -> str:\\n    \"\"\"Recursively extracts generic types from a Subscript node or a BaseExpression node.\"\"\"\\n\\n    if isinstance(node, libcst.Subscript):\\n        generics: list[str] = []\\n        for element in node.slice:\\n            if isinstance(element.slice, libcst.Index):\\n                if isinstance(element.slice.value, libcst.BinaryOperation):\\n                    union_type: str = _process_type_annotation_expression(\\n                        element.slice.value\\n                    )\\n                    generics.append(union_type)\\n                else:\\n                    generic_type: str = _extract_generic_types_from_subscript(\\n                        element.slice.value\\n                    )\\n                    generics.append(generic_type)\\n\\n        if isinstance(node.value, libcst.Name):\\n            generics_str = \", \".join(generics)\\n            return f\"{node.value.value}[{generics_str}]\"\\n        else:\\n            return \"\"\\n\\n    elif isinstance(node, libcst.Name):\\n        return node.value\\n    return \"\"\\n\\n```\\n\\nCHILDREN_SUMMARIES:\\n\\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_code_content(\\\\n    node: libcst.CSTNode,\\\\n) -> str:\\\\n    \"\"\"\\\\n    Extracts the code content from a given CST node.\\\\n\\\\n    This function converts a CST node to its string representation, maintaining the original code format.\\\\n\\\\n    Args:\\\\n        node (libcst.CSTNode): The CST node to extract code from.\\\\n\\\\n    Returns:\\\\n        str: The string representation of the code for the given CST node.\\\\n\\\\n    Example:\\\\n        >>> extract_code_content(some_cst_node)\\\\n        # Returns the code content as a string.\\\\n    \"\"\"\\\\n\\\\n    return libcst.Module([]).code_for_node(node)\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_stripped_code_content(\\\\n    node: libcst.CSTNode,\\\\n) -> str:\\\\n    \"\"\"\\\\n    Extracts the stripped code content from a given CST node.\\\\n\\\\n    Similar to extract_code_content, but also strips leading and trailing whitespace from the code string.\\\\n\\\\n    Args:\\\\n        node (libcst.CSTNode): The CST node to extract code from.\\\\n\\\\n    Returns:\\\\n        str: The stripped string representation of the code for the CST node.\\\\n\\\\n    Example:\\\\n        >>> extract_stripped_code_content(some_cst_node)\\\\n        # Returns the stripped code content as a string.\\\\n    \"\"\"\\\\n\\\\n    return extract_code_content(node).strip()\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_important_comment(\\\\n    comment_or_empty_line_node: libcst.CSTNode,\\\\n) -> CommentModel | None:\\\\n    \"\"\"\\\\n    Extracts an important comment from a given CST node.\\\\n\\\\n    Processes a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\\\\n\\\\n    Args:\\\\n        comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\\\\n\\\\n    Returns:\\\\n        CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\\\\n\\\\n    Example:\\\\n        >>> extract_important_comment(some_comment_node)\\\\n        # Returns a CommentModel for the comment, or None if not important.\\\\n    \"\"\"\\\\n\\\\n    comment_text: str | None = None\\\\n\\\\n    if isinstance(comment_or_empty_line_node, libcst.EmptyLine):\\\\n        if comment_or_empty_line_node.comment:\\\\n            comment_text = comment_or_empty_line_node.comment.value\\\\n    elif isinstance(comment_or_empty_line_node, libcst.Comment):\\\\n        comment_text = comment_or_empty_line_node.value\\\\n\\\\n    if not comment_text:\\\\n        return None\\\\n\\\\n    comment_types: list[CommentType] = [\\\\n        comment_type\\\\n        for comment_type in CommentType\\\\n        if comment_type.value in comment_text.upper()\\\\n    ]\\\\n\\\\n    if comment_types:\\\\n        return CommentModel(\\\\n            content=comment_text,\\\\n            comment_types=comment_types,\\\\n        )\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\\\nfrom python_parser.models.enums import CommentType\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_decorators(\\\\n    decorators: Sequence[libcst.Decorator],\\\\n) -> list[DecoratorModel] | None:\\\\n    \"\"\"\\\\n    Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\\\\n\\\\n    Processes each decorator node to form a model representing the decorator\\\\\\'s name and its arguments, if any.\\\\n\\\\n    Args:\\\\n        decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\\\\n\\\\n    Returns:\\\\n        list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\\\\n\\\\n    Example:\\\\n        >>> extract_decorators(function_node.decorators)\\\\n        # Returns a list of DecoratorModel objects representing each decorator in the function.\\\\n    \"\"\"\\\\n\\\\n    decorators_list: list[DecoratorModel] = []\\\\n    for decorator in decorators:\\\\n        decorator_model: DecoratorModel | None = extract_decorator(decorator)\\\\n        if isinstance(decorator_model, DecoratorModel):\\\\n            decorators_list.append(extract_decorator(decorator))  # type: ignore\\\\n    return decorators_list if decorators_list else None\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nfrom typing import Sequence\\\\nimport libcst\\\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_decorator(\\\\n    decorator: libcst.Decorator,\\\\n) -> DecoratorModel | None:\\\\n    \"\"\"\\\\n    Extracts the decorator from a libcst.Decorator node.\\\\n\\\\n    Processes a single decorator node to create a model representing the decorator\\\\\\'s name and arguments.\\\\n\\\\n    Args:\\\\n        decorator (libcst.Decorator): A libcst.Decorator node.\\\\n\\\\n    Returns:\\\\n        DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\\\\n\\\\n    Example:\\\\n        >>> extract_decorator(some_decorator_node)\\\\n        # Returns a DecoratorModel object for the decorator.\\\\n    \"\"\"\\\\n\\\\n    decorator_name: str = \"\"\\\\n    arg_list: list[str] | None = None\\\\n    if isinstance(decorator.decorator, libcst.Name):\\\\n        decorator_name: str = decorator.decorator.value\\\\n    if isinstance(decorator.decorator, libcst.Call):\\\\n        func = decorator.decorator.func\\\\n        if isinstance(func, libcst.Name) or isinstance(func, libcst.Attribute):\\\\n            if decorator.decorator.args:\\\\n                arg_list = [\\\\n                    extract_stripped_code_content(arg)\\\\n                    for arg in decorator.decorator.args\\\\n                ]\\\\n        if isinstance(func, libcst.Name):\\\\n            decorator_name = func.value\\\\n        elif isinstance(func, libcst.Attribute):\\\\n            decorator_name = func.attr.value\\\\n        else:\\\\n            logging.warning(\"Decorator func is not a Name or Attribute node\")\\\\n\\\\n    return (\\\\n        DecoratorModel(\\\\n            content=extract_stripped_code_content(decorator),\\\\n            decorator_name=decorator_name,\\\\n            decorator_args=arg_list,\\\\n        )\\\\n        if decorator_name\\\\n        else None\\\\n    )\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport logging\\\\nimport libcst\\\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef extract_type_annotation(node: libcst.CSTNode) -> str | None:\\\\n    \"\"\"\\\\n    Extracts the type annotation from a node.\\\\n\\\\n    Processes a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\\\\n\\\\n    Args:\\\\n        node (libcst.CSTNode): The node to extract the type annotation from.\\\\n\\\\n    Returns:\\\\n        str | None: The extracted type annotation as a string, or None if no type annotation is found.\\\\n    \"\"\"\\\\n\\\\n    annotation: libcst.Annotation | None = _get_node_annotation(node)\\\\n    if annotation and isinstance(annotation, libcst.Annotation):\\\\n        return _process_type_annotation_expression(annotation.annotation)\\\\n    return None\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef _get_node_annotation(node: libcst.CSTNode) -> libcst.Annotation | None:\\\\n    \"\"\"Retrieves the annotation of a given CSTNode.\"\"\"\\\\n\\\\n    if isinstance(node, libcst.Param) or isinstance(node, libcst.AnnAssign):\\\\n        return node.annotation\\\\n    elif isinstance(node, libcst.Annotation):\\\\n        return node\\\\n    return None\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef _process_type_annotation_expression(expression: libcst.BaseExpression) -> str:\\\\n    \"\"\"Process the type annotation expression and return a string representation recursively.\"\"\"\\\\n\\\\n    if isinstance(expression, libcst.Subscript):\\\\n        return _extract_generic_types_from_subscript(expression)\\\\n    elif isinstance(expression, libcst.BinaryOperation):\\\\n        left: str = _process_type_annotation_expression(expression.left)\\\\n        right: str = _process_type_annotation_expression(expression.right)\\\\n        return f\"{left} | {right}\"\\\\n    elif isinstance(expression, libcst.Name):\\\\n        return expression.value\\\\n    return \"\"\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\nSummary:\\n\\n        [{\\'content\\': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main\\\\nfeatures, and key components.\\\\n\", \\'role\\': \\'system\\'}, {\\'content\\': \\'Prompt: \"Summarize the code provided.\"\\\\n\\\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\\\n\\\\nChain of Density Steps:\\\\n\\\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\\\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\\\n\\\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\\\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\\\n\\\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\\\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\\\n\\\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\\\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\\\nlonger.\\\\n\\\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\\\nalgorithms, and structures used in the code, and include detailed information on the code\\\\\\'s purpose. It should provide a clear and concise overview of \\\\nthe code\\\\\\'s content and purpose.\\\\n\\\\nGuidelines:\\\\n- Ensure that each iteration of the summary accurately reflects the code\\\\\\'s functionality and purpose.\\\\n- The summary should be technical yet understandable, providing a clear picture of the code\\\\\\'s purpose, main features, and key components.\\\\n- Avoid technical jargon unless it is directly relevant to the code\\\\\\'s main functionality.\\\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\\\n\\\\nCODE:\\\\n```Python\\\\n\\\\n\\\\ndef _extract_generic_types_from_subscript(\\\\n    node: libcst.Subscript | libcst.BaseExpression,\\\\n) -> str:\\\\n    \"\"\"Recursively extracts generic types from a Subscript node or a BaseExpression node.\"\"\"\\\\n\\\\n    if isinstance(node, libcst.Subscript):\\\\n        generics: list[str] = []\\\\n        for element in node.slice:\\\\n            if isinstance(element.slice, libcst.Index):\\\\n                if isinstance(element.slice.value, libcst.BinaryOperation):\\\\n                    union_type: str = _process_type_annotation_expression(\\\\n                        element.slice.value\\\\n                    )\\\\n                    generics.append(union_type)\\\\n                else:\\\\n                    generic_type: str = _extract_generic_types_from_subscript(\\\\n                        element.slice.value\\\\n                    )\\\\n                    generics.append(generic_type)\\\\n\\\\n        if isinstance(node.value, libcst.Name):\\\\n            generics_str = \", \".join(generics)\\\\n            return f\"{node.value.value}[{generics_str}]\"\\\\n        else:\\\\n            return \"\"\\\\n\\\\n    elif isinstance(node, libcst.Name):\\\\n        return node.value\\\\n    return \"\"\\\\n\\\\n```\\\\n\\\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\\\n\\\\nimport libcst\\\\n\\\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\\\n\\', \\'role\\': \\'user\\'}]\\n \\n        \\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nfrom typing import Sequence\\nimport libcst\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\nfrom python_parser.models.enums import CommentType\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
    "children": [
        {
            "function_name": "extract_code_content",
            "docstring": "Extracts the code content from a given CST node.\n\nThis function converts a CST node to its string representation, maintaining the original code format.\n\nArgs:\n    node (libcst.CSTNode): The CST node to extract code from.\n\nReturns:\n    str: The string representation of the code for the given CST node.\n\nExample:\n    >>> extract_code_content(some_cst_node)\n    # Returns the code content as a string.",
            "decorators": null,
            "parameters": null,
            "returns": "str",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_code_content",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 8,
            "end_line_num": 30,
            "code_content": "\n\ndef extract_code_content(\n    node: libcst.CSTNode,\n) -> str:\n    \"\"\"\n    Extracts the code content from a given CST node.\n\n    This function converts a CST node to its string representation, maintaining the original code format.\n\n    Args:\n        node (libcst.CSTNode): The CST node to extract code from.\n\n    Returns:\n        str: The string representation of the code for the given CST node.\n\n    Example:\n        >>> extract_code_content(some_cst_node)\n        # Returns the code content as a string.\n    \"\"\"\n\n    return libcst.Module([]).code_for_node(node)\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_code_content(\\n    node: libcst.CSTNode,\\n) -> str:\\n    \"\"\"\\n    Extracts the code content from a given CST node.\\n\\n    This function converts a CST node to its string representation, maintaining the original code format.\\n\\n    Args:\\n        node (libcst.CSTNode): The CST node to extract code from.\\n\\n    Returns:\\n        str: The string representation of the code for the given CST node.\\n\\n    Example:\\n        >>> extract_code_content(some_cst_node)\\n        # Returns the code content as a string.\\n    \"\"\"\\n\\n    return libcst.Module([]).code_for_node(node)\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "extract_stripped_code_content",
            "docstring": "Extracts the stripped code content from a given CST node.\n\nSimilar to extract_code_content, but also strips leading and trailing whitespace from the code string.\n\nArgs:\n    node (libcst.CSTNode): The CST node to extract code from.\n\nReturns:\n    str: The stripped string representation of the code for the CST node.\n\nExample:\n    >>> extract_stripped_code_content(some_cst_node)\n    # Returns the stripped code content as a string.",
            "decorators": null,
            "parameters": null,
            "returns": "str",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_stripped_code_content",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 30,
            "end_line_num": 52,
            "code_content": "\n\ndef extract_stripped_code_content(\n    node: libcst.CSTNode,\n) -> str:\n    \"\"\"\n    Extracts the stripped code content from a given CST node.\n\n    Similar to extract_code_content, but also strips leading and trailing whitespace from the code string.\n\n    Args:\n        node (libcst.CSTNode): The CST node to extract code from.\n\n    Returns:\n        str: The stripped string representation of the code for the CST node.\n\n    Example:\n        >>> extract_stripped_code_content(some_cst_node)\n        # Returns the stripped code content as a string.\n    \"\"\"\n\n    return extract_code_content(node).strip()\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_code_content"
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_stripped_code_content(\\n    node: libcst.CSTNode,\\n) -> str:\\n    \"\"\"\\n    Extracts the stripped code content from a given CST node.\\n\\n    Similar to extract_code_content, but also strips leading and trailing whitespace from the code string.\\n\\n    Args:\\n        node (libcst.CSTNode): The CST node to extract code from.\\n\\n    Returns:\\n        str: The stripped string representation of the code for the CST node.\\n\\n    Example:\\n        >>> extract_stripped_code_content(some_cst_node)\\n        # Returns the stripped code content as a string.\\n    \"\"\"\\n\\n    return extract_code_content(node).strip()\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "extract_important_comment",
            "docstring": "Extracts an important comment from a given CST node.\n\nProcesses a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\n\nArgs:\n    comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\n\nReturns:\n    CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\n\nExample:\n    >>> extract_important_comment(some_comment_node)\n    # Returns a CommentModel for the comment, or None if not important.",
            "decorators": null,
            "parameters": null,
            "returns": "CommentModel | None",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_important_comment",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 52,
            "end_line_num": 95,
            "code_content": "\n\ndef extract_important_comment(\n    comment_or_empty_line_node: libcst.CSTNode,\n) -> CommentModel | None:\n    \"\"\"\n    Extracts an important comment from a given CST node.\n\n    Processes a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\n\n    Args:\n        comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\n\n    Returns:\n        CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\n\n    Example:\n        >>> extract_important_comment(some_comment_node)\n        # Returns a CommentModel for the comment, or None if not important.\n    \"\"\"\n\n    comment_text: str | None = None\n\n    if isinstance(comment_or_empty_line_node, libcst.EmptyLine):\n        if comment_or_empty_line_node.comment:\n            comment_text = comment_or_empty_line_node.comment.value\n    elif isinstance(comment_or_empty_line_node, libcst.Comment):\n        comment_text = comment_or_empty_line_node.value\n\n    if not comment_text:\n        return None\n\n    comment_types: list[CommentType] = [\n        comment_type\n        for comment_type in CommentType\n        if comment_type.value in comment_text.upper()\n    ]\n\n    if comment_types:\n        return CommentModel(\n            content=comment_text,\n            comment_types=comment_types,\n        )\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "CommentModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-CommentModel"
                        },
                        {
                            "name": "DecoratorModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                        }
                    ],
                    "imported_from": "python_parser.models.models",
                    "import_module_type": "LOCAL",
                    "local_module_id": "python_parser:models:models.py__*__MODULE"
                },
                {
                    "import_names": [
                        {
                            "name": "CommentType",
                            "as_name": null,
                            "local_block_id": "python_parser:models:enums.py__*__MODULE__*__CLASS-CommentType"
                        }
                    ],
                    "imported_from": "python_parser.models.enums",
                    "import_module_type": "LOCAL",
                    "local_module_id": "python_parser:models:enums.py__*__MODULE"
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_important_comment(\\n    comment_or_empty_line_node: libcst.CSTNode,\\n) -> CommentModel | None:\\n    \"\"\"\\n    Extracts an important comment from a given CST node.\\n\\n    Processes a libcst.Comment or libcst.EmptyLine node to extract important comments, categorizing them based on predefined types.\\n\\n    Args:\\n        comment_or_empty_line_node (libcst.CSTNode): A CST node representing a comment or an empty line with a comment.\\n\\n    Returns:\\n        CommentModel | None: A CommentModel object if an important comment is found, otherwise None.\\n\\n    Example:\\n        >>> extract_important_comment(some_comment_node)\\n        # Returns a CommentModel for the comment, or None if not important.\\n    \"\"\"\\n\\n    comment_text: str | None = None\\n\\n    if isinstance(comment_or_empty_line_node, libcst.EmptyLine):\\n        if comment_or_empty_line_node.comment:\\n            comment_text = comment_or_empty_line_node.comment.value\\n    elif isinstance(comment_or_empty_line_node, libcst.Comment):\\n        comment_text = comment_or_empty_line_node.value\\n\\n    if not comment_text:\\n        return None\\n\\n    comment_types: list[CommentType] = [\\n        comment_type\\n        for comment_type in CommentType\\n        if comment_type.value in comment_text.upper()\\n    ]\\n\\n    if comment_types:\\n        return CommentModel(\\n            content=comment_text,\\n            comment_types=comment_types,\\n        )\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\nfrom python_parser.models.enums import CommentType\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "extract_decorators",
            "docstring": "Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\n\nProcesses each decorator node to form a model representing the decorator's name and its arguments, if any.\n\nArgs:\n    decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\n\nReturns:\n    list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\n\nExample:\n    >>> extract_decorators(function_node.decorators)\n    # Returns a list of DecoratorModel objects representing each decorator in the function.",
            "decorators": null,
            "parameters": null,
            "returns": "list[DecoratorModel] | None",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_decorators",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 95,
            "end_line_num": 122,
            "code_content": "\n\ndef extract_decorators(\n    decorators: Sequence[libcst.Decorator],\n) -> list[DecoratorModel] | None:\n    \"\"\"\n    Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\n\n    Processes each decorator node to form a model representing the decorator's name and its arguments, if any.\n\n    Args:\n        decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\n\n    Returns:\n        list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\n\n    Example:\n        >>> extract_decorators(function_node.decorators)\n        # Returns a list of DecoratorModel objects representing each decorator in the function.\n    \"\"\"\n\n    decorators_list: list[DecoratorModel] = []\n    for decorator in decorators:\n        decorator_model: DecoratorModel | None = extract_decorator(decorator)\n        if isinstance(decorator_model, DecoratorModel):\n            decorators_list.append(extract_decorator(decorator))  # type: ignore\n    return decorators_list if decorators_list else None\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_decorator"
                },
                {
                    "import_names": [
                        {
                            "name": "Sequence",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": "typing",
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "CommentModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-CommentModel"
                        },
                        {
                            "name": "DecoratorModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                        }
                    ],
                    "imported_from": "python_parser.models.models",
                    "import_module_type": "LOCAL",
                    "local_module_id": "python_parser:models:models.py__*__MODULE"
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_decorators(\\n    decorators: Sequence[libcst.Decorator],\\n) -> list[DecoratorModel] | None:\\n    \"\"\"\\n    Extracts a list of decorator models from a sequence of libcst.Decorator nodes.\\n\\n    Processes each decorator node to form a model representing the decorator\\'s name and its arguments, if any.\\n\\n    Args:\\n        decorators (Sequence[libcst.Decorator]): A sequence of libcst.Decorator nodes.\\n\\n    Returns:\\n        list[DecoratorModel] | None: A list of DecoratorModel objects, or None if no decorators are found.\\n\\n    Example:\\n        >>> extract_decorators(function_node.decorators)\\n        # Returns a list of DecoratorModel objects representing each decorator in the function.\\n    \"\"\"\\n\\n    decorators_list: list[DecoratorModel] = []\\n    for decorator in decorators:\\n        decorator_model: DecoratorModel | None = extract_decorator(decorator)\\n        if isinstance(decorator_model, DecoratorModel):\\n            decorators_list.append(extract_decorator(decorator))  # type: ignore\\n    return decorators_list if decorators_list else None\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nfrom typing import Sequence\\nimport libcst\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "extract_decorator",
            "docstring": "Extracts the decorator from a libcst.Decorator node.\n\nProcesses a single decorator node to create a model representing the decorator's name and arguments.\n\nArgs:\n    decorator (libcst.Decorator): A libcst.Decorator node.\n\nReturns:\n    DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\n\nExample:\n    >>> extract_decorator(some_decorator_node)\n    # Returns a DecoratorModel object for the decorator.",
            "decorators": null,
            "parameters": null,
            "returns": "DecoratorModel | None",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_decorator",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 122,
            "end_line_num": 171,
            "code_content": "\n\ndef extract_decorator(\n    decorator: libcst.Decorator,\n) -> DecoratorModel | None:\n    \"\"\"\n    Extracts the decorator from a libcst.Decorator node.\n\n    Processes a single decorator node to create a model representing the decorator's name and arguments.\n\n    Args:\n        decorator (libcst.Decorator): A libcst.Decorator node.\n\n    Returns:\n        DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\n\n    Example:\n        >>> extract_decorator(some_decorator_node)\n        # Returns a DecoratorModel object for the decorator.\n    \"\"\"\n\n    decorator_name: str = \"\"\n    arg_list: list[str] | None = None\n    if isinstance(decorator.decorator, libcst.Name):\n        decorator_name: str = decorator.decorator.value\n    if isinstance(decorator.decorator, libcst.Call):\n        func = decorator.decorator.func\n        if isinstance(func, libcst.Name) or isinstance(func, libcst.Attribute):\n            if decorator.decorator.args:\n                arg_list = [\n                    extract_stripped_code_content(arg)\n                    for arg in decorator.decorator.args\n                ]\n        if isinstance(func, libcst.Name):\n            decorator_name = func.value\n        elif isinstance(func, libcst.Attribute):\n            decorator_name = func.attr.value\n        else:\n            logging.warning(\"Decorator func is not a Name or Attribute node\")\n\n    return (\n        DecoratorModel(\n            content=extract_stripped_code_content(decorator),\n            decorator_name=decorator_name,\n            decorator_args=arg_list,\n        )\n        if decorator_name\n        else None\n    )\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_stripped_code_content"
                },
                {
                    "import_names": [
                        {
                            "name": "logging",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "STANDARD_LIBRARY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                },
                {
                    "import_names": [
                        {
                            "name": "CommentModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-CommentModel"
                        },
                        {
                            "name": "DecoratorModel",
                            "as_name": null,
                            "local_block_id": "python_parser:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                        }
                    ],
                    "imported_from": "python_parser.models.models",
                    "import_module_type": "LOCAL",
                    "local_module_id": "python_parser:models:models.py__*__MODULE"
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_decorator(\\n    decorator: libcst.Decorator,\\n) -> DecoratorModel | None:\\n    \"\"\"\\n    Extracts the decorator from a libcst.Decorator node.\\n\\n    Processes a single decorator node to create a model representing the decorator\\'s name and arguments.\\n\\n    Args:\\n        decorator (libcst.Decorator): A libcst.Decorator node.\\n\\n    Returns:\\n        DecoratorModel | None: A DecoratorModel object if the decorator is valid, otherwise None.\\n\\n    Example:\\n        >>> extract_decorator(some_decorator_node)\\n        # Returns a DecoratorModel object for the decorator.\\n    \"\"\"\\n\\n    decorator_name: str = \"\"\\n    arg_list: list[str] | None = None\\n    if isinstance(decorator.decorator, libcst.Name):\\n        decorator_name: str = decorator.decorator.value\\n    if isinstance(decorator.decorator, libcst.Call):\\n        func = decorator.decorator.func\\n        if isinstance(func, libcst.Name) or isinstance(func, libcst.Attribute):\\n            if decorator.decorator.args:\\n                arg_list = [\\n                    extract_stripped_code_content(arg)\\n                    for arg in decorator.decorator.args\\n                ]\\n        if isinstance(func, libcst.Name):\\n            decorator_name = func.value\\n        elif isinstance(func, libcst.Attribute):\\n            decorator_name = func.attr.value\\n        else:\\n            logging.warning(\"Decorator func is not a Name or Attribute node\")\\n\\n    return (\\n        DecoratorModel(\\n            content=extract_stripped_code_content(decorator),\\n            decorator_name=decorator_name,\\n            decorator_args=arg_list,\\n        )\\n        if decorator_name\\n        else None\\n    )\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport logging\\nimport libcst\\nfrom python_parser.models.models import CommentModel, DecoratorModel\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "extract_type_annotation",
            "docstring": "Extracts the type annotation from a node.\n\nProcesses a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\n\nArgs:\n    node (libcst.CSTNode): The node to extract the type annotation from.\n\nReturns:\n    str | None: The extracted type annotation as a string, or None if no type annotation is found.",
            "decorators": null,
            "parameters": null,
            "returns": "str | None",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-extract_type_annotation",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 171,
            "end_line_num": 190,
            "code_content": "\n\ndef extract_type_annotation(node: libcst.CSTNode) -> str | None:\n    \"\"\"\n    Extracts the type annotation from a node.\n\n    Processes a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\n\n    Args:\n        node (libcst.CSTNode): The node to extract the type annotation from.\n\n    Returns:\n        str | None: The extracted type annotation as a string, or None if no type annotation is found.\n    \"\"\"\n\n    annotation: libcst.Annotation | None = _get_node_annotation(node)\n    if annotation and isinstance(annotation, libcst.Annotation):\n        return _process_type_annotation_expression(annotation.annotation)\n    return None\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_get_node_annotation"
                },
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_process_type_annotation_expression"
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef extract_type_annotation(node: libcst.CSTNode) -> str | None:\\n    \"\"\"\\n    Extracts the type annotation from a node.\\n\\n    Processes a libcst.CSTNode to extract the type annotation, if present. It handles various forms of type annotations, including generics and unions.\\n\\n    Args:\\n        node (libcst.CSTNode): The node to extract the type annotation from.\\n\\n    Returns:\\n        str | None: The extracted type annotation as a string, or None if no type annotation is found.\\n    \"\"\"\\n\\n    annotation: libcst.Annotation | None = _get_node_annotation(node)\\n    if annotation and isinstance(annotation, libcst.Annotation):\\n        return _process_type_annotation_expression(annotation.annotation)\\n    return None\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "_get_node_annotation",
            "docstring": "Retrieves the annotation of a given CSTNode.",
            "decorators": null,
            "parameters": null,
            "returns": " | None",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_get_node_annotation",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 190,
            "end_line_num": 200,
            "code_content": "\n\ndef _get_node_annotation(node: libcst.CSTNode) -> libcst.Annotation | None:\n    \"\"\"Retrieves the annotation of a given CSTNode.\"\"\"\n\n    if isinstance(node, libcst.Param) or isinstance(node, libcst.AnnAssign):\n        return node.annotation\n    elif isinstance(node, libcst.Annotation):\n        return node\n    return None\n",
            "important_comments": null,
            "dependencies": [
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef _get_node_annotation(node: libcst.CSTNode) -> libcst.Annotation | None:\\n    \"\"\"Retrieves the annotation of a given CSTNode.\"\"\"\\n\\n    if isinstance(node, libcst.Param) or isinstance(node, libcst.AnnAssign):\\n        return node.annotation\\n    elif isinstance(node, libcst.Annotation):\\n        return node\\n    return None\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "_process_type_annotation_expression",
            "docstring": "Process the type annotation expression and return a string representation recursively.",
            "decorators": null,
            "parameters": null,
            "returns": "str",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_process_type_annotation_expression",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 200,
            "end_line_num": 214,
            "code_content": "\n\ndef _process_type_annotation_expression(expression: libcst.BaseExpression) -> str:\n    \"\"\"Process the type annotation expression and return a string representation recursively.\"\"\"\n\n    if isinstance(expression, libcst.Subscript):\n        return _extract_generic_types_from_subscript(expression)\n    elif isinstance(expression, libcst.BinaryOperation):\n        left: str = _process_type_annotation_expression(expression.left)\n        right: str = _process_type_annotation_expression(expression.right)\n        return f\"{left} | {right}\"\n    elif isinstance(expression, libcst.Name):\n        return expression.value\n    return \"\"\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_extract_generic_types_from_subscript"
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef _process_type_annotation_expression(expression: libcst.BaseExpression) -> str:\\n    \"\"\"Process the type annotation expression and return a string representation recursively.\"\"\"\\n\\n    if isinstance(expression, libcst.Subscript):\\n        return _extract_generic_types_from_subscript(expression)\\n    elif isinstance(expression, libcst.BinaryOperation):\\n        left: str = _process_type_annotation_expression(expression.left)\\n        right: str = _process_type_annotation_expression(expression.right)\\n        return f\"{left} | {right}\"\\n    elif isinstance(expression, libcst.Name):\\n        return expression.value\\n    return \"\"\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        },
        {
            "function_name": "_extract_generic_types_from_subscript",
            "docstring": "Recursively extracts generic types from a Subscript node or a BaseExpression node.",
            "decorators": null,
            "parameters": null,
            "returns": "str",
            "is_method": false,
            "is_async": false,
            "id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_extract_generic_types_from_subscript",
            "parent_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE",
            "block_type": "FUNCTION",
            "start_line_num": 214,
            "end_line_num": 245,
            "code_content": "\n\ndef _extract_generic_types_from_subscript(\n    node: libcst.Subscript | libcst.BaseExpression,\n) -> str:\n    \"\"\"Recursively extracts generic types from a Subscript node or a BaseExpression node.\"\"\"\n\n    if isinstance(node, libcst.Subscript):\n        generics: list[str] = []\n        for element in node.slice:\n            if isinstance(element.slice, libcst.Index):\n                if isinstance(element.slice.value, libcst.BinaryOperation):\n                    union_type: str = _process_type_annotation_expression(\n                        element.slice.value\n                    )\n                    generics.append(union_type)\n                else:\n                    generic_type: str = _extract_generic_types_from_subscript(\n                        element.slice.value\n                    )\n                    generics.append(generic_type)\n\n        if isinstance(node.value, libcst.Name):\n            generics_str = \", \".join(generics)\n            return f\"{node.value.value}[{generics_str}]\"\n        else:\n            return \"\"\n\n    elif isinstance(node, libcst.Name):\n        return node.value\n    return \"\"\n",
            "important_comments": null,
            "dependencies": [
                {
                    "code_block_id": "python_parser:visitors:node_processing:common_functions.py__*__MODULE__*__FUNCTION-_process_type_annotation_expression"
                },
                {
                    "import_names": [
                        {
                            "name": "libcst",
                            "as_name": null,
                            "local_block_id": null
                        }
                    ],
                    "imported_from": null,
                    "import_module_type": "THIRD_PARTY",
                    "local_module_id": null
                }
            ],
            "summary": "Summary:\n\n        [{'content': \"You are a code summarizer. Your task is to analyze the code provided and create a concise summary of the\\ngiven code based on the prompt provided. Your summary should be technical yet understandable, providing a clear picture of the code's purpose, main\\nfeatures, and key components.\\n\", 'role': 'system'}, {'content': 'Prompt: \"Summarize the code provided.\"\\n\\nIf the code is for a function, or class, specifically reference the function or class name, and any names defined inside of it, in your summary.\\n\\nChain of Density Steps:\\n\\n1. INITIAL SUMMARY: Start by generating a high-level summary of the code. This summary should briefly describe the main functionality \\nand purpose of the code. For example, \"This code implements a basic sorting algorithm to return a list of integers sorted in ascending order.\"\\n\\n2. IDENTIFY MISSING KEY COMPONENTS: After creating the initial summary, identify 1-3 key components that are missing from the summary. These \\ncomponents could be specific functions, algorithms, data structures, classes, local and third-party library imports and variables, etc.\\n\\n3. INCORPORATE MISSING COMPONENTS: Rewrite the summary to include the identified components, making it more detailed and informative and explains the\\nfunctionality and purpose of the code even better. Ensure that the length of the summary does not increase. For example, \"This code implements a \\nquicksort algorithm using a pivot selection function and partitioning logic to return a list of integers in ascending order.\"\\n\\n4. REPEAT THE PROCESS: Continue this process, identifying missing components and integrating them into the summary in each iteration. After \\neach iteration, the summary should become more detailed, covering more aspects of the code and getting better detail on its purpose without becoming \\nlonger.\\n\\n5. FINAL SUMMARY: After 5 iterations, the final summary should be dense with technical details and accurately reflect the key functionalities, \\nalgorithms, and structures used in the code, and include detailed information on the code\\'s purpose. It should provide a clear and concise overview of \\nthe code\\'s content and purpose.\\n\\nGuidelines:\\n- Ensure that each iteration of the summary accurately reflects the code\\'s functionality and purpose.\\n- The summary should be technical yet understandable, providing a clear picture of the code\\'s purpose, main features, and key components.\\n- Avoid technical jargon unless it is directly relevant to the code\\'s main functionality.\\n- The final summary should be comprehensive yet concise, capturing the essence of the code, and written below the phrase \"FINAL SUMMARY:\".\\n\\nCODE:\\n```Python\\n\\n\\ndef _extract_generic_types_from_subscript(\\n    node: libcst.Subscript | libcst.BaseExpression,\\n) -> str:\\n    \"\"\"Recursively extracts generic types from a Subscript node or a BaseExpression node.\"\"\"\\n\\n    if isinstance(node, libcst.Subscript):\\n        generics: list[str] = []\\n        for element in node.slice:\\n            if isinstance(element.slice, libcst.Index):\\n                if isinstance(element.slice.value, libcst.BinaryOperation):\\n                    union_type: str = _process_type_annotation_expression(\\n                        element.slice.value\\n                    )\\n                    generics.append(union_type)\\n                else:\\n                    generic_type: str = _extract_generic_types_from_subscript(\\n                        element.slice.value\\n                    )\\n                    generics.append(generic_type)\\n\\n        if isinstance(node.value, libcst.Name):\\n            generics_str = \", \".join(generics)\\n            return f\"{node.value.value}[{generics_str}]\"\\n        else:\\n            return \"\"\\n\\n    elif isinstance(node, libcst.Name):\\n        return node.value\\n    return \"\"\\n\\n```\\n\\nSTANDARD_LIBRARY_AND_THIRD_PARTY_LIBRARY_IMPORTS:\\n\\nimport libcst\\n\\nMake sure to write your final summary below the phrase \"FINAL SUMMARY:\". Take a deep breath and do some great work!\\n', 'role': 'user'}]\n \n        ",
            "children": null
        }
    ]
}