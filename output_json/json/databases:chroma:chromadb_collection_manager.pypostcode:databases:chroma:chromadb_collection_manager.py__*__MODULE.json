{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "logging",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "Any",
                    "as_name": null,
                    "local_block_id": null
                },
                {
                    "name": "Mapping",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "postcode.types.chroma",
                    "as_name": "chroma_types",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:types:chroma.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModelType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "postcode.types.postcode",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:types:postcode.py__*__MODULE"
        }
    ],
    "id": "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE",
    "file_path": "postcode/databases/chroma/chromadb_collection_manager.py",
    "parent_id": "postcode:databases:chroma__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 468,
    "code_content": "import logging\nfrom typing import Any, Mapping\n\nimport postcode.types.chroma as chroma_types\nfrom postcode.types.postcode import ModelType\n\n\nclass ChromaCollectionManager:\n    \"\"\"\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\n    and querying embeddings, and their associated metadata.\n\n    This class serves as an interface to interact with a specific collection in ChromaDB.\n\n    Attributes:\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\n            which this manager is responsible for.\n\n    Methods:\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\n        - `add_embeddings`: Adds embeddings to the collection.\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\n        - `upsert_models`: Loads or updates the embeddings of the provided module models into the collection.\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder\n        import postcode.types.chromadb.types as chroma_types\n\n        # Create a persistent ChromaDB client\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Instantiate the ChromaDBCollectionManager with a specific collection\n        collection_manager: ChromaDBCollectionManager = (\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\n        )\n\n        # Example usage of the collection manager\n        embedding_count: int = collection_manager.collection_embedding_count()\n        print(f\"Total embeddings: {embedding_count}\")\n        ```\n    \"\"\"\n\n    def __init__(self, collection: chroma_types.Collection) -> None:\n        self.collection: chroma_types.Collection = collection\n\n    def collection_embedding_count(self) -> int | None:\n        \"\"\"\n        Gets the total number of embeddings in the collection.\n\n        Returns:\n            - embedding_count (int): The total number of embeddings in the collection.\n\n        Examples:\n            ```Python\n            embedding_count: int = collection_manager.get_collection_embedding_count()\n            ```\n        \"\"\"\n        try:\n            embedding_count: int = self.collection.count()\n            logging.info(\n                f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\n            )\n            return embedding_count\n        except Exception as exception:\n            logging.error(exception)\n\n    def add_embeddings(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n    ) -> None:\n        \"\"\"\n        Adds embeddings to the collection.\n\n        Args:\n            - ids (list[str]): A list of ids to add to the collection.\n            - documents (list[str]): A list of documents to add to the collection.\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\n        Raises:\n            - ValueError - If you don't provide either embeddings or documents.\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError - If you provide an id that already exists.\n\n        Examples:\n            ```Python\n            # define the ids, metadatas, and documents to add to the collection\n            id: list[str] = [\"my_id\", \"my_id2\"]\n            metadatas: list[dict[str, Any]] = [\n                {\"my_metadata\": \"my_metadata_value\"},\n                {\"my_metadata2\": \"my_metadata_value2\"},\n            ]\n            documents: list[str] = [\"my_document\", \"my_document2\"]\n\n            # add the embeddings to the collection\n            collection_manager.add_embeddings(id, metadatas, documents)\n            ```\n        \"\"\"\n\n        if not len(ids) == len(documents) == len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        try:\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\n        except Exception as exception:\n            raise exception\n\n    def get_embeddings(\n        self,\n        ids: list[str] | None,\n        *,\n        where_filter: chroma_types.Where | None = None,\n        limit: int | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.GetResult | None:\n        \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n            return self.collection.get(\n                ids,\n                where=where_filter,\n                limit=limit,\n                where_document=where_document_filter,\n                include=include_in_result,\n            )\n        except Exception as exception:\n            raise exception\n\n    def query_collection(\n        self,\n        queries: list[str],\n        n_results: int = 10,\n        where_filter: chroma_types.Where | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.QueryResult | None:\n        \"\"\"\n        Queries and returns the `n` nearest neighbors from the collection.\n\n        Args:\n            - queries (list[str]): A list of queries to search the collection for.\n            - n_results (int): The number of results to return.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                - e.g. `{$contains: \"binary search\"}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n                `include_in_result` parameter:\n                - ids: list[str] # The ids are always returned.\n                - embeddings: List[list[Embedding]] | None\n                - documents: list[list[str]]] | None\n                - uris: list[list[URI]]] | None\n                - data: list[Loadable] | None\n                - metadatas: list[list[Metadata]] | None\n                - distances: list[list[float]] | None\n\n        Raises:\n            - ValueError: If you don't provide query_texts.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma\n\n            # define the queries and filters used to search the collection\n            queries: list[str] = [\"binary search\", \"linear search\"]\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n            # query the collection and return the results from the collection\n            results: chroma_types.QueryResult = collection_manager.query_collection(\n                queries,\n                where_filter=where_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Querying collection {self.collection.name}\")\n\n            if results := self.collection.query(\n                query_texts=queries,\n                n_results=n_results,\n                where=where_filter,\n                where_document=where_document_filter,\n                include=include_in_result,\n            ):\n                return results\n            else:\n                logging.warning(\n                    f\"No results found from collection {self.collection.name}.\"\n                )\n\n        except Exception as exception:\n            raise exception\n\n    def modify_collection_name(self, name: str) -> None:\n        \"\"\"\n        Modifies the name of the collection managed by this class.\n\n        Args:\n            - name (str): The new name to assign to the collection.\n\n        Examples:\n            ```Python\n            # Rename the collection to 'new_collection_name'\n            collection_manager.modify_collection_name('new_collection_name')\n            ```\n        \"\"\"\n\n        self.collection.modify(name=name)\n\n    def modify_collection_metadata(\n        self, metadata: dict[str, Any] | None = None\n    ) -> None:\n        \"\"\"\n        Modifies the metadata of the collection managed by this class.\n\n        Args:\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\n        Examples:\n            ```Python\n            # Update metadata of the collection\n            new_metadata = {\"description\": \"Updated collection metadata\"}\n            collection_manager.modify_collection_metadata(new_metadata)\n            ```\n        \"\"\"\n\n        self.collection.modify(metadata=metadata)\n\n    def _update_metadata_or_documents_by_ids(\n        self,\n        ids: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\n        documents: list[str] | None = None,\n    ) -> None:\n        \"\"\"\n        Updates the metadata or documents of specific entries in the collection by their ids.\n\n        Args:\n            - ids (list[str]): List of ids of the entries to be updated.\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n            - documents (list[str] | None): List of document updates corresponding to the ids.\n\n        Raises:\n            - ValueError: If neither metadatas nor documents are provided.\n            - ValueError: If the length of ids and documents don't match.\n            - ValueError: If the length of ids and metadatas don't match.\n            - ValueError: If the length of ids, metadatas, and documents don't match.\n\n        Notes:\n            - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            # Update metadata and documents for specific ids\n            ids_to_update = ['id1', 'id2']\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n            document_updates = [\"new document 1\", \"new document 2\"]\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n            ```\n        \"\"\"\n\n        if not metadatas and not documents:\n            raise ValueError(\"You must provide either metadatas or documents.\")\n        if not metadatas and documents:\n            if len(ids) != len(documents):\n                raise ValueError(\"The length of ids and documents must match.\")\n        if metadatas and not documents:\n            if len(ids) != len(metadatas):\n                raise ValueError(\"The length of ids and metadatas must match.\")\n        if metadatas and documents:\n            if len(ids) != len(metadatas) != len(documents):\n                raise ValueError(\n                    \"The length of ids, metadatas, and documents must match.\"\n                )\n        for index, id in enumerate(ids):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids.pop(index)\n                if metadatas:\n                    popped_metadata = metadatas.pop(index)\n                    if popped_metadata:\n                        logging.warning(\n                            f\"Removing metadata at index {index} from update.\"\n                        )\n                if documents:\n                    popped_document = documents.pop(index)\n                    if popped_document:\n                        logging.warning(\n                            f\"Removing document at index {index} from update.\"\n                        )\n\n        if not ids:\n            logging.warning(\"All updates failed.\")\n            return None\n        else:\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\n\n    def _upsert_documents(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n        # embeddings: list[chroma_types.Embedding],\n    ) -> None:\n        \"\"\"\n        Inserts or updates documents in the collection, based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\n            - documents (list[str]): List of documents corresponding to the ids.\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\n        Raises:\n            - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\n        Examples:\n            ```Python\n            # Upsert documents in the collection\n            ids = ['id1', 'id2']\n            documents = ['doc1', 'doc2']\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n            # Upsert documents in the collection\n            collection_manager.upsert_documents(ids, documents, metadatas)\n            ```\n        \"\"\"\n\n        if len(ids) != len(documents) != len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\n        self.collection.upsert(\n            ids=ids,\n            # embeddings=embeddings,\n            metadatas=metadatas,\n            documents=documents,\n        )\n\n    def delete_embeddings(self, ids: list[str]) -> None:\n        \"\"\"\n        Deletes embeddings from the collection based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\n        Examples:\n            ```Python\n            # Delete specific embeddings by ids\n            ids_to_delete = ['id1', 'id2']\n            collection_manager.delete_embeddings(ids_to_delete)\n            ```\n        \"\"\"\n\n        ids_to_delete: list[str] = ids.copy()\n        for index, id in enumerate(ids_to_delete):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids_to_delete.pop(index)\n\n        if not ids_to_delete:\n            logging.warning(\"No IDs given were in the database.\")\n            return None\n\n        logging.info(\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\n        )\n        self.collection.delete(ids_to_delete)\n\n    def upsert_models(self, models: tuple[ModelType, ...]) -> None:\n        \"\"\"\n        Loads or updates the embeddings of the provided models into the collection.\n\n        The Pydantic models are converted to a dictionary with a format that ChromaDB can use, then the ids, documents, and metadatas\n        are added to their respective lists. The lists are then either added to or updated in the collection depending on whether or\n        not the code blocks were in the the collection to begin with.\n\n        Args:\n            - models (tuple[ModelType, ...]): The models to load or update into the collection.\n\n        Examples:\n            ```Python\n            # Upsert models into the collection\n            models = (model1, model2)\n            collection_manager.upsert_models(models)\n            ```\n        \"\"\"\n\n        ids: list[str] = []\n        documents: list[str] = []\n        metadatas: list[Mapping[str, str | int | float | bool]] = []\n\n        for model in models:\n            if model.summary:\n                ids.append(model.id)\n                documents.append(model.summary)\n                metadatas.append(model.convert_to_metadata())\n\n        logging.info(\n            f\"{self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n        )\n        self._upsert_documents(ids=ids, documents=documents, metadatas=metadatas)\n        logging.info(\n            f\"After upsert {self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n        )\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "\nSummary:\n\n        postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE\n\n        \nChild (postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager) code content:\n\n\nclass ChromaCollectionManager:\n    \"\"\"\n    Manages a collection within ChromaDB instance, providing functionalities for adding, retrieving,\n    and querying embeddings, and their associated metadata.\n\n    This class serves as an interface to interact with a specific collection in ChromaDB.\n\n    Attributes:\n        - collection (chroma_types.Collection): An instance of the Collection class from ChromaDB\n            which this manager is responsible for.\n\n    Methods:\n        - `collection_embedding_count`: Gets the total number of embeddings in the collection.\n        - `add_embeddings`: Adds embeddings to the collection.\n        - `get_embeddings`: Gets embeddings and their metadata from the collection in the form of a TypedDict.\n        - `query_collection`: Queries and returns the `n` nearest neighbors from the collection.\n        - `upsert_models`: Loads or updates the embeddings of the provided module models into the collection.\n\n    Examples:\n        ```Python\n        from postcode.databases.chroma import ChromaDBClientBuilder\n        import postcode.types.chromadb.types as chroma_types\n\n        # Create a persistent ChromaDB client\n        client: chroma_types.ClientAPI = ChromaDBClientBuilder.create_persistent_client()\n\n        # Instantiate the ChromaDBCollectionManager with a specific collection\n        collection_manager: ChromaDBCollectionManager = (\n            ChromaDBCollectionManager(client.get_collection(\"my_collection\"))\n        )\n\n        # Example usage of the collection manager\n        embedding_count: int = collection_manager.collection_embedding_count()\n        print(f\"Total embeddings: {embedding_count}\")\n        ```\n    \"\"\"\n\n    def __init__(self, collection: chroma_types.Collection) -> None:\n        self.collection: chroma_types.Collection = collection\n\n    def collection_embedding_count(self) -> int | None:\n        \"\"\"\n        Gets the total number of embeddings in the collection.\n\n        Returns:\n            - embedding_count (int): The total number of embeddings in the collection.\n\n        Examples:\n            ```Python\n            embedding_count: int = collection_manager.get_collection_embedding_count()\n            ```\n        \"\"\"\n        try:\n            embedding_count: int = self.collection.count()\n            logging.info(\n                f\"Collection {self.collection.name} has {embedding_count} embeddings.\"\n            )\n            return embedding_count\n        except Exception as exception:\n            logging.error(exception)\n\n    def add_embeddings(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n    ) -> None:\n        \"\"\"\n        Adds embeddings to the collection.\n\n        Args:\n            - ids (list[str]): A list of ids to add to the collection.\n            - documents (list[str]): A list of documents to add to the collection.\n            - metadatas (list[dict[str, Any]]): A list of metadatas to add to the collection.\n\n        Raises:\n            - ValueError - If you don't provide either embeddings or documents.\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError - If you provide an id that already exists.\n\n        Examples:\n            ```Python\n            # define the ids, metadatas, and documents to add to the collection\n            id: list[str] = [\"my_id\", \"my_id2\"]\n            metadatas: list[dict[str, Any]] = [\n                {\"my_metadata\": \"my_metadata_value\"},\n                {\"my_metadata2\": \"my_metadata_value2\"},\n            ]\n            documents: list[str] = [\"my_document\", \"my_document2\"]\n\n            # add the embeddings to the collection\n            collection_manager.add_embeddings(id, metadatas, documents)\n            ```\n        \"\"\"\n\n        if not len(ids) == len(documents) == len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        try:\n            logging.info(f\"Adding embeddings to collection {self.collection.name}\")\n            self.collection.add(ids, documents=documents, metadatas=metadatas)\n        except Exception as exception:\n            raise exception\n\n    def get_embeddings(\n        self,\n        ids: list[str] | None,\n        *,\n        where_filter: chroma_types.Where | None = None,\n        limit: int | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.GetResult | None:\n        \"\"\"\n        Gets embeddings and their metadata from the collection in the form of a TypedDict.\n\n        Args:\n            - ids (list[str]): A list of ids to get from the collection.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n            - limit (int | None): The maximum number of results to return.\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                e.g. `{$contains: {\"text\": \"hello\"}}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - embeddings (TypedDict): A typed dict of embedding data from the collection with the following keys:\n                - ids: list[str]\n                - embeddings: list[Embedding] | None\n                - documents: list[str] | None\n                - uris: chroma_types.URIs | None\n                - data: chroma_types.Loadable | None\n                - metadatas: list[chroma_types.Metadata]]\n\n        Raises:\n            - ValueError: If the length of ids, embeddings, metadatas, or documents don't match.\n            - ValueError: If you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma_types\n\n            # define the ids, filters to use to get embeddings from the collection\n            ids: list[str] = [\"my_id\", \"my_id2\"]\n            where_filter: chroma_types.Where = {\"my_metadata\": \"my_metadata_value\"}\n            where_document_filter: chroma_types.WhereDocument = {\"$contains\": {\"text\": \"hello\"}}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\"]\n\n            # get the embeddings from the collection\n            embeddings: chroma_types.GetResult = collection_manager.get_embeddings(\n                ids,\n                where_filter=where_filter,\n                where_document_filter=where_document_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Getting embeddings from collection {self.collection.name}\")\n            return self.collection.get(\n                ids,\n                where=where_filter,\n                limit=limit,\n                where_document=where_document_filter,\n                include=include_in_result,\n            )\n        except Exception as exception:\n            raise exception\n\n    def query_collection(\n        self,\n        queries: list[str],\n        n_results: int = 10,\n        where_filter: chroma_types.Where | None = None,\n        where_document_filter: chroma_types.WhereDocument | None = None,\n        include_in_result: chroma_types.Include = [\"metadatas\", \"documents\"],\n    ) -> chroma_types.QueryResult | None:\n        \"\"\"\n        Queries and returns the `n` nearest neighbors from the collection.\n\n        Args:\n            - queries (list[str]): A list of queries to search the collection for.\n            - n_results (int): The number of results to return.\n            - where_filter (chroma_types.Where | None): A TypedDict used to filter the results.\n                - e.g. `{\"block_type\": \"FUNCTION\", \"children\": None}`\n            - where_document_filter (chroma_types.WhereDocument | None): A TypedDict used to filter the results by the document,\n                - e.g. `{$contains: \"binary search\"}`\n            - include_in_result (chroma_types.Include | None): A list used of what to return from the results, e.g. `[\"metadatas\", \"embeddings\", \"documents\"]`\n\n        Returns:\n            - results (chroma_types.QueryResult | None): A typed dict of query results from the collection, can have the following keys based on the\n                `include_in_result` parameter:\n                - ids: list[str] # The ids are always returned.\n                - embeddings: List[list[Embedding]] | None\n                - documents: list[list[str]]] | None\n                - uris: list[list[URI]]] | None\n                - data: list[Loadable] | None\n                - metadatas: list[list[Metadata]] | None\n                - distances: list[list[float]] | None\n\n        Raises:\n            - ValueError: If you don't provide query_texts.\n\n        Examples:\n            ```Python\n            import postcode.types.chromadb.types as chroma\n\n            # define the queries and filters used to search the collection\n            queries: list[str] = [\"binary search\", \"linear search\"]\n            where_filter: chroma_types.Where = {\"block_type\": \"FUNCTION\"}\n\n            # define the data to return from the collection\n            include_in_result: chroma_types.Include = [\"metadatas\", \"documents\", \"distances\"]\n\n            # query the collection and return the results from the collection\n            results: chroma_types.QueryResult = collection_manager.query_collection(\n                queries,\n                where_filter=where_filter,\n                include_in_result=include_in_result\n                )\n            ```\n        \"\"\"\n\n        try:\n            logging.info(f\"Querying collection {self.collection.name}\")\n\n            if results := self.collection.query(\n                query_texts=queries,\n                n_results=n_results,\n                where=where_filter,\n                where_document=where_document_filter,\n                include=include_in_result,\n            ):\n                return results\n            else:\n                logging.warning(\n                    f\"No results found from collection {self.collection.name}.\"\n                )\n\n        except Exception as exception:\n            raise exception\n\n    def modify_collection_name(self, name: str) -> None:\n        \"\"\"\n        Modifies the name of the collection managed by this class.\n\n        Args:\n            - name (str): The new name to assign to the collection.\n\n        Examples:\n            ```Python\n            # Rename the collection to 'new_collection_name'\n            collection_manager.modify_collection_name('new_collection_name')\n            ```\n        \"\"\"\n\n        self.collection.modify(name=name)\n\n    def modify_collection_metadata(\n        self, metadata: dict[str, Any] | None = None\n    ) -> None:\n        \"\"\"\n        Modifies the metadata of the collection managed by this class.\n\n        Args:\n            - metadata (dict[str, Any] | None): The new metadata to assign to the collection. If None, no change is made.\n\n        Examples:\n            ```Python\n            # Update metadata of the collection\n            new_metadata = {\"description\": \"Updated collection metadata\"}\n            collection_manager.modify_collection_metadata(new_metadata)\n            ```\n        \"\"\"\n\n        self.collection.modify(metadata=metadata)\n\n    def _update_metadata_or_documents_by_ids(\n        self,\n        ids: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]] | None = None,\n        documents: list[str] | None = None,\n    ) -> None:\n        \"\"\"\n        Updates the metadata or documents of specific entries in the collection by their ids.\n\n        Args:\n            - ids (list[str]): List of ids of the entries to be updated.\n            - metadatas (list[Mapping[str, Any]] | None): List of metadata updates corresponding to the ids.\n            - documents (list[str] | None): List of document updates corresponding to the ids.\n\n        Raises:\n            - ValueError: If neither metadatas nor documents are provided.\n            - ValueError: If the length of ids and documents don't match.\n            - ValueError: If the length of ids and metadatas don't match.\n            - ValueError: If the length of ids, metadatas, and documents don't match.\n\n        Notes:\n            - As of now, ChromaDB doesn't raise an exception if you provide an id that doesn't exist.\n\n        Examples:\n            ```Python\n            # Update metadata and documents for specific ids\n            ids_to_update = ['id1', 'id2']\n            metadata_updates = [{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\n            document_updates = [\"new document 1\", \"new document 2\"]\n            collection_manager.update_metadata_or_documents_by_ids(ids_to_update, metadata_updates, document_updates)\n            ```\n        \"\"\"\n\n        if not metadatas and not documents:\n            raise ValueError(\"You must provide either metadatas or documents.\")\n        if not metadatas and documents:\n            if len(ids) != len(documents):\n                raise ValueError(\"The length of ids and documents must match.\")\n        if metadatas and not documents:\n            if len(ids) != len(metadatas):\n                raise ValueError(\"The length of ids and metadatas must match.\")\n        if metadatas and documents:\n            if len(ids) != len(metadatas) != len(documents):\n                raise ValueError(\n                    \"The length of ids, metadatas, and documents must match.\"\n                )\n        for index, id in enumerate(ids):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids.pop(index)\n                if metadatas:\n                    popped_metadata = metadatas.pop(index)\n                    if popped_metadata:\n                        logging.warning(\n                            f\"Removing metadata at index {index} from update.\"\n                        )\n                if documents:\n                    popped_document = documents.pop(index)\n                    if popped_document:\n                        logging.warning(\n                            f\"Removing document at index {index} from update.\"\n                        )\n\n        if not ids:\n            logging.warning(\"All updates failed.\")\n            return None\n        else:\n            logging.info(f\"Updating collection {self.collection.name} with ids {ids}.\")\n            self.collection.update(ids=ids, metadatas=metadatas, documents=documents)\n\n    def _upsert_documents(\n        self,\n        ids: list[str],\n        documents: list[str],\n        metadatas: list[Mapping[str, str | int | float | bool]],\n        # embeddings: list[chroma_types.Embedding],\n    ) -> None:\n        \"\"\"\n        Inserts or updates documents in the collection, based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids for the documents to be inserted or updated.\n            - documents (list[str]): List of documents corresponding to the ids.\n            - metadatas (list[Mapping[str, Any]]): List of metadata corresponding to the ids.\n\n        Raises:\n            - ValueError: If the lengths of ids, documents, and metadatas don't match.\n\n        Examples:\n            ```Python\n            # Upsert documents in the collection\n            ids = ['id1', 'id2']\n            documents = ['doc1', 'doc2']\n            metadatas = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\n            # Upsert documents in the collection\n            collection_manager.upsert_documents(ids, documents, metadatas)\n            ```\n        \"\"\"\n\n        if len(ids) != len(documents) != len(metadatas):\n            raise ValueError(\"The length of ids, documents, and metadatas must match.\")\n\n        logging.info(f\"Upserting collection {self.collection.name} with ids {ids}.\")\n        self.collection.upsert(\n            ids=ids,\n            # embeddings=embeddings,\n            metadatas=metadatas,\n            documents=documents,\n        )\n\n    def delete_embeddings(self, ids: list[str]) -> None:\n        \"\"\"\n        Deletes embeddings from the collection based on the provided ids.\n\n        Args:\n            - ids (list[str]): List of ids corresponding to the embeddings to be deleted.\n\n        Examples:\n            ```Python\n            # Delete specific embeddings by ids\n            ids_to_delete = ['id1', 'id2']\n            collection_manager.delete_embeddings(ids_to_delete)\n            ```\n        \"\"\"\n\n        ids_to_delete: list[str] = ids.copy()\n        for index, id in enumerate(ids_to_delete):\n            if not self.collection.get(id):\n                logging.error(\n                    f\"Id {id} does not exist in collection {self.collection.name}.\"\n                )\n                ids_to_delete.pop(index)\n\n        if not ids_to_delete:\n            logging.warning(\"No IDs given were in the database.\")\n            return None\n\n        logging.info(\n            f\"Deleting embeddings from collection {self.collection.name} with ids {ids_to_delete}.\"\n        )\n        self.collection.delete(ids_to_delete)\n\n    def upsert_models(self, models: tuple[ModelType, ...]) -> None:\n        \"\"\"\n        Loads or updates the embeddings of the provided models into the collection.\n\n        The Pydantic models are converted to a dictionary with a format that ChromaDB can use, then the ids, documents, and metadatas\n        are added to their respective lists. The lists are then either added to or updated in the collection depending on whether or\n        not the code blocks were in the the collection to begin with.\n\n        Args:\n            - models (tuple[ModelType, ...]): The models to load or update into the collection.\n\n        Examples:\n            ```Python\n            # Upsert models into the collection\n            models = (model1, model2)\n            collection_manager.upsert_models(models)\n            ```\n        \"\"\"\n\n        ids: list[str] = []\n        documents: list[str] = []\n        metadatas: list[Mapping[str, str | int | float | bool]] = []\n\n        for model in models:\n            if model.summary:\n                ids.append(model.id)\n                documents.append(model.summary)\n                metadatas.append(model.convert_to_metadata())\n\n        logging.info(\n            f\"{self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n        )\n        self._upsert_documents(ids=ids, documents=documents, metadatas=metadatas)\n        logging.info(\n            f\"After upsert {self.collection.name} has {self.collection_embedding_count()} embeddings.\"\n        )\n\n, None, None\n        ",
    "children_ids": [
        "postcode:databases:chroma:chromadb_collection_manager.py__*__MODULE__*__CLASS-ChromaCollectionManager"
    ]
}