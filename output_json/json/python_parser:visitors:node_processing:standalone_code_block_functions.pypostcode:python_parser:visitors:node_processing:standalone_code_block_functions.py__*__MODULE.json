{
    "docstring": null,
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "THIRD_PARTY",
            "local_module_id": null
        },
        {
            "import_names": [
                {
                    "name": "logging_decorator",
                    "as_name": null,
                    "local_block_id": "postcode:utilities:logger:decorators.py__*__MODULE__*__FUNCTION-logging_decorator"
                }
            ],
            "imported_from": "postcode.utilities.logger.decorators",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:utilities:logger:decorators.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "StandaloneCodeBlockIDGenerationStrategy",
                    "as_name": null,
                    "local_block_id": "postcode:python_parser:id_generation:id_generation_strategies.py__*__MODULE__*__CLASS-StandaloneCodeBlockIDGenerationStrategy"
                }
            ],
            "imported_from": "postcode.python_parser.id_generation.id_generation_strategies",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:python_parser:id_generation:id_generation_strategies.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BuilderFactory",
                    "as_name": null,
                    "local_block_id": "postcode:python_parser:model_builders:builder_factory.py__*__MODULE__*__CLASS-BuilderFactory"
                }
            ],
            "imported_from": "postcode.python_parser.model_builders.builder_factory",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:python_parser:model_builders:builder_factory.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "StandaloneBlockModelBuilder",
                    "as_name": null,
                    "local_block_id": "postcode:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE__*__CLASS-StandaloneBlockModelBuilder"
                }
            ],
            "imported_from": "postcode.python_parser.model_builders.standalone_block_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "CommentModel",
                    "as_name": null,
                    "local_block_id": "postcode:models:models.py__*__MODULE__*__CLASS-CommentModel"
                },
                {
                    "name": "BlockType",
                    "as_name": null,
                    "local_block_id": null
                }
            ],
            "imported_from": "postcode.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "postcode.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": null
                }
            ],
            "imported_from": null,
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "NodeAndPositionData",
                    "as_name": null,
                    "local_block_id": "postcode:utilities:processing_context.py__*__MODULE__*__CLASS-NodeAndPositionData"
                }
            ],
            "imported_from": "postcode.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": "postcode:utilities:processing_context.py__*__MODULE"
        }
    ],
    "id": "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE",
    "file_path": "postcode/python_parser/visitors/node_processing/standalone_code_block_functions.py",
    "parent_id": "postcode:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 194,
    "code_content": "from typing import Sequence\nimport libcst\n\nfrom postcode.utilities.logger.decorators import logging_decorator\n\nfrom postcode.python_parser.id_generation.id_generation_strategies import (\n    StandaloneCodeBlockIDGenerationStrategy,\n)\n\nfrom postcode.python_parser.model_builders.builder_factory import BuilderFactory\nfrom postcode.python_parser.model_builders.standalone_block_model_builder import (\n    StandaloneBlockModelBuilder,\n)\nfrom postcode.models.models import CommentModel, BlockType\n\nimport postcode.python_parser.visitors.node_processing.common_functions as common_functions\nfrom postcode.utilities.processing_context import NodeAndPositionData\n\n\ndef gather_standalone_lines(\n    node_body: Sequence[libcst.CSTNode], visitor_instance\n) -> list[NodeAndPositionData]:\n    \"\"\"\n    Gathers standalone lines of code that are not part of class or function definitions or import statements.\n\n    This function iterates over a sequence of CSTNodes, identifying blocks of code that stand alone. Standalone blocks are those not encapsulated in class or function definitions and not part of import statements.\n\n    Args:\n        node_body: A sequence of libcst.CSTNode representing the body of a module or a block.\n        visitor_instance: An instance of a visitor class that provides additional context and utilities.\n\n    Returns:\n        A list of NodeAndPositionData, each representing a standalone block of code with its start and end line numbers.\n\n    Example:\n        >>> visitor_instance = ModuleVisitor(id=\"module1\", ...)\n        >>> standalone_blocks = gather_standalone_lines(module_ast.body, visitor_instance)\n        # This will process the module AST and return standalone blocks of code.\n    \"\"\"\n\n    standalone_blocks: list[NodeAndPositionData] = []\n    standalone_block: list[libcst.CSTNode] = []\n    start_line = end_line = 0\n\n    for statement in node_body:\n        if _is_class_or_function_def(statement) or _is_import_statement(statement):\n            if standalone_block:\n                end_line = visitor_instance.get_node_position_data(\n                    standalone_block[-1]\n                ).end\n                standalone_blocks.append(\n                    NodeAndPositionData(standalone_block, start_line, end_line)\n                )\n                standalone_block = []\n                start_line = end_line = 0\n        else:\n            if not standalone_block:\n                start_line = visitor_instance.get_node_position_data(statement).start\n            standalone_block.append(statement)\n\n    if standalone_block:\n        end_line = visitor_instance.get_node_position_data(standalone_block[-1]).end\n        standalone_blocks.append(\n            NodeAndPositionData(standalone_block, start_line, end_line)\n        )\n\n    return standalone_blocks\n\n\ndef process_standalone_blocks(\n    code_blocks: list[NodeAndPositionData], parent_id: str, file_path: str\n) -> list[StandaloneBlockModelBuilder]:\n    \"\"\"\n    Processes standalone blocks of code and builds models for each block.\n\n    Iterates over a list of standalone code blocks, processing each to build a model representing the block. Each block is assigned an identifier and associated with a parent identifier.\n\n    Args:\n        - code_blocks: A list of NodeAndPositionData representing standalone code blocks.\n        - parent_id: The identifier of the parent (usually a module or class).\n        - file_path: The file path of the module containing the standalone blocks.\n\n    Returns:\n        - list[StandaloneBlockModelBuilder], each representing a processed standalone block.\n\n    Example:\n        ```Python\n        standalone_blocks_models = process_standalone_blocks(standalone_blocks, \"module1\")\n        # Processes standalone blocks and creates models for them.\n        ```\n    \"\"\"\n\n    models: list[StandaloneBlockModelBuilder] = []\n    for count, code_block in enumerate(code_blocks):\n        models.append(\n            _process_standalone_block(\n                code_block, parent_id, count + 1, file_path=file_path\n            )\n        )\n\n    return models\n\n\ndef _is_class_or_function_def(statement: libcst.CSTNode) -> bool:\n    \"\"\"Returns True if the statement is a class or function definition.\"\"\"\n\n    return isinstance(statement, (libcst.ClassDef, libcst.FunctionDef))\n\n\ndef _is_import_statement(statement: libcst.CSTNode) -> bool:\n    \"\"\"Returns True if the statement is an import statement.\"\"\"\n\n    return isinstance(statement, libcst.SimpleStatementLine) and any(\n        isinstance(elem, (libcst.Import, libcst.ImportFrom)) for elem in statement.body\n    )\n\n\n# TODO: Fix important comment logic\ndef _process_standalone_block(\n    standalone_block: NodeAndPositionData, parent_id: str, count: int, file_path: str\n) -> StandaloneBlockModelBuilder:\n    \"\"\"Processes a standalone block of code and sets the attributes in the model builder, returns the builder instance.\"\"\"\n\n    id: str = StandaloneCodeBlockIDGenerationStrategy.generate_id(parent_id, count)\n    builder: StandaloneBlockModelBuilder = BuilderFactory.create_builder_instance(\n        block_type=BlockType.STANDALONE_CODE_BLOCK,\n        id=id,\n        parent_id=parent_id,\n        file_path=file_path,\n    )\n    content, variable_assignments, important_comments = _process_nodes(standalone_block)\n    (\n        builder.set_start_line_num(standalone_block.start)\n        .set_end_line_num(standalone_block.end)\n        .set_code_content(content)\n    )\n    for important_comment in important_comments:\n        builder.add_important_comment(important_comment)\n    builder.set_variable_assignments(variable_assignments)\n\n    return builder\n\n\n@logging_decorator(syntax_highlighting=True)\ndef _process_nodes(\n    standalone_block: NodeAndPositionData,\n) -> tuple[str, list[str], list[CommentModel]]:\n    \"\"\"Processes the nodes in a standalone block of code and returns the content, variable assignments and important comments.\"\"\"\n\n    content: str = \"\"\n    variable_assignments: list[str] = []\n    important_comments: list[CommentModel] = []\n\n    for line in standalone_block.nodes:\n        if isinstance(line, libcst.SimpleStatementLine):\n            variable_assignments.extend(_extract_variable_assignments(line))\n\n        important_comments.extend(_process_leading_lines(line))\n        line_content: str = common_functions.extract_stripped_code_content(line)\n        content += line_content + \"\\n\"\n\n    return content, variable_assignments, important_comments\n\n\ndef _process_leading_lines(line: libcst.CSTNode) -> list[CommentModel]:\n    \"\"\"Processes the leading lines of a node and returns the important comments.\"\"\"\n\n    important_comments: list[CommentModel] = []\n\n    if isinstance(line, libcst.SimpleStatementLine):\n        for leading_line in line.leading_lines:\n            important_comment: CommentModel | None = (\n                common_functions.extract_important_comment(leading_line)\n            )\n            if important_comment:\n                important_comments.append(important_comment)\n\n    return important_comments\n\n\ndef _extract_variable_assignments(\n    node: libcst.SimpleStatementLine,\n) -> list[str]:\n    \"\"\"Extracts variable assignments from a SimpleStatementLine node.\"\"\"\n\n    variable_assignments: list[str] = []\n    for stmt in node.body:\n        if isinstance(stmt, (libcst.AnnAssign, libcst.Assign)):\n            variable_assignments.append(\n                common_functions.extract_stripped_code_content(stmt)\n            )\n\n    return variable_assignments\n",
    "important_comments": null,
    "dependencies": null,
    "summary": "\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE\n\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-gather_standalone_lines\n\n        None, \nImported code block (postcode:utilities:processing_context.py__*__MODULE) code content:\n\n\n@dataclass\nclass NodeAndPositionData:\n    \"\"\"A node in the syntax tree and its positional data.\"\"\"\n\n    nodes: list[libcst.CSTNode]\n    start: int\n    end: int\n\n, \nfrom typing import Sequence\nimport libcst\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-process_standalone_blocks\n\n        None, \nImported code block (postcode:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE) code content:\n\n\nclass StandaloneBlockModelBuilder(BaseModelBuilder):\n    \"\"\"\n    A builder class for constructing a model of a standalone code block.\n\n    This class extends BaseModelBuilder and specializes in building models of standalone code blocks, which are blocks of code not part of any class or function definitions. It captures details such as variable assignments within the block.\n\n    Attributes:\n        - standalone_block_attributes (StandaloneCodeBlockSpecificAttributes): An instance containing attributes specific to a standalone code block, such as variable assignments.\n\n    Args:\n        - id (str): The unique identifier for the standalone code block model.\n        - parent_id (str): The identifier of the parent model (e.g., module or class containing this standalone block).\n\n    Example:\n        ```Python\n        standalone_block_builder = StandaloneBlockModelBuilder(id='block1', parent_id='module1')\n        standalone_block_builder.set_variable_assignments(['x = 1', 'y = 2'])\n        # Configures the builder with variable assignments for the standalone code block.\n        ```\n    \"\"\"\n\n    def __init__(self, id: str, parent_id: str, file_path: str) -> None:\n        super().__init__(\n            id=id,\n            block_type=BlockType.STANDALONE_CODE_BLOCK,\n            parent_id=parent_id,\n            file_path=file_path,\n        )\n\n        self.standalone_block_attributes = StandaloneCodeBlockSpecificAttributes(\n            variable_assignments=None,\n        )\n\n    def set_variable_assignments(\n        self, variable_declarations: list[str]\n    ) -> \"StandaloneBlockModelBuilder\":\n        \"\"\"Sets the list of variable declarations to the standalone code block model.\"\"\"\n        self.standalone_block_attributes.variable_assignments = variable_declarations\n        return self\n\n    def _get_standalone_block_specific_attributes(self) -> dict[str, Any]:\n        \"\"\"Gets the standalone block specific attributes.\"\"\"\n        return self.standalone_block_attributes.model_dump()\n\n    @logging_decorator(message=\"Building standalone code block model\")\n    def build(self) -> StandaloneCodeBlockModel:\n        \"\"\"Creates a StandaloneCodeBlockModel instance after building and setting the children models.\"\"\"\n        return StandaloneCodeBlockModel(\n            **self._get_common_attributes(),\n            **self._get_standalone_block_specific_attributes(),\n        )\n\n\nImported code block (postcode:utilities:processing_context.py__*__MODULE) code content:\n\n\n@dataclass\nclass NodeAndPositionData:\n    \"\"\"A node in the syntax tree and its positional data.\"\"\"\n\n    nodes: list[libcst.CSTNode]\n    start: int\n    end: int\n\n, \n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_class_or_function_def\n\n        None, None, \nimport libcst\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_import_statement\n\n        None, None, \nimport libcst\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_standalone_block\n\n        None, \nImported code block (postcode:python_parser:id_generation:id_generation_strategies.py__*__MODULE) code content:\n\n\nclass StandaloneCodeBlockIDGenerationStrategy(IDGenerationStrategy):\n    \"\"\"ID generation strategy for standalone code blocks.\"\"\"\n\n    @staticmethod\n    def generate_id(parent_id: str, count: int) -> str:\n        \"\"\"\n        Generates an ID for a standalone code block based on the given parent ID and a count.\n\n        Args:\n            - parent_id (str): The ID of the parent (typically a module).\n            - count (int): A unique count or index for the standalone block within its parent.\n\n        Returns:\n            - str: The generated ID, incorporating the parent ID and the count.\n        \"\"\"\n        return f\"{parent_id}__*__STANDALONE_BLOCK-{count}\"\n\n\nImported code block (postcode:python_parser:model_builders:builder_factory.py__*__MODULE) code content:\n\n\nclass BuilderFactory:\n    \"\"\"\n    A factory class for creating instances of different types of model builders.\n\n    This class uses a strategy pattern to map each block type to a corresponding builder creation function. Depending on the block type specified, it creates and returns an instance of the appropriate model builder class.\n\n    The factory supports creating builders for modules, classes, functions, and standalone code blocks.\n\n    Attributes:\n        _creation_strategies (dict[BlockType, Callable[..., Any]]): A dictionary mapping block types to their corresponding builder creation functions.\n    \"\"\"\n\n    _creation_strategies: dict[BlockType, Callable[..., Any]] = {\n        BlockType.MODULE: lambda id, file_path, name, parent_id: ModuleModelBuilder(\n            id=id,\n            file_path=file_path,\n            parent_id=parent_id,\n        ),\n        BlockType.CLASS: lambda id, name, parent_id, file_path: ClassModelBuilder(\n            id=id,\n            class_name=name,\n            parent_id=parent_id,\n            file_path=file_path,\n        ),\n        BlockType.FUNCTION: lambda id, name, parent_id, file_path: FunctionModelBuilder(\n            id=id,\n            function_name=name,\n            parent_id=parent_id,\n            file_path=file_path,\n        ),\n        BlockType.STANDALONE_CODE_BLOCK: lambda id, parent_id, name, file_path: StandaloneBlockModelBuilder(\n            id=id,\n            parent_id=parent_id,\n            file_path=file_path,\n        ),\n    }\n\n    @staticmethod\n    @overload\n    def create_builder_instance(\n        block_type: Literal[BlockType.MODULE],\n        *,\n        id: str,\n        file_path: str,\n        parent_id: str,\n    ) -> ModuleModelBuilder:\n        \"\"\"\n        Creates a ModuleModelBuilder instance for building module models.\n\n        Args:\n            block_type: Specifies that a ModuleModelBuilder is to be created.\n            id (str): The unique identifier for the module model.\n            file_path (str): The file path of the module.\n\n        Returns:\n            ModuleModelBuilder: An instance of ModuleModelBuilder.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @overload\n    def create_builder_instance(\n        block_type: Literal[BlockType.CLASS],\n        *,\n        id: str,\n        name: str,\n        parent_id: str,\n        file_path: str,\n    ) -> ClassModelBuilder:\n        \"\"\"\n        Creates a ClassModelBuilder instance for building class models.\n\n        Args:\n            block_type: Specifies that a ClassModelBuilder is to be created.\n            id (str): The unique identifier for the class model.\n            name (str): The name of the class.\n            parent_id (str): The identifier of the parent model.\n\n        Returns:\n            ClassModelBuilder: An instance of ClassModelBuilder.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @overload\n    def create_builder_instance(\n        block_type: Literal[BlockType.FUNCTION],\n        *,\n        id: str,\n        name: str,\n        parent_id: str,\n        file_path: str,\n    ) -> FunctionModelBuilder:\n        \"\"\"\n        Creates a FunctionModelBuilder instance for building function models.\n\n        Args:\n            block_type: Specifies that a FunctionModelBuilder is to be created.\n            id (str): The unique identifier for the function model.\n            name (str): The name of the function.\n            parent_id (str): The identifier of the parent model.\n\n        Returns:\n            FunctionModelBuilder: An instance of FunctionModelBuilder.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @overload\n    def create_builder_instance(\n        block_type: Literal[BlockType.STANDALONE_CODE_BLOCK],\n        *,\n        id: str,\n        parent_id: str,\n        file_path: str,\n    ) -> StandaloneBlockModelBuilder:\n        \"\"\"\n        Creates a StandaloneBlockModelBuilder instance for building standalone code block models.\n\n        Args:\n            block_type: Specifies that a StandaloneBlockModelBuilder is to be created.\n            id (str): The unique identifier for the standalone code block model.\n            parent_id (str): The identifier of the parent model.\n\n        Returns:\n            StandaloneBlockModelBuilder: An instance of StandaloneBlockModelBuilder.\n        \"\"\"\n        ...\n\n    @logging_decorator()\n    @staticmethod\n    def create_builder_instance(\n        block_type: BlockType,\n        *,\n        id: str,\n        name: str | None = None,\n        parent_id: str | None = None,\n        file_path: str | None = None,\n    ) -> (\n        ModuleModelBuilder\n        | ClassModelBuilder\n        | FunctionModelBuilder\n        | StandaloneBlockModelBuilder\n    ):\n        \"\"\"\n        Creates and returns an instance of a model builder based on the specified block type.\n\n        Depending on the block type (module, class, function, standalone code block), it creates an instance of the corresponding model builder class.\n\n        Args:\n            block_type (BlockType): The type of code block for which the builder is to be created.\n            id (str): The unique identifier for the builder.\n            name (str | None): The name of the code block (relevant for class or function blocks).\n            parent_id (str | None): The identifier of the parent model (if applicable).\n            file_path (str | None): The file path of the module (relevant for module blocks).\n\n        Returns:\n            Union[ModuleModelBuilder, ClassModelBuilder, FunctionModelBuilder, StandaloneBlockModelBuilder]:\n            An instance of the appropriate model builder class.\n\n        Raises:\n            ValueError: If an unknown block type is provided.\n\n        Example:\n            >>> builder = BuilderFactory.create_builder_instance(\n                    block_type=BlockType.CLASS,\n                    id='class1',\n                    name='MyClass',\n                    parent_id='module1'\n                )\n            # This will create an instance of ClassModelBuilder for a class named 'MyClass'.\n        \"\"\"\n\n        if block_type not in BuilderFactory._creation_strategies:\n            raise ValueError(f\"Unknown node type: {block_type}\")\n        return BuilderFactory._creation_strategies[block_type](\n            id=id, name=name, parent_id=parent_id, file_path=file_path\n        )\n\n\nImported code block (postcode:python_parser:model_builders:standalone_block_model_builder.py__*__MODULE) code content:\n\n\nclass StandaloneBlockModelBuilder(BaseModelBuilder):\n    \"\"\"\n    A builder class for constructing a model of a standalone code block.\n\n    This class extends BaseModelBuilder and specializes in building models of standalone code blocks, which are blocks of code not part of any class or function definitions. It captures details such as variable assignments within the block.\n\n    Attributes:\n        - standalone_block_attributes (StandaloneCodeBlockSpecificAttributes): An instance containing attributes specific to a standalone code block, such as variable assignments.\n\n    Args:\n        - id (str): The unique identifier for the standalone code block model.\n        - parent_id (str): The identifier of the parent model (e.g., module or class containing this standalone block).\n\n    Example:\n        ```Python\n        standalone_block_builder = StandaloneBlockModelBuilder(id='block1', parent_id='module1')\n        standalone_block_builder.set_variable_assignments(['x = 1', 'y = 2'])\n        # Configures the builder with variable assignments for the standalone code block.\n        ```\n    \"\"\"\n\n    def __init__(self, id: str, parent_id: str, file_path: str) -> None:\n        super().__init__(\n            id=id,\n            block_type=BlockType.STANDALONE_CODE_BLOCK,\n            parent_id=parent_id,\n            file_path=file_path,\n        )\n\n        self.standalone_block_attributes = StandaloneCodeBlockSpecificAttributes(\n            variable_assignments=None,\n        )\n\n    def set_variable_assignments(\n        self, variable_declarations: list[str]\n    ) -> \"StandaloneBlockModelBuilder\":\n        \"\"\"Sets the list of variable declarations to the standalone code block model.\"\"\"\n        self.standalone_block_attributes.variable_assignments = variable_declarations\n        return self\n\n    def _get_standalone_block_specific_attributes(self) -> dict[str, Any]:\n        \"\"\"Gets the standalone block specific attributes.\"\"\"\n        return self.standalone_block_attributes.model_dump()\n\n    @logging_decorator(message=\"Building standalone code block model\")\n    def build(self) -> StandaloneCodeBlockModel:\n        \"\"\"Creates a StandaloneCodeBlockModel instance after building and setting the children models.\"\"\"\n        return StandaloneCodeBlockModel(\n            **self._get_common_attributes(),\n            **self._get_standalone_block_specific_attributes(),\n        )\n\n\nImported code block (postcode:models:models.py__*__MODULE) code content:\n\n\nclass CommentModel(BaseModel):\n    \"\"\"Class representing a comment.\"\"\"\n\n    content: str\n    comment_types: list[CommentType]\n\n    def convert_comment_to_metadata(self) -> str:\n        \"\"\"Converts the comment to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nImported code block (postcode:utilities:processing_context.py__*__MODULE) code content:\n\n\n@dataclass\nclass NodeAndPositionData:\n    \"\"\"A node in the syntax tree and its positional data.\"\"\"\n\n    nodes: list[libcst.CSTNode]\n    start: int\n    end: int\n\n, \n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_nodes\n\n        None, \nImported code block (postcode:utilities:logger:decorators.py__*__MODULE) code content:\n\n\ndef logging_decorator(\n    level=logging.DEBUG,\n    *,\n    message: str | None = None,\n    syntax_highlighting: bool = False,\n) -> Callable:\n    \"\"\"\n    A decorator for adding enhanced logging to functions, with optional syntax highlighting.\n\n    This decorator logs the call to the decorated function at the specified logging level. If syntax_highlighting is enabled and the first argument of the function is a libcst.CSTNode, the decorator logs the node's content with syntax highlighting.\n\n    Args:\n        level (int): The logging level. Defaults to logging.DEBUG.\n        message (str | None): Custom log message. If None, a default message is generated.\n        syntax_highlighting (bool): If True, enables syntax highlighting for libcst.CSTNode arguments.\n\n    Returns:\n        Callable: The decorated function with enhanced logging capability.\n\n    Example:\n        >>> @logging_decorator(level=logging.INFO, message=\"Function start\", syntax_highlighting=True)\n        >>> def sample_function(arg1):\n        >>>     pass\n        # This decorates 'sample_function' with enhanced logging at INFO level.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            log_message: str = (\n                message if message else (f\"Calling function: {func.__name__}\")\n            )\n            frame_info: inspect.FrameInfo = inspect.stack()[1]\n            caller_info: LoggingCallerInfo = _get_caller_info(frame_info)\n            code_content: str = _gather_code_content(syntax_highlighting, args)\n            logger: Logger = _get_logger(caller_info.caller_module_name)\n\n            _handle_logging(\n                logger,\n                caller_info,\n                level,\n                log_message,\n                syntax_highlighting,\n                code_content,\n            )\n\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n\n\nImported code block (postcode:models:models.py__*__MODULE) code content:\n\n\nclass CommentModel(BaseModel):\n    \"\"\"Class representing a comment.\"\"\"\n\n    content: str\n    comment_types: list[CommentType]\n\n    def convert_comment_to_metadata(self) -> str:\n        \"\"\"Converts the comment to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nImported code block (postcode:utilities:processing_context.py__*__MODULE) code content:\n\n\n@dataclass\nclass NodeAndPositionData:\n    \"\"\"A node in the syntax tree and its positional data.\"\"\"\n\n    nodes: list[libcst.CSTNode]\n    start: int\n    end: int\n\n, \nimport libcst\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_leading_lines\n\n        None, \nImported code block (postcode:models:models.py__*__MODULE) code content:\n\n\nclass CommentModel(BaseModel):\n    \"\"\"Class representing a comment.\"\"\"\n\n    content: str\n    comment_types: list[CommentType]\n\n    def convert_comment_to_metadata(self) -> str:\n        \"\"\"Converts the comment to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n, \nimport libcst\n        \n\nSummary:\n\n        postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_extract_variable_assignments\n\n        None, None, \nimport libcst\n        , None, None\n        ",
    "children_ids": [
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-gather_standalone_lines",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-process_standalone_blocks",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_class_or_function_def",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_is_import_statement",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_standalone_block",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_nodes",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_process_leading_lines",
        "postcode:python_parser:visitors:node_processing:standalone_code_block_functions.py__*__MODULE__*__FUNCTION-_extract_variable_assignments"
    ]
}